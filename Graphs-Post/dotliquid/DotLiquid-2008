D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Raw.cs	DotLiquid.Tags.Raw.Parse(System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	12	0	protected override void Parse ( List < string > tokens ) { if ( tokens != null ) ; NodeList = NodeList ?? new List < object > ( ) ; NodeList . Clear ( ) ; string token ; while ( ( token = tokens . Shift ( ) ) != null ) { Match fullTokenMatch = FullToken . Match ( token ) ; if ( fullTokenMatch . Success && BlockDelimiter == fullTokenMatch . Groups [ 1 ] . Value ) { EndTag ( ) ; return ; } else NodeList . Add ( token ) ; } AssertMissingDelimitation ( ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\CSharpNamingConvention.cs	DotLiquid.NamingConventions.CSharpNamingConvention.GetMemberName(System.String name)	name != null	1	21	0	public string GetMemberName ( string name ) { if ( name != null ) ; return name ; }	name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\StrFTime.cs	DotLiquid.Util.StrFTime.ToStrFTime(System.DateTime dateTime, System.String pattern)	dateTime != null	1	14	0	public static string ToStrFTime ( this DateTime dateTime , string pattern ) { if ( dateTime != null ) ; string output = "" ; int n = 0 ; while ( n < pattern . Length ) { string s = pattern . Substring ( n , 1 ) ; if ( n + 1 >= pattern . Length ) output += s ; else output += s == "%" ? Formats . ContainsKey ( pattern . Substring ( ++ n , 1 ) ) ? Formats [ pattern . Substring ( n , 1 ) ] . Invoke ( dateTime ) : "%" + pattern . Substring ( n , 1 ) : s ; n ++ ; } return output ; }	dateTime != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Literal.cs	DotLiquid.Tags.Literal.FromShortHand(System.String string)	string != null	1	97	0	public static string FromShortHand ( string @string ) { if ( string != null ) ; if ( @string == null ) return @string ; Match match = Regex . Match ( @string , Liquid . LiteralShorthand ) ; return match . Success ? string . Format ( @"{{%literal%}}{0}{{%endliteral%}}" , match . Groups [ 1 ] . Value ) : @string ; }	string != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_from != null	1	80	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _from != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_from != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template != null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Size(System.Object input)	ret >= 0	1	6	0	public static int Size ( object input ) { if ( ret >= 0 ) ; if ( input is string ) return ( ( string ) input ) . Length ; if ( input is IEnumerable ) return ( ( IEnumerable ) input ) . Cast < object > ( ) . Count ( ) ; return 0 ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.BlockDrop.Super()	_block != null	1	1	0	public void Super ( ) { if ( _block != null ) ; _block . CallSuper ( Context , _result ) ; }	_block != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_to == null	0.470588235294118	8	9	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _to == null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_to == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.GlobalFilter(System.Type filter)	DotLiquid.Strainer.Filters != null	1	97	0	public static void GlobalFilter ( Type filter ) { if ( DotLiquid . Strainer . Filters != null ) ; Filters [ filter . AssemblyQualifiedName ] = filter ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Parse(System.Collections.Generic.List`1<System.String> tokens)	DotLiquid.Block.ContentOfVariable != null	1	97	0	protected override void Parse ( List < string > tokens ) { if ( DotLiquid . Block . ContentOfVariable != null ) ; NodeList = NodeList ?? new List < object > ( ) ; NodeList . Clear ( ) ; string token ; while ( ( token = tokens . Shift ( ) ) != null ) { Match isTagMatch = IsTag . Match ( token ) ; if ( isTagMatch . Success ) { Match fullTokenMatch = FullToken . Match ( token ) ; if ( fullTokenMatch . Success ) { if ( BlockDelimiter == fullTokenMatch . Groups [ 1 ] . Value ) { EndTag ( ) ; return ; } Type tagType ; if ( ( tagType = Template . GetTagType ( fullTokenMatch . Groups [ 1 ] . Value ) ) != null ) { Tag tag = ( Tag ) Activator . CreateInstance ( tagType ) ; tag . Initialize ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; NodeList . Add ( tag ) ; tag . AssertTagRulesViolation ( NodeList ) ; } else { UnknownTag ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; } } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagNotTerminatedException" ) , token , Liquid . TagEnd ) ; } } else if ( IsVariable . Match ( token ) . Success ) { NodeList . Add ( CreateVariable ( token ) ) ; } else if ( token == string . Empty ) { } else { NodeList . Add ( token ) ; } } AssertMissingDelimitation ( ) ; }	DotLiquid . Block . ContentOfVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\CSharpNamingConvention.cs	DotLiquid.NamingConventions.CSharpNamingConvention.GetMemberName(System.String name)	name.ToString().Equals("Test")	0.333333333333333	7	14	public string GetMemberName ( string name ) { if ( name . ToString ( ) . Equals ( "Test" ) ) ; return name ; }	name . ToString ( ) . Equals ( "Test" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_attributes != null	1	70	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _attributes != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_attributes != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\IfChanged.cs	DotLiquid.Tags.IfChanged.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; context . Stack ( ( ) => { string tempString ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; tempString = temp . ToString ( ) ; } if ( tempString != ( context . Registers [ "ifchanged" ] as string ) ) { context . Registers [ "ifchanged" ] = tempString ; result . Write ( tempString ) ; } } ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\ObjectExtensionMethods.cs	DotLiquid.Util.ObjectExtensionMethods.Send(System.Object value, System.String member, System.Object[] parameters)	value != null	1	25	0	public static object Send ( this object value , string member , object [ ] parameters ) { if ( value != null ) ; else public static object Send ( this object value , string member , object [ ] parameters = null ) { if ( value == null ) throw new ArgumentNullException ( "value" ) ; Type type = value . GetType ( ) ; MethodInfo methodInfo = type . GetMethod ( member ) ; if ( methodInfo != null ) return methodInfo . Invoke ( value , parameters ) ; PropertyInfo propertyInfo = type . GetProperty ( member ) ; if ( propertyInfo != null ) return propertyInfo . GetValue ( value , null ) ; return null ; } }	value != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName != null	1	51	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_blocks != null	1	62	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _blocks != null ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_blocks != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\ListExtensionMethods.cs	DotLiquid.Util.ListExtensionMethods.Shift(System.Collections.Generic.List`1<T> list)	list != null	1	97	0	public static T Shift < T > ( this List < T > list ) where T : class { if ( list != null ) ; if ( list == null || list . Count == 0 ) return null ; T result = list [ 0 ] ; list . RemoveAt ( 0 ) ; return result ; }	list != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\EmbeddedFileSystem.cs	DotLiquid.FileSystems.EmbeddedFileSystem.FullPath(System.String templatePath)	templatePath != null	1	4	0	public string FullPath ( string templatePath ) { if ( templatePath != null ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; var basePath = templatePath . Contains ( "/" ) ? Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) : Root ; var fileName = string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ; var fullPath = Regex . Replace ( Path . Combine ( basePath , fileName ) , @"\\|/" , "." ) ; return fullPath ; }	templatePath != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1 != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.ReadTemplateFile(DotLiquid.Context context, System.String templateName)	context != null	1	18	0	public string ReadTemplateFile ( Context context , string templateName ) { if ( context != null ) ; string templatePath = ( string ) context [ templateName ] ; string fullPath = FullPath ( templatePath ) ; if ( ! File . Exists ( fullPath ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemTemplateNotFoundException" ) , templatePath ) ; return File . ReadAllText ( fullPath ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\CSharpNamingConvention.cs	DotLiquid.NamingConventions.CSharpNamingConvention.GetMemberName(System.String name)	ret != null	1	21	0	public string GetMemberName ( string name ) { if ( ret != null ) ; return name ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Succ(System.Int32 val)	val >= 1	1	23	0	internal static int Succ ( int val ) { if ( val >= 1 ) ; return val + 1 ; }	val >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_attributes != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _attributes != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_attributes != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName == null	1	97	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName == null ) ; Parse ( tokens ) ; }	tagName == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\StrFTime.cs	DotLiquid.Util.StrFTime.ToStrFTime(System.DateTime dateTime, System.String pattern)	pattern != null	1	14	0	public static string ToStrFTime ( this DateTime dateTime , string pattern ) { if ( pattern != null ) ; string output = "" ; int n = 0 ; while ( n < pattern . Length ) { string s = pattern . Substring ( n , 1 ) ; if ( n + 1 >= pattern . Length ) output += s ; else output += s == "%" ? Formats . ContainsKey ( pattern . Substring ( ++ n , 1 ) ) ? Formats [ pattern . Substring ( n , 1 ) ] . Invoke ( dateTime ) : "%" + pattern . Substring ( n , 1 ) : s ; n ++ ; } return output ; }	pattern != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\EnumerableExtensionMethods.cs	DotLiquid.Util.EnumerableExtensionMethods.Flatten(System.Collections.IEnumerable array)	array != null	1	13	0	public static IEnumerable Flatten ( this IEnumerable array ) { if ( array != null ) ; foreach ( var item in array ) if ( item is string ) yield return item ; else if ( item is IEnumerable ) foreach ( var subitem in Flatten ( ( IEnumerable ) item ) ) { yield return subitem ; } else yield return item ; }	array != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Q(System.String regex)	regex != null	1	97	0	public static string Q ( string regex ) { if ( regex != null ) ; return string . Format ( "(?-mix:{0})" , regex ) ; }	regex != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Collections.Generic.IEnumerable`1<System.Type> filters)	_rethrowErrors == false	1	77	0	public void AddFilters ( IEnumerable < Type > filters ) { if ( _rethrowErrors == false ) ; foreach ( Type f in filters ) Strainer . Extend ( f ) ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_attributes != null	1	90	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _attributes != null ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_attributes != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Comment.cs	DotLiquid.Tags.Comment.FromShortHand(System.String string)	string != null	1	97	0	public static string FromShortHand ( string @string ) { if ( string != null ) ; if ( @string == null ) return @string ; Match match = Regex . Match ( @string , Liquid . CommentShorthand ) ; return match . Success ? string . Format ( @"{{%comment%}}{0}{{%endcomment%}}" , match . Groups [ 1 ] . Value ) : @string ; }	string != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name != null ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	_name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.ReadTemplateFile(DotLiquid.Context context, System.String templateName)	context._rethrowErrors == true	0.5	9	9	public string ReadTemplateFile ( Context context , string templateName ) { if ( context . _rethrowErrors == true ) ; string templatePath = ( string ) context [ templateName ] ; string fullPath = FullPath ( templatePath ) ; if ( ! File . Exists ( fullPath ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemTemplateNotFoundException" ) , templatePath ) ; return File . ReadAllText ( fullPath ) ; }	context . _rethrowErrors == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromAnonymousObject(System.Object anonymousObject)	anonymousObject != null	1	97	0	public static Hash FromAnonymousObject ( object anonymousObject ) { if ( anonymousObject != null ) ; Hash result = new Hash ( ) ; if ( anonymousObject != null ) foreach ( PropertyInfo property in anonymousObject . GetType ( ) . GetProperties ( ) ) result [ property . Name ] = property . GetValue ( anonymousObject , null ) ; return result ; }	anonymousObject != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.AssertTagRulesViolation(System.Collections.Generic.List`1<System.Object> rootNodeList)	rootNodeList != null	1	97	0	internal virtual void AssertTagRulesViolation ( List < object > rootNodeList ) { if ( rootNodeList != null ) ; }	rootNodeList != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	DotLiquid.Condition.Operators != null	1	87	0	public virtual bool Evaluate ( Context context ) { if ( DotLiquid . Condition . Operators != null ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	DotLiquid . Condition . Operators != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.capnames == null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . capnames == null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . capnames == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.BeforeMethod(System.String method)	_resolution != null	1	28	0	public virtual object BeforeMethod ( string method ) { if ( _resolution != null ) ; if ( Template . NamingConvention is RubyNamingConvention ) { string rubyMethod = Template . NamingConvention . GetMemberName ( method ) ; MethodInfo mi ; PropertyInfo pi ; if ( TypeResolution . CachedMethods . TryGetValue ( rubyMethod , out mi ) || TypeResolution . CachedProperties . TryGetValue ( rubyMethod , out pi ) ) { return string . Format ( Liquid . ResourceManager . GetString ( "DropWrongNamingConventionMessage" ) , rubyMethod ) ; } } return null ; }	_resolution != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterTag(System.String name)	DotLiquid.Template.NamingConvention != null	1	97	0	public static void RegisterTag < T > ( string name ) where T : Tag , new ( ) { if ( DotLiquid . Template . NamingConvention != null ) ; Tags [ name ] = typeof ( T ) ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\StrFTime.cs	DotLiquid.Util.StrFTime.ToStrFTime(System.DateTime dateTime, System.String pattern)	pattern.ToString().Equals("%Z")	0.785714285714286	11	3	public static string ToStrFTime ( this DateTime dateTime , string pattern ) { if ( pattern . ToString ( ) . Equals ( "%Z" ) ) ; string output = "" ; int n = 0 ; while ( n < pattern . Length ) { string s = pattern . Substring ( n , 1 ) ; if ( n + 1 >= pattern . Length ) output += s ; else output += s == "%" ? Formats . ContainsKey ( pattern . Substring ( ++ n , 1 ) ) ? Formats [ pattern . Substring ( n , 1 ) ] . Invoke ( dateTime ) : "%" + pattern . Substring ( n , 1 ) : s ; n ++ ; } return output ; }	pattern . ToString ( ) . Equals ( "%Z" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.GlobalFilter(System.Type filter)	filter != null	1	97	0	public static void GlobalFilter ( Type filter ) { if ( filter != null ) ; Filters [ filter . AssemblyQualifiedName ] = filter ; }	filter != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\EnumerableExtensionMethods.cs	DotLiquid.Util.EnumerableExtensionMethods.Flatten(System.Collections.IEnumerable array)	ret != null	1	13	0	public static IEnumerable Flatten ( this IEnumerable array ) { if ( ret != null ) ; foreach ( var item in array ) if ( item is string ) yield return item ; else if ( item is IEnumerable ) foreach ( var subitem in Flatten ( ( IEnumerable ) item ) ) { yield return subitem ; } else yield return item ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup == null	1	97	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup == null ) ; Parse ( tokens ) ; }	markup == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\IfChanged.cs	DotLiquid.Tags.IfChanged.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; context . Stack ( ( ) => { string tempString ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; tempString = temp . ToString ( ) ; } if ( tempString != ( context . Registers [ "ifchanged" ] as string ) ) { context . Registers [ "ifchanged" ] = tempString ; result . Write ( tempString ) ; } } ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Succ(System.Int32 val)	ret >= 0	1	23	0	internal static int Succ ( int val ) { if ( ret >= 0 ) ; return val + 1 ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	97	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; Parse ( tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left != null	1	62	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _left != null ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_left != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Literal.cs	DotLiquid.Tags.Literal.FromShortHand(System.String string)	ret != null	1	97	0	public static string FromShortHand ( string @string ) { if ( ret != null ) ; if ( @string == null ) return @string ; Match match = Regex . Match ( @string , Liquid . LiteralShorthand ) ; return match . Success ? string . Format ( @"{{%literal%}}{0}{{%endliteral%}}" , match . Groups [ 1 ] . Value ) : @string ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\ObjectExtensionMethods.cs	DotLiquid.Util.ObjectExtensionMethods.Send(System.Object value, System.String member, System.Object[] parameters)	member != null	1	25	0	public static object Send ( this object value , string member , object [ ] parameters ) { if ( member != null ) ; else public static object Send ( this object value , string member , object [ ] parameters = null ) { if ( value == null ) throw new ArgumentNullException ( "value" ) ; Type type = value . GetType ( ) ; MethodInfo methodInfo = type . GetMethod ( member ) ; if ( methodInfo != null ) return methodInfo . Invoke ( value , parameters ) ; PropertyInfo propertyInfo = type . GetProperty ( member ) ; if ( propertyInfo != null ) return propertyInfo . GetValue ( value , null ) ; return null ; } }	member != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_from._markup != null	1	80	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _from . _markup != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_from . _markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_to != null	0.470588235294118	8	9	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _to != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_to != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\CSharpNamingConvention.cs	DotLiquid.NamingConventions.CSharpNamingConvention.GetMemberName(System.String name)	ret.Equals(name)	1	21	0	public string GetMemberName ( string name ) { if ( ret . Equals ( name ) ) ; return name ; }	ret . Equals ( name )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._assigns != null	0.88659793814433	86	11	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _assigns != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _assigns != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.BlockDrop.Super()	_result != null	1	1	0	public void Super ( ) { if ( _result != null ) ; _block . CallSuper ( Context , _result ) ; }	_result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'complex'")	0.274509803921569	14	37	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'complex'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'complex'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_attributes >= 0	0.0142857142857143	1	69	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _attributes >= 0 ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_attributes >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\TypeUtility.cs	DotLiquid.Util.TypeUtility.IsAnonymousType(System.Type t)	t != null	1	95	0	public static bool IsAnonymousType ( Type t ) { if ( t != null ) ; return Attribute . IsDefined ( t , typeof ( CompilerGeneratedAttribute ) , false ) && t . IsGenericType && ( t . Name . Contains ( "AnonymousType" ) || t . Name . Contains ( "AnonType" ) ) && ( t . Name . StartsWith ( "<>" ) || t . Name . StartsWith ( "VB$" ) ) && ( t . Attributes & AnonymousTypeAttributes ) == AnonymousTypeAttributes ; }	t != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_attributes >= 0	0.0222222222222222	2	88	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _attributes >= 0 ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_attributes >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Comment.cs	DotLiquid.Tags.Comment.FromShortHand(System.String string)	ret != null	1	97	0	public static string FromShortHand ( string @string ) { if ( ret != null ) ; if ( @string == null ) return @string ; Match match = Regex . Match ( @string , Liquid . CommentShorthand ) ; return match . Success ? string . Format ( @"{{%comment%}}{0}{{%endcomment%}}" , match . Groups [ 1 ] . Value ) : @string ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\EmbeddedFileSystem.cs	DotLiquid.FileSystems.EmbeddedFileSystem.FullPath(System.String templatePath)	ret != null	1	4	0	public string FullPath ( string templatePath ) { if ( ret != null ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; var basePath = templatePath . Contains ( "/" ) ? Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) : Root ; var fileName = string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ; var fullPath = Regex . Replace ( Path . Combine ( basePath , fileName ) , @"\\|/" , "." ) ; return fullPath ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.caps == null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . caps == null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . caps == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Q(System.String regex)	ret != null	1	97	0	public static string Q ( string regex ) { if ( ret != null ) ; return string . Format ( "(?-mix:{0})" , regex ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	97	0	public virtual void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; TagName = tagName ; Markup = markup ; Parse ( tokens ) ; }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.BeforeMethod(System.String method)	method != null	0.964285714285714	27	1	public virtual object BeforeMethod ( string method ) { if ( method != null ) ; if ( Template . NamingConvention is RubyNamingConvention ) { string rubyMethod = Template . NamingConvention . GetMemberName ( method ) ; MethodInfo mi ; PropertyInfo pi ; if ( TypeResolution . CachedMethods . TryGetValue ( rubyMethod , out mi ) || TypeResolution . CachedProperties . TryGetValue ( rubyMethod , out pi ) ) { return string . Format ( Liquid . ResourceManager . GetString ( "DropWrongNamingConventionMessage" ) , rubyMethod ) ; } } return null ; }	method != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name >= 0	0.0384615384615385	1	25	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name >= 0 ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	_name >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Parse(System.Collections.Generic.List`1<System.String> tokens)	DotLiquid.Block.FullToken != null	1	97	0	protected override void Parse ( List < string > tokens ) { if ( DotLiquid . Block . FullToken != null ) ; NodeList = NodeList ?? new List < object > ( ) ; NodeList . Clear ( ) ; string token ; while ( ( token = tokens . Shift ( ) ) != null ) { Match isTagMatch = IsTag . Match ( token ) ; if ( isTagMatch . Success ) { Match fullTokenMatch = FullToken . Match ( token ) ; if ( fullTokenMatch . Success ) { if ( BlockDelimiter == fullTokenMatch . Groups [ 1 ] . Value ) { EndTag ( ) ; return ; } Type tagType ; if ( ( tagType = Template . GetTagType ( fullTokenMatch . Groups [ 1 ] . Value ) ) != null ) { Tag tag = ( Tag ) Activator . CreateInstance ( tagType ) ; tag . Initialize ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; NodeList . Add ( tag ) ; tag . AssertTagRulesViolation ( NodeList ) ; } else { UnknownTag ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; } } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagNotTerminatedException" ) , token , Liquid . TagEnd ) ; } } else if ( IsVariable . Match ( token ) . Success ) { NodeList . Add ( CreateVariable ( token ) ) ; } else if ( token == string . Empty ) { } else { NodeList . Add ( token ) ; } } AssertMissingDelimitation ( ) ; }	DotLiquid . Block . FullToken != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\StrFTime.cs	DotLiquid.Util.StrFTime.ToStrFTime(System.DateTime dateTime, System.String pattern)	ret != null	1	14	0	public static string ToStrFTime ( this DateTime dateTime , string pattern ) { if ( ret != null ) ; string output = "" ; int n = 0 ; while ( n < pattern . Length ) { string s = pattern . Substring ( n , 1 ) ; if ( n + 1 >= pattern . Length ) output += s ; else output += s == "%" ? Formats . ContainsKey ( pattern . Substring ( ++ n , 1 ) ) ? Formats [ pattern . Substring ( n , 1 ) ] . Invoke ( dateTime ) : "%" + pattern . Substring ( n , 1 ) : s ; n ++ ; } return output ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.ReadTemplateFile(DotLiquid.Context context, System.String templateName)	context._strainer == null	1	18	0	public string ReadTemplateFile ( Context context , string templateName ) { if ( context . _strainer == null ) ; string templatePath = ( string ) context [ templateName ] ; string fullPath = FullPath ( templatePath ) ; if ( ! File . Exists ( fullPath ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemTemplateNotFoundException" ) , templatePath ) ; return File . ReadAllText ( fullPath ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterTag(System.String name)	DotLiquid.Template.SafeTypeTransformers != null	1	97	0	public static void RegisterTag < T > ( string name ) where T : Tag , new ( ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; Tags [ name ] = typeof ( T ) ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromAnonymousObject(System.Object anonymousObject)	ret != null	1	97	0	public static Hash FromAnonymousObject ( object anonymousObject ) { if ( ret != null ) ; Hash result = new Hash ( ) ; if ( anonymousObject != null ) foreach ( PropertyInfo property in anonymousObject . GetType ( ) . GetProperties ( ) ) result [ property . Name ] = property . GetValue ( anonymousObject , null ) ; return result ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\IfChanged.cs	DotLiquid.Tags.IfChanged.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; context . Stack ( ( ) => { string tempString ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; tempString = temp . ToString ( ) ; } if ( tempString != ( context . Registers [ "ifchanged" ] as string ) ) { context . Registers [ "ifchanged" ] = tempString ; result . Write ( tempString ) ; } } ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Literal.cs	DotLiquid.Tags.Literal.FromShortHand(System.String string)	ret.Equals(string)	0.876288659793814	85	12	public static string FromShortHand ( string @string ) { if ( ret . Equals ( string ) ) ; if ( @string == null ) return @string ; Match match = Regex . Match ( @string , Liquid . LiteralShorthand ) ; return match . Success ? string . Format ( @"{{%literal%}}{0}{{%endliteral%}}" , match . Groups [ 1 ] . Value ) : @string ; }	ret . Equals ( string )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	DotLiquid.Strainer.Filters != null	1	93	0	public static Strainer Create ( Context context ) { if ( DotLiquid . Strainer . Filters != null ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	DotLiquid.Variable.FilterParser != null	1	80	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( DotLiquid . Variable . FilterParser != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	DotLiquid . Variable . FilterParser != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	17	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\CSharpNamingConvention.cs	DotLiquid.NamingConventions.CSharpNamingConvention.GetMemberName(System.String name)	ret.ToString().Equals("Test")	0.333333333333333	7	14	public string GetMemberName ( string name ) { if ( ret . ToString ( ) . Equals ( "Test" ) ) ; return name ; }	ret . ToString ( ) . Equals ( "Test" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_collectionName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\EnumerableExtensionMethods.cs	DotLiquid.Util.EnumerableExtensionMethods.EachWithIndex(System.Collections.Generic.IEnumerable`1<System.Object> array, System.Action`2<System.Object, System.Int32> callback)	array != null	1	26	0	public static void EachWithIndex ( this IEnumerable < object > array , Action < object , int > callback ) { if ( array != null ) ; int index = 0 ; ; foreach ( object item in array ) { callback ( item , index ) ; ++ index ; } }	array != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._assigns._defaultValue == null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _assigns . _defaultValue == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _assigns . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.BlockRenderState.GetNodeList(DotLiquid.Tags.Block block)	block != null	1	4	0	public List < object > GetNodeList ( Block block ) { if ( block != null ) ; List < object > nodeList ; if ( ! NodeLists . TryGetValue ( block , out nodeList ) ) nodeList = block . NodeList ; return nodeList ; }	block != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\ObjectExtensionMethods.cs	DotLiquid.Util.ObjectExtensionMethods.Send(System.Object value, System.String member, System.Object[] parameters)	member.ToString().Equals("a")	0.84	21	4	public static object Send ( this object value , string member , object [ ] parameters ) { if ( member . ToString ( ) . Equals ( "a" ) ) ; else public static object Send ( this object value , string member , object [ ] parameters = null ) { if ( value == null ) throw new ArgumentNullException ( "value" ) ; Type type = value . GetType ( ) ; MethodInfo methodInfo = type . GetMethod ( member ) ; if ( methodInfo != null ) return methodInfo . Invoke ( value , parameters ) ; PropertyInfo propertyInfo = type . GetProperty ( member ) ; if ( propertyInfo != null ) return propertyInfo . GetValue ( value , null ) ; return null ; } }	member . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Collections.Generic.IEnumerable`1<System.Type> filters)	_strainer != null	0.987012987012987	76	1	public void AddFilters ( IEnumerable < Type > filters ) { if ( _strainer != null ) ; foreach ( Type f in filters ) Strainer . Extend ( f ) ; }	_strainer != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	exception != null	0.865979381443299	84	13	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( exception != null ) ; Parse ( tokens ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\TypeUtility.cs	DotLiquid.Util.TypeUtility.IsAnonymousType(System.Type t)	ret == false	0.673684210526316	64	31	public static bool IsAnonymousType ( Type t ) { if ( ret == false ) ; return Attribute . IsDefined ( t , typeof ( CompilerGeneratedAttribute ) , false ) && t . IsGenericType && ( t . Name . Contains ( "AnonymousType" ) || t . Name . Contains ( "AnonType" ) ) && ( t . Name . StartsWith ( "<>" ) || t . Name . StartsWith ( "VB$" ) ) && ( t . Attributes & AnonymousTypeAttributes ) == AnonymousTypeAttributes ; }	ret == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Comment.cs	DotLiquid.Tags.Comment.FromShortHand(System.String string)	ret.Equals(string)	1	97	0	public static string FromShortHand ( string @string ) { if ( ret . Equals ( string ) ) ; if ( @string == null ) return @string ; Match match = Regex . Match ( @string , Liquid . CommentShorthand ) ; return match . Success ? string . Format ( @"{{%comment%}}{0}{{%endcomment%}}" , match . Groups [ 1 ] . Value ) : @string ; }	ret . Equals ( string )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Downcase(System.String input)	input.ToString().Equals("Testing")	1	10	0	public static string Downcase ( string input ) { if ( input . ToString ( ) . Equals ( "Testing" ) ) ; return input == null ? input : input . ToLower ( ) ; }	input . ToString ( ) . Equals ( "Testing" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	_childCondition == null	0.885057471264368	77	10	public virtual bool Evaluate ( Context context ) { if ( _childCondition == null ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	_childCondition == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left.ToString().Equals("condition")	0.338709677419355	21	41	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _left . ToString ( ) . Equals ( "condition" ) ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_left . ToString ( ) . Equals ( "condition" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.BeforeMethod(System.String method)	method >= 0	0.0357142857142857	1	27	public virtual object BeforeMethod ( string method ) { if ( method >= 0 ) ; if ( Template . NamingConvention is RubyNamingConvention ) { string rubyMethod = Template . NamingConvention . GetMemberName ( method ) ; MethodInfo mi ; PropertyInfo pi ; if ( TypeResolution . CachedMethods . TryGetValue ( rubyMethod , out mi ) || TypeResolution . CachedProperties . TryGetValue ( rubyMethod , out pi ) ) { return string . Format ( Liquid . ResourceManager . GetString ( "DropWrongNamingConventionMessage" ) , rubyMethod ) ; } } return null ; }	method >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Q(System.String regex)	ret >= 0	0.0103092783505155	1	96	public static string Q ( string regex ) { if ( ret >= 0 ) ; return string . Format ( "(?-mix:{0})" , regex ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterTag(System.String name)	DotLiquid.Template.ValueTypeTransformers != null	1	97	0	public static void RegisterTag < T > ( string name ) where T : Tag , new ( ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; Tags [ name ] = typeof ( T ) ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	context != null	1	93	0	public static Strainer Create ( Context context ) { if ( context != null ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromAnonymousObject(System.Object anonymousObject)	ret >= 0	0.0412371134020619	4	93	public static Hash FromAnonymousObject ( object anonymousObject ) { if ( ret >= 0 ) ; Hash result = new Hash ( ) ; if ( anonymousObject != null ) foreach ( PropertyInfo property in anonymousObject . GetType ( ) . GetProperties ( ) ) result [ property . Name ] = property . GetValue ( anonymousObject , null ) ; return result ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\EmbeddedFileSystem.cs	DotLiquid.FileSystems.EmbeddedFileSystem.FullPath(System.String templatePath)	exception != null	1	4	0	public string FullPath ( string templatePath ) { if ( exception != null ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; var basePath = templatePath . Contains ( "/" ) ? Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) : Root ; var fileName = string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ; var fullPath = Regex . Replace ( Path . Combine ( basePath , fileName ) , @"\\|/" , "." ) ; return fullPath ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName != null	1	70	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("include")	0.0103092783505155	1	96	public virtual void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "include" ) ) ; TagName = tagName ; Markup = markup ; Parse ( tokens ) ; }	tagName . ToString ( ) . Equals ( "include" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._assigns._lambda == null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _assigns . _lambda == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _assigns . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("capture")	1	17	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "capture" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName . ToString ( ) . Equals ( "capture" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Literal.cs	DotLiquid.Tags.Literal.Parse(System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	32	0	protected override void Parse ( List < string > tokens ) { if ( tokens != null ) ; NodeList = NodeList ?? new List < object > ( ) ; NodeList . Clear ( ) ; string token ; while ( ( token = tokens . Shift ( ) ) != null ) { Match fullTokenMatch = FullToken . Match ( token ) ; if ( fullTokenMatch . Success && BlockDelimiter == fullTokenMatch . Groups [ 1 ] . Value ) { EndTag ( ) ; return ; } else NodeList . Add ( token ) ; } AssertMissingDelimitation ( ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variables.Count == 2	0.653846153846154	17	9	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variables . Count == 2 ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	_variables . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_to != null	1	80	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _to != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_to != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.BlockRenderState.GetNodeList(DotLiquid.Tags.Block block)	ret != null	1	4	0	public List < object > GetNodeList ( Block block ) { if ( ret != null ) ; List < object > nodeList ; if ( ! NodeLists . TryGetValue ( block , out nodeList ) ) nodeList = block . NodeList ; return nodeList ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\IfChanged.cs	DotLiquid.Tags.IfChanged.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; context . Stack ( ( ) => { string tempString ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; tempString = temp . ToString ( ) ; } if ( tempString != ( context . Registers [ "ifchanged" ] as string ) ) { context . Registers [ "ifchanged" ] = tempString ; result . Write ( tempString ) ; } } ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.capsize >= 0	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . capsize >= 0 ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . capsize >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\EnumerableExtensionMethods.cs	DotLiquid.Util.EnumerableExtensionMethods.EachWithIndex(System.Collections.Generic.IEnumerable`1<System.Object> array, System.Action`2<System.Object, System.Int32> callback)	callback != null	1	26	0	public static void EachWithIndex ( this IEnumerable < object > array , Action < object , int > callback ) { if ( callback != null ) ; int index = 0 ; ; foreach ( object item in array ) { callback ( item , index ) ; ++ index ; } }	callback != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.ReadTemplateFile(DotLiquid.Context context, System.String templateName)	templateName != null	1	18	0	public string ReadTemplateFile ( Context context , string templateName ) { if ( templateName != null ) ; string templatePath = ( string ) context [ templateName ] ; string fullPath = FullPath ( templatePath ) ; if ( ! File . Exists ( fullPath ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemTemplateNotFoundException" ) , templatePath ) ; return File . ReadAllText ( fullPath ) ; }	templateName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Parse(System.Collections.Generic.List`1<System.String> tokens)	DotLiquid.Block.IsTag != null	1	97	0	protected override void Parse ( List < string > tokens ) { if ( DotLiquid . Block . IsTag != null ) ; NodeList = NodeList ?? new List < object > ( ) ; NodeList . Clear ( ) ; string token ; while ( ( token = tokens . Shift ( ) ) != null ) { Match isTagMatch = IsTag . Match ( token ) ; if ( isTagMatch . Success ) { Match fullTokenMatch = FullToken . Match ( token ) ; if ( fullTokenMatch . Success ) { if ( BlockDelimiter == fullTokenMatch . Groups [ 1 ] . Value ) { EndTag ( ) ; return ; } Type tagType ; if ( ( tagType = Template . GetTagType ( fullTokenMatch . Groups [ 1 ] . Value ) ) != null ) { Tag tag = ( Tag ) Activator . CreateInstance ( tagType ) ; tag . Initialize ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; NodeList . Add ( tag ) ; tag . AssertTagRulesViolation ( NodeList ) ; } else { UnknownTag ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; } } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagNotTerminatedException" ) , token , Liquid . TagEnd ) ; } } else if ( IsVariable . Match ( token ) . Success ) { NodeList . Add ( CreateVariable ( token ) ) ; } else if ( token == string . Empty ) { } else { NodeList . Add ( token ) ; } } AssertMissingDelimitation ( ) ; }	DotLiquid . Block . IsTag != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'middle'")	0.274509803921569	14	37	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'middle'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'middle'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Variable.FilterParser != null	1	97	0	public void Render ( Context context , TextWriter result ) { if ( DotLiquid . Variable . FilterParser != null ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	DotLiquid . Variable . FilterParser != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\ObjectExtensionMethods.cs	DotLiquid.Util.ObjectExtensionMethods.Send(System.Object value, System.String member, System.Object[] parameters)	member.ToString().Equals("NodeList")	0.16	4	21	public static object Send ( this object value , string member , object [ ] parameters ) { if ( member . ToString ( ) . Equals ( "NodeList" ) ) ; else public static object Send ( this object value , string member , object [ ] parameters = null ) { if ( value == null ) throw new ArgumentNullException ( "value" ) ; Type type = value . GetType ( ) ; MethodInfo methodInfo = type . GetMethod ( member ) ; if ( methodInfo != null ) return methodInfo . Invoke ( value , parameters ) ; PropertyInfo propertyInfo = type . GetProperty ( member ) ; if ( propertyInfo != null ) return propertyInfo . GetValue ( value , null ) ; return null ; } }	member . ToString ( ) . Equals ( "NodeList" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\StrFTime.cs	DotLiquid.Util.StrFTime.ToStrFTime(System.DateTime dateTime, System.String pattern)	ret.ToString().Equals("-08:00")	0.785714285714286	11	3	public static string ToStrFTime ( this DateTime dateTime , string pattern ) { if ( ret . ToString ( ) . Equals ( "-08:00" ) ) ; string output = "" ; int n = 0 ; while ( n < pattern . Length ) { string s = pattern . Substring ( n , 1 ) ; if ( n + 1 >= pattern . Length ) output += s ; else output += s == "%" ? Formats . ContainsKey ( pattern . Substring ( ++ n , 1 ) ) ? Formats [ pattern . Substring ( n , 1 ) ] . Invoke ( dateTime ) : "%" + pattern . Substring ( n , 1 ) : s ; n ++ ; } return output ; }	ret . ToString ( ) . Equals ( "-08:00" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName.ToString().Equals("numbers")	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName . ToString ( ) . Equals ( "numbers" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_collectionName . ToString ( ) . Equals ( "numbers" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\TypeUtility.cs	DotLiquid.Util.TypeUtility.IsAnonymousType(System.Type t)	ret == true	0.0210526315789474	2	93	public static bool IsAnonymousType ( Type t ) { if ( ret == true ) ; return Attribute . IsDefined ( t , typeof ( CompilerGeneratedAttribute ) , false ) && t . IsGenericType && ( t . Name . Contains ( "AnonymousType" ) || t . Name . Contains ( "AnonType" ) ) && ( t . Name . StartsWith ( "<>" ) || t . Name . StartsWith ( "VB$" ) ) && ( t . Attributes & AnonymousTypeAttributes ) == AnonymousTypeAttributes ; }	ret == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	format != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( format != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	format != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Comment.cs	DotLiquid.Tags.Comment.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	7	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterTag(System.String name)	name != null	1	97	0	public static void RegisterTag < T > ( string name ) where T : Tag , new ( ) { if ( name != null ) ; Tags [ name ] = typeof ( T ) ; }	name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromAnonymousObject(System.Object anonymousObject)	ret._defaultValue == null	1	97	0	public static Hash FromAnonymousObject ( object anonymousObject ) { if ( ret . _defaultValue == null ) ; Hash result = new Hash ( ) ; if ( anonymousObject != null ) foreach ( PropertyInfo property in anonymousObject . GetType ( ) . GetProperties ( ) ) result [ property . Name ] = property . GetValue ( anonymousObject , null ) ; return result ; }	ret . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.BeforeMethod(System.String method)	method.ToString().Equals("Name")	0.25	7	21	public virtual object BeforeMethod ( string method ) { if ( method . ToString ( ) . Equals ( "Name" ) ) ; if ( Template . NamingConvention is RubyNamingConvention ) { string rubyMethod = Template . NamingConvention . GetMemberName ( method ) ; MethodInfo mi ; PropertyInfo pi ; if ( TypeResolution . CachedMethods . TryGetValue ( rubyMethod , out mi ) || TypeResolution . CachedProperties . TryGetValue ( rubyMethod , out pi ) ) { return string . Format ( Liquid . ResourceManager . GetString ( "DropWrongNamingConventionMessage" ) , rubyMethod ) ; } } return null ; }	method . ToString ( ) . Equals ( "Name" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName != null	1	90	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName != null ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_collectionName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	0.917525773195876	89	8	public virtual void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; TagName = tagName ; Markup = markup ; Parse ( tokens ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.capslist == null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . capslist == null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . capslist == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName >= 0	0.0142857142857143	1	69	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName >= 0 ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left.ToString().Equals("a.size")	0.145161290322581	9	53	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _left . ToString ( ) . Equals ( "a.size" ) ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_left . ToString ( ) . Equals ( "a.size" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	context._rethrowErrors == false	1	93	0	public static Strainer Create ( Context context ) { if ( context . _rethrowErrors == false ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	17	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Collections.Generic.IEnumerable`1<System.Type> filters)	_strainer >= 0	0.012987012987013	1	76	public void AddFilters ( IEnumerable < Type > filters ) { if ( _strainer >= 0 ) ; foreach ( Type f in filters ) Strainer . Extend ( f ) ; }	_strainer >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._assigns._nestedDictionary != null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _assigns . _nestedDictionary != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _assigns . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	97	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.BlockRenderState.Find(DotLiquid.Context context)	context != null	1	4	0	public static BlockRenderState Find ( Context context ) { if ( context != null ) ; foreach ( Hash scope in context . Scopes ) { object blockState ; if ( scope . TryGetValue ( "blockstate" , out blockState ) ) { return blockState as BlockRenderState ; } } return null ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_to.ToString().Equals("a")	0.025	2	78	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _to . ToString ( ) . Equals ( "a" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_to . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Downcase(System.String input)	ret.ToString().Equals("testing")	1	10	0	public static string Downcase ( string input ) { if ( ret . ToString ( ) . Equals ( "testing" ) ) ; return input == null ? input : input . ToLower ( ) ; }	ret . ToString ( ) . Equals ( "testing" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variables != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variables != null ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	_variables != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.ReadTemplateFile(DotLiquid.Context context, System.String templateName)	templateName >= 0	0.0555555555555556	1	17	public string ReadTemplateFile ( Context context , string templateName ) { if ( templateName >= 0 ) ; string templatePath = ( string ) context [ templateName ] ; string fullPath = FullPath ( templatePath ) ; if ( ! File . Exists ( fullPath ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemTemplateNotFoundException" ) , templatePath ) ; return File . ReadAllText ( fullPath ) ; }	templateName >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromAnonymousObject(System.Object anonymousObject)	ret._lambda == null	1	97	0	public static Hash FromAnonymousObject ( object anonymousObject ) { if ( ret . _lambda == null ) ; Hash result = new Hash ( ) ; if ( anonymousObject != null ) foreach ( PropertyInfo property in anonymousObject . GetType ( ) . GetProperties ( ) ) result [ property . Name ] = property . GetValue ( anonymousObject , null ) ; return result ; }	ret . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets.Count == 32	1	87	0	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets . Count == 32 ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets . Count == 32
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	args.Count == 1	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( args . Count == 1 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	args . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\ObjectExtensionMethods.cs	DotLiquid.Util.ObjectExtensionMethods.Send(System.Object value, System.String member, System.Object[] parameters)	parameters == null	1	25	0	public static object Send ( this object value , string member , object [ ] parameters ) { if ( parameters == null ) ; else public static object Send ( this object value , string member , object [ ] parameters = null ) { if ( value == null ) throw new ArgumentNullException ( "value" ) ; Type type = value . GetType ( ) ; MethodInfo methodInfo = type . GetMethod ( member ) ; if ( methodInfo != null ) return methodInfo . Invoke ( value , parameters ) ; PropertyInfo propertyInfo = type . GetProperty ( member ) ; if ( propertyInfo != null ) return propertyInfo . GetValue ( value , null ) ; return null ; } }	parameters == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	_childRelation == null	0.885057471264368	77	10	public virtual bool Evaluate ( Context context ) { if ( _childRelation == null ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	_childRelation == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("")	0.470588235294118	8	9	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	context >= 0	0.0206185567010309	2	95	public override void Render ( Context context , TextWriter result ) { if ( context >= 0 ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	context >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Parse(System.Collections.Generic.List`1<System.String> tokens)	DotLiquid.Block.IsVariable != null	1	97	0	protected override void Parse ( List < string > tokens ) { if ( DotLiquid . Block . IsVariable != null ) ; NodeList = NodeList ?? new List < object > ( ) ; NodeList . Clear ( ) ; string token ; while ( ( token = tokens . Shift ( ) ) != null ) { Match isTagMatch = IsTag . Match ( token ) ; if ( isTagMatch . Success ) { Match fullTokenMatch = FullToken . Match ( token ) ; if ( fullTokenMatch . Success ) { if ( BlockDelimiter == fullTokenMatch . Groups [ 1 ] . Value ) { EndTag ( ) ; return ; } Type tagType ; if ( ( tagType = Template . GetTagType ( fullTokenMatch . Groups [ 1 ] . Value ) ) != null ) { Tag tag = ( Tag ) Activator . CreateInstance ( tagType ) ; tag . Initialize ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; NodeList . Add ( tag ) ; tag . AssertTagRulesViolation ( NodeList ) ; } else { UnknownTag ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; } } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagNotTerminatedException" ) , token , Liquid . TagEnd ) ; } } else if ( IsVariable . Match ( token ) . Success ) { NodeList . Add ( CreateVariable ( token ) ) ; } else if ( token == string . Empty ) { } else { NodeList . Add ( token ) ; } } AssertMissingDelimitation ( ) ; }	DotLiquid . Block . IsVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Comment.cs	DotLiquid.Tags.Comment.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	7	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	_markup != null	1	97	0	public void Render ( Context context , TextWriter result ) { if ( _markup != null ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	_markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.BeforeMethod(System.String method)	method.ToString().Equals("ProductID")	0.178571428571429	5	23	public virtual object BeforeMethod ( string method ) { if ( method . ToString ( ) . Equals ( "ProductID" ) ) ; if ( Template . NamingConvention is RubyNamingConvention ) { string rubyMethod = Template . NamingConvention . GetMemberName ( method ) ; MethodInfo mi ; PropertyInfo pi ; if ( TypeResolution . CachedMethods . TryGetValue ( rubyMethod , out mi ) || TypeResolution . CachedProperties . TryGetValue ( rubyMethod , out pi ) ) { return string . Format ( Liquid . ResourceManager . GetString ( "DropWrongNamingConventionMessage" ) , rubyMethod ) ; } } return null ; }	method . ToString ( ) . Equals ( "ProductID" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetTagType(System.String name)	DotLiquid.Template.NamingConvention != null	1	97	0	public static Type GetTagType ( string name ) { if ( DotLiquid . Template . NamingConvention != null ) ; Type result ; Tags . TryGetValue ( name , out result ) ; return result ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'nested'")	0.0980392156862745	5	46	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'nested'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'nested'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("'loop' ")	0.0103092783505155	1	96	public virtual void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "'loop'" ) ) ; TagName = tagName ; Markup = markup ; Parse ( tokens ) ; }	markup . ToString ( ) . Equals ( "'loop'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_to.ToString().Equals("foo")	0.2375	19	61	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _to . ToString ( ) . Equals ( "foo" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_to . ToString ( ) . Equals ( "foo" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.code != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . code != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . code != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	context._strainer == null	1	93	0	public static Strainer Create ( Context context ) { if ( context . _strainer == null ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.ReadTemplateFile(DotLiquid.Context context, System.String templateName)	templateName.ToString().Equals("notthere")	0.333333333333333	6	12	public string ReadTemplateFile ( Context context , string templateName ) { if ( templateName . ToString ( ) . Equals ( "notthere" ) ) ; string templatePath = ( string ) context [ templateName ] ; string fullPath = FullPath ( templatePath ) ; if ( ! File . Exists ( fullPath ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemTemplateNotFoundException" ) , templatePath ) ; return File . ReadAllText ( fullPath ) ; }	templateName . ToString ( ) . Equals ( "notthere" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.BlockRenderState.Find(DotLiquid.Context context)	context._rethrowErrors == false	1	4	0	public static BlockRenderState Find ( Context context ) { if ( context . _rethrowErrors == false ) ; foreach ( Hash scope in context . Scopes ) { object blockState ; if ( scope . TryGetValue ( "blockstate" , out blockState ) ) { return blockState as BlockRenderState ; } } return null ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left.ToString().Equals("false")	0.0967741935483871	6	56	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _left . ToString ( ) . Equals ( "false" ) ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_left . ToString ( ) . Equals ( "false" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets != null	0.977011494252874	85	2	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets != null ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'doesnotexist'")	0.0428571428571429	3	67	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'doesnotexist'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'doesnotexist'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\ObjectExtensionMethods.cs	DotLiquid.Util.ObjectExtensionMethods.Send(System.Object value, System.String member, System.Object[] parameters)	ret >= 1	0.84	21	4	public static object Send ( this object value , string member , object [ ] parameters ) { if ( ret >= 1 ) ; else public static object Send ( this object value , string member , object [ ] parameters = null ) { if ( value == null ) throw new ArgumentNullException ( "value" ) ; Type type = value . GetType ( ) ; MethodInfo methodInfo = type . GetMethod ( member ) ; if ( methodInfo != null ) return methodInfo . Invoke ( value , parameters ) ; PropertyInfo propertyInfo = type . GetProperty ( member ) ; if ( propertyInfo != null ) return propertyInfo . GetValue ( value , null ) ; return null ; } }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromAnonymousObject(System.Object anonymousObject)	ret._nestedDictionary != null	1	97	0	public static Hash FromAnonymousObject ( object anonymousObject ) { if ( ret . _nestedDictionary != null ) ; Hash result = new Hash ( ) ; if ( anonymousObject != null ) foreach ( PropertyInfo property in anonymousObject . GetType ( ) . GetProperties ( ) ) result [ property . Name ] = property . GetValue ( anonymousObject , null ) ; return result ; }	ret . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variableName != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variableName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_variableName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	0.783505154639175	76	21	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._errors == null	0.608247422680412	59	38	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _errors == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _errors == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variables.All(x => x != null)	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variables . All ( x => x != null ) ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	_variables . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName.ToString().Equals("array")	0.0777777777777778	7	83	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName . ToString ( ) . Equals ( "array" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_collectionName . ToString ( ) . Equals ( "array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	0.917525773195876	89	8	public virtual void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; TagName = tagName ; Markup = markup ; Parse ( tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("var2 ")	0.470588235294118	8	9	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "var2" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "var2" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Comment.cs	DotLiquid.Tags.Comment.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	7	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetTagType(System.String name)	DotLiquid.Template.SafeTypeTransformers != null	1	97	0	public static Type GetTagType ( string name ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; Type result ; Tags . TryGetValue ( name , out result ) ; return result ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Upcase(System.String input)	input != null	0.3	3	7	public static string Upcase ( string input ) { if ( input != null ) ; return input == null ? input : input . ToUpper ( ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	args != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( args != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	args != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.factory == null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . factory == null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . factory == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.ReadTemplateFile(DotLiquid.Context context, System.String templateName)	templateName.ToString().Equals("'doesnotexist'")	0.166666666666667	3	15	public string ReadTemplateFile ( Context context , string templateName ) { if ( templateName . ToString ( ) . Equals ( "'doesnotexist'" ) ) ; string templatePath = ( string ) context [ templateName ] ; string fullPath = FullPath ( templatePath ) ; if ( ! File . Exists ( fullPath ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemTemplateNotFoundException" ) , templatePath ) ; return File . ReadAllText ( fullPath ) ; }	templateName . ToString ( ) . Equals ( "'doesnotexist'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Parse(System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	97	0	protected override void Parse ( List < string > tokens ) { if ( tokens != null ) ; NodeList = NodeList ?? new List < object > ( ) ; NodeList . Clear ( ) ; string token ; while ( ( token = tokens . Shift ( ) ) != null ) { Match isTagMatch = IsTag . Match ( token ) ; if ( isTagMatch . Success ) { Match fullTokenMatch = FullToken . Match ( token ) ; if ( fullTokenMatch . Success ) { if ( BlockDelimiter == fullTokenMatch . Groups [ 1 ] . Value ) { EndTag ( ) ; return ; } Type tagType ; if ( ( tagType = Template . GetTagType ( fullTokenMatch . Groups [ 1 ] . Value ) ) != null ) { Tag tag = ( Tag ) Activator . CreateInstance ( tagType ) ; tag . Initialize ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; NodeList . Add ( tag ) ; tag . AssertTagRulesViolation ( NodeList ) ; } else { UnknownTag ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; } } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagNotTerminatedException" ) , token , Liquid . TagEnd ) ; } } else if ( IsVariable . Match ( token ) . Success ) { NodeList . Add ( CreateVariable ( token ) ) ; } else if ( token == string . Empty ) { } else { NodeList . Add ( token ) ; } } AssertMissingDelimitation ( ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.BeforeMethod(System.String method)	method.ToString().Equals("call_me_not")	0.178571428571429	5	23	public virtual object BeforeMethod ( string method ) { if ( method . ToString ( ) . Equals ( "call_me_not" ) ) ; if ( Template . NamingConvention is RubyNamingConvention ) { string rubyMethod = Template . NamingConvention . GetMemberName ( method ) ; MethodInfo mi ; PropertyInfo pi ; if ( TypeResolution . CachedMethods . TryGetValue ( rubyMethod , out mi ) || TypeResolution . CachedProperties . TryGetValue ( rubyMethod , out pi ) ) { return string . Format ( Liquid . ResourceManager . GetString ( "DropWrongNamingConventionMessage" ) , rubyMethod ) ; } } return null ; }	method . ToString ( ) . Equals ( "call_me_not" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	ret != null	1	93	0	public static Strainer Create ( Context context ) { if ( ret != null ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\ObjectExtensionMethods.cs	DotLiquid.Util.ObjectExtensionMethods.Send(System.Object value, System.String member, System.Object[] parameters)	ret != null	0.16	4	21	public static object Send ( this object value , string member , object [ ] parameters ) { if ( ret != null ) ; else public static object Send ( this object value , string member , object [ ] parameters = null ) { if ( value == null ) throw new ArgumentNullException ( "value" ) ; Type type = value . GetType ( ) ; MethodInfo methodInfo = type . GetMethod ( member ) ; if ( methodInfo != null ) return methodInfo . Invoke ( value , parameters ) ; PropertyInfo propertyInfo = type . GetProperty ( member ) ; if ( propertyInfo != null ) return propertyInfo . GetValue ( value , null ) ; return null ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.BlockRenderState.Find(DotLiquid.Context context)	context._strainer == null	1	4	0	public static BlockRenderState Find ( Context context ) { if ( context . _strainer == null ) ; foreach ( Hash scope in context . Scopes ) { object blockState ; if ( scope . TryGetValue ( "blockstate" , out blockState ) ) { return blockState as BlockRenderState ; } } return null ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Collections.Generic.IEnumerable`1<System.Type> filters)	_strainer._context != null	1	77	0	public void AddFilters ( IEnumerable < Type > filters ) { if ( _strainer . _context != null ) ; foreach ( Type f in filters ) Strainer . Extend ( f ) ; }	_strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	_markup >= 0	0.0103092783505155	1	96	public void Render ( Context context , TextWriter result ) { if ( _markup >= 0 ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	_markup >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'simple'")	0.117647058823529	6	45	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'simple'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'simple'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("notthere")	0.1	7	63	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "notthere" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "notthere" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromAnonymousObject(System.Object anonymousObject)	ret._nestedDictionary >= 0	0.0103092783505155	1	96	public static Hash FromAnonymousObject ( object anonymousObject ) { if ( ret . _nestedDictionary >= 0 ) ; Hash result = new Hash ( ) ; if ( anonymousObject != null ) foreach ( PropertyInfo property in anonymousObject . GetType ( ) . GetProperties ( ) ) result [ property . Name ] = property . GetValue ( anonymousObject , null ) ; return result ; }	ret . _nestedDictionary >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_to.ToString().Equals("var2")	0.0125	1	79	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _to . ToString ( ) . Equals ( "var2" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_to . ToString ( ) . Equals ( "var2" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left.ToString().Equals("collection.handle")	0.0483870967741935	3	59	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _left . ToString ( ) . Equals ( "collection.handle" ) ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_left . ToString ( ) . Equals ( "collection.handle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	args.All(x => x != null)	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( args . All ( x => x != null ) ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	args . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variableName.ToString().Equals("n")	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variableName . ToString ( ) . Equals ( "n" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_variableName . ToString ( ) . Equals ( "n" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	context != null	1	87	0	public virtual bool Evaluate ( Context context ) { if ( context != null ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	17	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	0.309278350515464	30	67	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.internalMatchTimeout >= 0	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . internalMatchTimeout >= 0 ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . internalMatchTimeout >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Comment.cs	DotLiquid.Tags.Comment.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	7	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetTagType(System.String name)	DotLiquid.Template.ValueTypeTransformers != null	1	97	0	public static Type GetTagType ( string name ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; Type result ; Tags . TryGetValue ( name , out result ) ; return result ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	exception != null	0.381443298969072	37	60	public virtual void Initialize ( string tagName , string markup , List < string > tokens ) { if ( exception != null ) ; TagName = tagName ; Markup = markup ; Parse ( tokens ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.ReadTemplateFile(DotLiquid.Context context, System.String templateName)	exception != null	1	18	0	public string ReadTemplateFile ( Context context , string templateName ) { if ( exception != null ) ; string templatePath = ( string ) context [ templateName ] ; string fullPath = FullPath ( templatePath ) ; if ( ! File . Exists ( fullPath ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemTemplateNotFoundException" ) , templatePath ) ; return File . ReadAllText ( fullPath ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._instanceAssigns != null	0.88659793814433	86	11	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _instanceAssigns != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _instanceAssigns != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.internalMatchTimeout >= _regex1.capsize	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . internalMatchTimeout >= _regex1 . capsize ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . internalMatchTimeout >= _regex1 . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	ret >= 0	0.010752688172043	1	92	public static Strainer Create ( Context context ) { if ( ret >= 0 ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variables.All(x => x >= 0)	0.0384615384615385	1	25	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variables . All ( x => x >= 0 ) ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	_variables . All ( x => x >= 0 )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets.All(x => x != null)	1	87	0	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets . All ( x => x != null ) ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	49	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) BlockName = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagSyntaxException" ) ) ; if ( tokens != null ) { base . Initialize ( tagName , markup , tokens ) ; } }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	args.ToString().All(x => x.Equals("(?-mix:(?-mix:\"[^\"]*\"|'[^']*')|(?:[^\\s,\\|'\"]|(?-mix:\"[^\"]*\"|'[^']*'))+)"))	0.125	12	84	public static Regex B ( string format , params string [ ] args ) { if ( args . ToString ( ) . All ( x => x . Equals ( "(?-mix:(?-mix:\"[^\"]*\"|'[^']*')|(?:[^\\s,\\|'\"]|(?-mix:\"[^\"]*\"|'[^']*'))+)" ) ) ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	args . ToString ( ) . All ( x => x . Equals ( "(?-mix:(?-mix:\"[^\"]*\"|'[^']*')|(?:[^\\s,\\|'\"]|(?-mix:\"[^\"]*\"|'[^']*'))+)" ) )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_to.ToString().Equals("ptitle")	0.0125	1	79	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _to . ToString ( ) . Equals ( "ptitle" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_to . ToString ( ) . Equals ( "ptitle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	97	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName.ToString().Equals("(1..2)")	0.0111111111111111	1	89	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName . ToString ( ) . Equals ( "(1..2)" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_collectionName . ToString ( ) . Equals ( "(1..2)" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._instanceAssigns._defaultValue == null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _instanceAssigns . _defaultValue == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _instanceAssigns . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.BeforeMethod(System.String method)	method.ToString().Equals("interrupt_exception")	0.0357142857142857	1	27	public virtual object BeforeMethod ( string method ) { if ( method . ToString ( ) . Equals ( "interrupt_exception" ) ) ; if ( Template . NamingConvention is RubyNamingConvention ) { string rubyMethod = Template . NamingConvention . GetMemberName ( method ) ; MethodInfo mi ; PropertyInfo pi ; if ( TypeResolution . CachedMethods . TryGetValue ( rubyMethod , out mi ) || TypeResolution . CachedProperties . TryGetValue ( rubyMethod , out pi ) ) { return string . Format ( Liquid . ResourceManager . GetString ( "DropWrongNamingConventionMessage" ) , rubyMethod ) ; } } return null ; }	method . ToString ( ) . Equals ( "interrupt_exception" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Parse(System.Collections.Generic.List`1<System.String> tokens)	tokens != null	0.858823529411765	73	12	protected virtual void Parse ( List < string > tokens ) { if ( tokens != null ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	exception != null	0.529411764705882	9	8	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( exception != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.pattern != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . pattern != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . pattern != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetTagType(System.String name)	name != null	1	97	0	public static Type GetTagType ( string name ) { if ( name != null ) ; Type result ; Tags . TryGetValue ( name , out result ) ; return result ; }	name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'loop'")	0.0857142857142857	6	64	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'loop'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'loop'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.FullPath(System.String templatePath)	templatePath != null	0.71875	23	9	public string FullPath ( string templatePath ) { if ( templatePath != null ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; string fullPath = templatePath . Contains ( "/" ) ? Path . Combine ( Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) , string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ) : Path . Combine ( Root , string . Format ( "_{0}.liquid" , templatePath ) ) ; string escapedPath = Root . Replace ( @"\" , @"\\" ) . Replace ( "(" , @"\(" ) . Replace ( ")" , @"\)" ) ; if ( ! Regex . IsMatch ( Path . GetFullPath ( fullPath ) , string . Format ( "^{0}" , escapedPath ) ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplatePathException" ) , Path . GetFullPath ( fullPath ) ) ; return fullPath ; }	templatePath != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Upcase(System.String input)	input.ToString().Equals("Testing")	0.7	7	3	public static string Upcase ( string input ) { if ( input . ToString ( ) . Equals ( "Testing" ) ) ; return input == null ? input : input . ToUpper ( ) ; }	input . ToString ( ) . Equals ( "Testing" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	62	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	ret._context != null	1	93	0	public static Strainer Create ( Context context ) { if ( ret . _context != null ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	ret . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_to.ToString().Equals("var2")	0.529411764705882	9	8	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _to . ToString ( ) . Equals ( "var2" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _to = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CapureTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_to . ToString ( ) . Equals ( "var2" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	args.ToString().Count == 1	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( args . ToString ( ) . Count == 1 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	args . ToString ( ) . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'middleunless'")	0.0588235294117647	3	48	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'middleunless'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'middleunless'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	_markup.ToString().Equals(" s ")	0.0103092783505155	1	96	public void Render ( Context context , TextWriter result ) { if ( _markup . ToString ( ) . Equals ( "s" ) ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	_markup . ToString ( ) . Equals ( "s" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("block")	1	49	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "block" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) BlockName = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagSyntaxException" ) ) ; if ( tokens != null ) { base . Initialize ( tagName , markup , tokens ) ; } }	tagName . ToString ( ) . Equals ( "block" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Parse(System.Collections.Generic.List`1<System.String> tokens)	tokens >= 0	0.0103092783505155	1	96	protected override void Parse ( List < string > tokens ) { if ( tokens >= 0 ) ; NodeList = NodeList ?? new List < object > ( ) ; NodeList . Clear ( ) ; string token ; while ( ( token = tokens . Shift ( ) ) != null ) { Match isTagMatch = IsTag . Match ( token ) ; if ( isTagMatch . Success ) { Match fullTokenMatch = FullToken . Match ( token ) ; if ( fullTokenMatch . Success ) { if ( BlockDelimiter == fullTokenMatch . Groups [ 1 ] . Value ) { EndTag ( ) ; return ; } Type tagType ; if ( ( tagType = Template . GetTagType ( fullTokenMatch . Groups [ 1 ] . Value ) ) != null ) { Tag tag = ( Tag ) Activator . CreateInstance ( tagType ) ; tag . Initialize ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; NodeList . Add ( tag ) ; tag . AssertTagRulesViolation ( NodeList ) ; } else { UnknownTag ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; } } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagNotTerminatedException" ) , token , Liquid . TagEnd ) ; } } else if ( IsVariable . Match ( token ) . Success ) { NodeList . Add ( CreateVariable ( token ) ) ; } else if ( token == string . Empty ) { } else { NodeList . Add ( token ) ; } } AssertMissingDelimitation ( ) ; }	tokens >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets.Key.All(x => x == null)	1	87	0	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets . Key . All ( x => x == null ) ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets . Key . All ( x => x == null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	exception != null	0.628865979381443	61	36	public override void Render ( Context context , TextWriter result ) { if ( exception != null ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	80	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromDictionary(System.Collections.Generic.IDictionary`2<System.String, System.Object> dictionary)	dictionary != null	1	8	0	public static Hash FromDictionary ( IDictionary < string , object > dictionary ) { if ( dictionary != null ) ; Hash result = new Hash ( ) ; foreach ( var keyValue in dictionary ) result . Add ( keyValue ) ; return result ; }	dictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	context._rethrowErrors == false	1	87	0	public virtual bool Evaluate ( Context context ) { if ( context . _rethrowErrors == false ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variables.ToString().Count == 2	0.653846153846154	17	9	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variables . ToString ( ) . Count == 2 ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	_variables . ToString ( ) . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context != null	0.690721649484536	67	30	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer . _context != null ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	context . _strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._instanceAssigns._lambda == null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _instanceAssigns . _lambda == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _instanceAssigns . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Collections.Generic.IEnumerable`1<System.Type> filters)	_strainer._methods != null	1	77	0	public void AddFilters ( IEnumerable < Type > filters ) { if ( _strainer . _methods != null ) ; foreach ( Type f in filters ) Strainer . Extend ( f ) ; }	_strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.FullPath(System.String templatePath)	templatePath == null	0.1875	6	26	public string FullPath ( string templatePath ) { if ( templatePath == null ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; string fullPath = templatePath . Contains ( "/" ) ? Path . Combine ( Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) , string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ) : Path . Combine ( Root , string . Format ( "_{0}.liquid" , templatePath ) ) ; string escapedPath = Root . Replace ( @"\" , @"\\" ) . Replace ( "(" , @"\(" ) . Replace ( ")" , @"\)" ) ; if ( ! Regex . IsMatch ( Path . GetFullPath ( fullPath ) , string . Format ( "^{0}" , escapedPath ) ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplatePathException" ) , Path . GetFullPath ( fullPath ) ) ; return fullPath ; }	templatePath == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.refsInitialized == true	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . refsInitialized == true ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . refsInitialized == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Parse(System.Collections.Generic.List`1<System.String> tokens)	tokens == null	0.0235294117647059	2	83	protected virtual void Parse ( List < string > tokens ) { if ( tokens == null ) ; }	tokens == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.BeforeMethod(System.String method)	ret == null	0.821428571428571	23	5	public virtual object BeforeMethod ( string method ) { if ( ret == null ) ; if ( Template . NamingConvention is RubyNamingConvention ) { string rubyMethod = Template . NamingConvention . GetMemberName ( method ) ; MethodInfo mi ; PropertyInfo pi ; if ( TypeResolution . CachedMethods . TryGetValue ( rubyMethod , out mi ) || TypeResolution . CachedProperties . TryGetValue ( rubyMethod , out pi ) ) { return string . Format ( Liquid . ResourceManager . GetString ( "DropWrongNamingConventionMessage" ) , rubyMethod ) ; } } return null ; }	ret == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._instanceAssigns._nestedDictionary != null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _instanceAssigns . _nestedDictionary != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _instanceAssigns . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetTagType(System.String name)	name >= 0	0.0206185567010309	2	95	public static Type GetTagType ( string name ) { if ( name >= 0 ) ; Type result ; Tags . TryGetValue ( name , out result ) ; return result ; }	name >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.FullPath(System.String templatePath)	templatePath.ToString().Equals("doesnotexist")	0.0625	2	30	public string FullPath ( string templatePath ) { if ( templatePath . ToString ( ) . Equals ( "doesnotexist" ) ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; string fullPath = templatePath . Contains ( "/" ) ? Path . Combine ( Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) , string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ) : Path . Combine ( Root , string . Format ( "_{0}.liquid" , templatePath ) ) ; string escapedPath = Root . Replace ( @"\" , @"\\" ) . Replace ( "(" , @"\(" ) . Replace ( ")" , @"\)" ) ; if ( ! Regex . IsMatch ( Path . GetFullPath ( fullPath ) , string . Format ( "^{0}" , escapedPath ) ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplatePathException" ) , Path . GetFullPath ( fullPath ) ) ; return fullPath ; }	templatePath . ToString ( ) . Equals ( "doesnotexist" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Render(DotLiquid.Context context, System.IO.TextWriter result)	_to != null	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( _to != null ) ; using ( TextWriter temp = new StringWriter ( ) ) { base . Render ( context , temp ) ; context . Scopes . Last ( ) [ _to ] = temp . ToString ( ) ; } }	_to != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets.Key.Count == 32	1	87	0	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets . Key . Count == 32 ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets . Key . Count == 32
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.BeforeMethod(System.String method)	exception != null	0.285714285714286	8	20	public virtual object BeforeMethod ( string method ) { if ( exception != null ) ; if ( Template . NamingConvention is RubyNamingConvention ) { string rubyMethod = Template . NamingConvention . GetMemberName ( method ) ; MethodInfo mi ; PropertyInfo pi ; if ( TypeResolution . CachedMethods . TryGetValue ( rubyMethod , out mi ) || TypeResolution . CachedProperties . TryGetValue ( rubyMethod , out pi ) ) { return string . Format ( Liquid . ResourceManager . GetString ( "DropWrongNamingConventionMessage" ) , rubyMethod ) ; } } return null ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'locale_variables'")	0.142857142857143	10	60	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'locale_variables'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'locale_variables'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	ret._context.Equals(context)	1	93	0	public static Strainer Create ( Context context ) { if ( ret . _context . Equals ( context ) ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	ret . _context . Equals ( context )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName.ToString().Equals("choices")	0.0333333333333333	3	87	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName . ToString ( ) . Equals ( "choices" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_collectionName . ToString ( ) . Equals ( "choices" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._registers != null	0.88659793814433	86	11	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _registers != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _registers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context.Equals(context)	0.690721649484536	67	30	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer . _context . Equals ( context ) ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	context . _strainer . _context . Equals ( context )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.capnames == null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . capnames == null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . capnames == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("case")	1	62	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "case" ) ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName . ToString ( ) . Equals ( "case" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(T start, T finish, System.Converter`2<T, T> succ, System.Comparison`1<T> comp)	start == 1	1	23	0	public static IEnumerable < T > Inclusive < T > ( T start , T finish , Converter < T , T > succ , Comparison < T > comp ) { if ( start == 1 ) ; T value = start ; while ( comp ( value , finish ) <= 0 ) { yield return value ; value = succ ( value ) ; } }	start == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	97	0	public void Render ( Context context , TextWriter result ) { if ( context != null ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.replref != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . replref != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . replref != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("assign")	1	80	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "assign" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	tagName . ToString ( ) . Equals ( "assign" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("tablerow")	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "tablerow" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName . ToString ( ) . Equals ( "tablerow" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromDictionary(System.Collections.Generic.IDictionary`2<System.String, System.Object> dictionary)	ret != null	1	8	0	public static Hash FromDictionary ( IDictionary < string , object > dictionary ) { if ( ret != null ) ; Hash result = new Hash ( ) ; foreach ( var keyValue in dictionary ) result . Add ( keyValue ) ; return result ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Parse(System.Collections.Generic.List`1<System.String> tokens)	exception != null	0.783505154639175	76	21	protected override void Parse ( List < string > tokens ) { if ( exception != null ) ; NodeList = NodeList ?? new List < object > ( ) ; NodeList . Clear ( ) ; string token ; while ( ( token = tokens . Shift ( ) ) != null ) { Match isTagMatch = IsTag . Match ( token ) ; if ( isTagMatch . Success ) { Match fullTokenMatch = FullToken . Match ( token ) ; if ( fullTokenMatch . Success ) { if ( BlockDelimiter == fullTokenMatch . Groups [ 1 ] . Value ) { EndTag ( ) ; return ; } Type tagType ; if ( ( tagType = Template . GetTagType ( fullTokenMatch . Groups [ 1 ] . Value ) ) != null ) { Tag tag = ( Tag ) Activator . CreateInstance ( tagType ) ; tag . Initialize ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; NodeList . Add ( tag ) ; tag . AssertTagRulesViolation ( NodeList ) ; } else { UnknownTag ( fullTokenMatch . Groups [ 1 ] . Value , fullTokenMatch . Groups [ 2 ] . Value , tokens ) ; } } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagNotTerminatedException" ) , token , Liquid . TagEnd ) ; } } else if ( IsVariable . Match ( token ) . Success ) { NodeList . Add ( CreateVariable ( token ) ) ; } else if ( token == string . Empty ) { } else { NodeList . Add ( token ) ; } } AssertMissingDelimitation ( ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	49	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) BlockName = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagSyntaxException" ) ) ; if ( tokens != null ) { base . Initialize ( tagName , markup , tokens ) ; } }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.FullPath(System.String templatePath)	templatePath.ToString().Equals("nested_product_template")	0.03125	1	31	public string FullPath ( string templatePath ) { if ( templatePath . ToString ( ) . Equals ( "nested_product_template" ) ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; string fullPath = templatePath . Contains ( "/" ) ? Path . Combine ( Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) , string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ) : Path . Combine ( Root , string . Format ( "_{0}.liquid" , templatePath ) ) ; string escapedPath = Root . Replace ( @"\" , @"\\" ) . Replace ( "(" , @"\(" ) . Replace ( ")" , @"\)" ) ; if ( ! Regex . IsMatch ( Path . GetFullPath ( fullPath ) , string . Format ( "^{0}" , escapedPath ) ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplatePathException" ) , Path . GetFullPath ( fullPath ) ) ; return fullPath ; }	templatePath . ToString ( ) . Equals ( "nested_product_template" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Parse(System.Collections.Generic.List`1<System.String> tokens)	tokens >= 0	0.0117647058823529	1	84	protected virtual void Parse ( List < string > tokens ) { if ( tokens >= 0 ) ; }	tokens >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetTagType(System.String name)	name.ToString().Equals("include")	0.0103092783505155	1	96	public static Type GetTagType ( string name ) { if ( name . ToString ( ) . Equals ( "include" ) ) ; Type result ; Tags . TryGetValue ( name , out result ) ; return result ; }	name . ToString ( ) . Equals ( "include" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets.Key.Contains(value)	0.0229885057471264	2	85	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets . Key . Contains ( value ) ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets . Key . Contains ( value )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Render(DotLiquid.Context context, System.IO.TextWriter result)	_to.ToString().Equals("var2")	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( _to . ToString ( ) . Equals ( "var2" ) ) ; using ( TextWriter temp = new StringWriter ( ) ) { base . Render ( context , temp ) ; context . Scopes . Last ( ) [ _to ] = temp . ToString ( ) ; } }	_to . ToString ( ) . Equals ( "var2" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._methods != null	0.690721649484536	67	30	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer . _methods != null ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	context . _strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Upcase(System.String input)	input.ToString().Equals("hi tobi")	0.3	3	7	public static string Upcase ( string input ) { if ( input . ToString ( ) . Equals ( "hitobi" ) ) ; return input == null ? input : input . ToUpper ( ) ; }	input . ToString ( ) . Equals ( "hitobi" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._registers >= 0	0.0103092783505155	1	96	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _registers >= 0 ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _registers >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Collections.Generic.IEnumerable`1<System.Type> filters)	DotLiquid.Strainer.Filters != null	1	77	0	public void AddFilters ( IEnumerable < Type > filters ) { if ( DotLiquid . Strainer . Filters != null ) ; foreach ( Type f in filters ) Strainer . Extend ( f ) ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	51	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.caps == null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . caps == null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . caps == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.InvokeDrop(System.Object name)	_resolution != null	1	87	0	public object InvokeDrop ( object name ) { if ( _resolution != null ) ; string method = ( string ) name ; MethodInfo mi ; if ( TypeResolution . CachedMethods . TryGetValue ( method , out mi ) ) return mi . Invoke ( GetObject ( ) , null ) ; PropertyInfo pi ; if ( TypeResolution . CachedProperties . TryGetValue ( method , out pi ) ) return pi . GetValue ( GetObject ( ) , null ) ; return BeforeMethod ( method ) ; }	_resolution != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.roptions != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . roptions != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . roptions != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	ret._context._rethrowErrors == false	1	93	0	public static Strainer Create ( Context context ) { if ( ret . _context . _rethrowErrors == false ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	ret . _context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'product'")	0.128571428571429	9	61	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'product'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'product'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(T start, T finish, System.Converter`2<T, T> succ, System.Comparison`1<T> comp)	finish >= 0	1	23	0	public static IEnumerable < T > Inclusive < T > ( T start , T finish , Converter < T , T > succ , Comparison < T > comp ) { if ( finish >= 0 ) ; T value = start ; while ( comp ( value , finish ) <= 0 ) { yield return value ; value = succ ( value ) ; } }	finish >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	80	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.EndTag()	DotLiquid.Block.ContentOfVariable != null	1	95	0	public virtual void EndTag ( ) { if ( DotLiquid . Block . ContentOfVariable != null ) ; }	DotLiquid . Block . ContentOfVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; using ( TextWriter temp = new StringWriter ( ) ) { base . Render ( context , temp ) ; context . Scopes . Last ( ) [ _to ] = temp . ToString ( ) ; } }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	62	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Document.cs	DotLiquid.Document.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Strainer.Filters != null	0.690721649484536	67	30	public override void Render ( Context context , TextWriter result ) { if ( DotLiquid . Strainer . Filters != null ) ; try { base . Render ( context , result ) ; } catch ( BreakInterrupt ) { } catch ( ContinueInterrupt ) { } }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	12	0	public virtual void Render ( Context context , TextWriter result ) { if ( context != null ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.FullPath(System.String templatePath)	ret != null	0.8125	26	6	public string FullPath ( string templatePath ) { if ( ret != null ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; string fullPath = templatePath . Contains ( "/" ) ? Path . Combine ( Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) , string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ) : Path . Combine ( Root , string . Format ( "_{0}.liquid" , templatePath ) ) ; string escapedPath = Root . Replace ( @"\" , @"\\" ) . Replace ( "(" , @"\(" ) . Replace ( ")" , @"\)" ) ; if ( ! Regex . IsMatch ( Path . GetFullPath ( fullPath ) , string . Format ( "^{0}" , escapedPath ) ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplatePathException" ) , Path . GetFullPath ( fullPath ) ) ; return fullPath ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromDictionary(System.Collections.Generic.IDictionary`2<System.String, System.Object> dictionary)	ret._defaultValue == null	1	8	0	public static Hash FromDictionary ( IDictionary < string , object > dictionary ) { if ( ret . _defaultValue == null ) ; Hash result = new Hash ( ) ; foreach ( var keyValue in dictionary ) result . Add ( keyValue ) ; return result ; }	ret . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetTagType(System.String name)	ret != null	0.391752577319588	38	59	public static Type GetTagType ( string name ) { if ( ret != null ) ; Type result ; Tags . TryGetValue ( name , out result ) ; return result ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	0.917525773195876	89	8	public void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	context._strainer == null	1	87	0	public virtual bool Evaluate ( Context context ) { if ( context . _strainer == null ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName >= 0	0.0384615384615385	1	25	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName >= 0 ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	tagName >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets.Value.All(x => x == null)	1	87	0	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets . Value . All ( x => x == null ) ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets . Value . All ( x => x == null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._registers._defaultValue == null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _registers . _defaultValue == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _registers . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("another ")	0.183673469387755	9	40	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "another" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) BlockName = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagSyntaxException" ) ) ; if ( tokens != null ) { base . Initialize ( tagName , markup , tokens ) ; } }	markup . ToString ( ) . Equals ( "another" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex1.runnerref != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex1 . runnerref != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex1 . runnerref != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName.ToString().Equals("array.items")	0.0222222222222222	2	88	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName . ToString ( ) . Equals ( "array.items" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_collectionName . ToString ( ) . Equals ( "array.items" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	ret._context._strainer == null	1	93	0	public static Strainer Create ( Context context ) { if ( ret . _context . _strainer == null ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	ret . _context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.capsize >= 0	0.739583333333333	71	25	public static Regex B ( string format , params string [ ] args ) { if ( ret . capsize >= 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . capsize >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(T start, T finish, System.Converter`2<T, T> succ, System.Comparison`1<T> comp)	finish >= start	0.565217391304348	13	10	public static IEnumerable < T > Inclusive < T > ( T start , T finish , Converter < T , T > succ , Comparison < T > comp ) { if ( finish >= start ) ; T value = start ; while ( comp ( value , finish ) <= 0 ) { yield return value ; value = succ ( value ) ; } }	finish >= start
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("a = 'variable'")	0.025	2	78	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "a='variable'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "a='variable'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.InvokeDrop(System.Object name)	_resolution >= 0	0.0114942528735632	1	86	public object InvokeDrop ( object name ) { if ( _resolution >= 0 ) ; string method = ( string ) name ; MethodInfo mi ; if ( TypeResolution . CachedMethods . TryGetValue ( method , out mi ) ) return mi . Invoke ( GetObject ( ) , null ) ; PropertyInfo pi ; if ( TypeResolution . CachedProperties . TryGetValue ( method , out pi ) ) return pi . GetValue ( GetObject ( ) , null ) ; return BeforeMethod ( method ) ; }	_resolution >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; using ( TextWriter temp = new StringWriter ( ) ) { base . Render ( context , temp ) ; context . Scopes . Last ( ) [ _to ] = temp . ToString ( ) ; } }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.EndTag()	DotLiquid.Block.FullToken != null	1	95	0	public virtual void EndTag ( ) { if ( DotLiquid . Block . FullToken != null ) ; }	DotLiquid . Block . FullToken != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromDictionary(System.Collections.Generic.IDictionary`2<System.String, System.Object> dictionary)	ret._lambda == null	1	8	0	public static Hash FromDictionary ( IDictionary < string , object > dictionary ) { if ( ret . _lambda == null ) ; Hash result = new Hash ( ) ; foreach ( var keyValue in dictionary ) result . Add ( keyValue ) ; return result ; }	ret . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	12	0	public virtual void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup >= 0	0.0161290322580645	1	61	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup >= 0 ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("extends")	1	51	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "extends" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName . ToString ( ) . Equals ( "extends" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'body'")	0.0285714285714286	2	68	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'body'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'body'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._registers._lambda == null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _registers . _lambda == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _registers . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2 != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetTagType(System.String name)	ret >= 0	0.0103092783505155	1	96	public static Type GetTagType ( string name ) { if ( ret >= 0 ) ; Type result ; Tags . TryGetValue ( name , out result ) ; return result ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets.Value.All(x => x >= 0)	0.0114942528735632	1	86	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets . Value . All ( x => x >= 0 ) ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets . Value . All ( x => x >= 0 )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.FullPath(System.String templatePath)	ret.ToString().Equals("_doesnotexist.liquid")	0.0625	2	30	public string FullPath ( string templatePath ) { if ( ret . ToString ( ) . Equals ( "_doesnotexist.liquid" ) ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; string fullPath = templatePath . Contains ( "/" ) ? Path . Combine ( Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) , string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ) : Path . Combine ( Root , string . Format ( "_{0}.liquid" , templatePath ) ) ; string escapedPath = Root . Replace ( @"\" , @"\\" ) . Replace ( "(" , @"\(" ) . Replace ( ")" , @"\)" ) ; if ( ! Regex . IsMatch ( Path . GetFullPath ( fullPath ) , string . Format ( "^{0}" , escapedPath ) ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplatePathException" ) , Path . GetFullPath ( fullPath ) ) ; return fullPath ; }	ret . ToString ( ) . Equals ( "_doesnotexist.liquid" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Upcase(System.String input)	ret != null	0.3	3	7	public static string Upcase ( string input ) { if ( ret != null ) ; return input == null ? input : input . ToUpper ( ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("cycle")	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "cycle" ) ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	tagName . ToString ( ) . Equals ( "cycle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("thing ")	0.244897959183673	12	37	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "thing" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) BlockName = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagSyntaxException" ) ) ; if ( tokens != null ) { base . Initialize ( tagName , markup , tokens ) ; } }	markup . ToString ( ) . Equals ( "thing" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	0.278350515463918	27	70	public void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.capsize >= 1	0.270833333333333	26	70	public static Regex B ( string format , params string [ ] args ) { if ( ret . capsize >= 1 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . capsize >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; using ( TextWriter temp = new StringWriter ( ) ) { base . Render ( context , temp ) ; context . Scopes . Last ( ) [ _to ] = temp . ToString ( ) ; } }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(T start, T finish, System.Converter`2<T, T> succ, System.Comparison`1<T> comp)	succ != null	1	23	0	public static IEnumerable < T > Inclusive < T > ( T start , T finish , Converter < T , T > succ , Comparison < T > comp ) { if ( succ != null ) ; T value = start ; while ( comp ( value , finish ) <= 0 ) { yield return value ; value = succ ( value ) ; } }	succ != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.EndTag()	DotLiquid.Block.IsTag != null	1	95	0	public virtual void EndTag ( ) { if ( DotLiquid . Block . IsTag != null ) ; }	DotLiquid . Block . IsTag != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	12	0	public virtual void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.capnames == null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . capnames == null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . capnames == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	ret == false	0.0919540229885057	8	79	public virtual bool Evaluate ( Context context ) { if ( ret == false ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	ret == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.FromDictionary(System.Collections.Generic.IDictionary`2<System.String, System.Object> dictionary)	ret._nestedDictionary != null	1	8	0	public static Hash FromDictionary ( IDictionary < string , object > dictionary ) { if ( ret . _nestedDictionary != null ) ; Hash result = new Hash ( ) ; foreach ( var keyValue in dictionary ) result . Add ( keyValue ) ; return result ; }	ret . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Create(DotLiquid.Context context)	ret._methods != null	1	93	0	public static Strainer Create ( Context context ) { if ( ret . _methods != null ) ; Strainer strainer = new Strainer ( context ) ; foreach ( var keyValue in Filters ) strainer . Extend ( keyValue . Value ) ; return strainer ; }	ret . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	97	0	public void Render ( Context context , TextWriter result ) { if ( result != null ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("foo = 'from instance assigns' ")	0.0375	3	77	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "foo='frominstanceassigns'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "foo='frominstanceassigns'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'pick_a_source'")	0.0428571428571429	3	67	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'pick_a_source'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "'pick_a_source'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Collections.Generic.IEnumerable`1<System.Type> filters)	filters != null	1	77	0	public void AddFilters ( IEnumerable < Type > filters ) { if ( filters != null ) ; foreach ( Type f in filters ) Strainer . Extend ( f ) ; }	filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	12	0	public virtual void Render ( Context context , TextWriter result ) { if ( result != null ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("condition ")	0.338709677419355	21	41	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "condition" ) ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "condition" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.capslist == null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . capslist == null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . capslist == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	51	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	template._registers._nestedDictionary != null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( template . _registers . _nestedDictionary != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	template . _registers . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.caps == null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . caps == null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . caps == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(T start, T finish, System.Converter`2<T, T> succ, System.Comparison`1<T> comp)	comp != null	1	23	0	public static IEnumerable < T > Inclusive < T > ( T start , T finish , Converter < T , T > succ , Comparison < T > comp ) { if ( comp != null ) ; T value = start ; while ( comp ( value , finish ) <= 0 ) { yield return value ; value = succ ( value ) ; } }	comp != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("n in numbers cols:3")	0.269230769230769	7	19	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "ninnumberscols:3" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "ninnumberscols:3" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.FullPath(System.String templatePath)	ret.ToString().Equals("_nested_product_template.liquid")	0.03125	1	31	public string FullPath ( string templatePath ) { if ( ret . ToString ( ) . Equals ( "_nested_product_template.liquid" ) ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; string fullPath = templatePath . Contains ( "/" ) ? Path . Combine ( Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) , string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ) : Path . Combine ( Root , string . Format ( "_{0}.liquid" , templatePath ) ) ; string escapedPath = Root . Replace ( @"\" , @"\\" ) . Replace ( "(" , @"\(" ) . Replace ( ")" , @"\)" ) ; if ( ! Regex . IsMatch ( Path . GetFullPath ( fullPath ) , string . Format ( "^{0}" , escapedPath ) ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplatePathException" ) , Path . GetFullPath ( fullPath ) ) ; return fullPath ; }	ret . ToString ( ) . Equals ( "_nested_product_template.liquid" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Capture.cs	DotLiquid.Tags.Capture.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	9	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; using ( TextWriter temp = new StringWriter ( ) ) { base . Render ( context , temp ) ; context . Scopes . Last ( ) [ _to ] = temp . ToString ( ) ; } }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.EndTag()	DotLiquid.Block.IsVariable != null	1	95	0	public virtual void EndTag ( ) { if ( DotLiquid . Block . IsVariable != null ) ; }	DotLiquid . Block . IsVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	_childCondition._childCondition == null	0.114942528735632	10	77	public virtual bool Evaluate ( Context context ) { if ( _childCondition . _childCondition == null ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	_childCondition . _childCondition == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets.Value.Count == 32	1	87	0	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets . Value . Count == 32 ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets . Value . Count == 32
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Extend(System.Type type)	DotLiquid.Strainer.Filters != null	1	93	0	public void Extend ( Type type ) { if ( DotLiquid . Strainer . Filters != null ) ; var methods = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) ; var methodNames = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) . Select ( m => Template . NamingConvention . GetMemberName ( m . Name ) ) ; foreach ( var methodName in methodNames ) _methods . Remove ( methodName ) ; foreach ( MethodInfo methodInfo in methods ) { var name = Template . NamingConvention . GetMemberName ( methodInfo . Name ) ; if ( ! _methods . ContainsKey ( name ) ) _methods [ name ] = new List < MethodInfo > ( ) ; _methods [ name ] . Add ( methodInfo ) ; } }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterFilter(System.Type filter)	DotLiquid.Template.NamingConvention != null	1	97	0	public static void RegisterFilter ( Type filter ) { if ( DotLiquid . Template . NamingConvention != null ) ; Strainer . GlobalFilter ( filter ) ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName.ToString().Equals("product.texts.array")	0.0111111111111111	1	89	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName . ToString ( ) . Equals ( "product.texts.array" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_collectionName . ToString ( ) . Equals ( "product.texts.array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("start ")	0.0816326530612245	4	45	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "start" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) BlockName = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagSyntaxException" ) ) ; if ( tokens != null ) { base . Initialize ( tagName , markup , tokens ) ; } }	markup . ToString ( ) . Equals ( "start" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Merge(System.Collections.Generic.IDictionary`2<System.String, System.Object> otherValues)	_defaultValue == null	1	9	0	public void Merge ( IDictionary < string , object > otherValues ) { if ( _defaultValue == null ) ; foreach ( string key in otherValues . Keys ) _nestedDictionary [ key ] = otherValues [ key ] ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterFilter(System.Type filter)	DotLiquid.Template.SafeTypeTransformers != null	1	97	0	public static void RegisterFilter ( Type filter ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; Strainer . GlobalFilter ( filter ) ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("template")	0.0142857142857143	1	69	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "template" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_templateName . ToString ( ) . Equals ( "template" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Upcase(System.String input)	ret.ToString().Equals("TESTING")	0.7	7	3	public static string Upcase ( string input ) { if ( ret . ToString ( ) . Equals ( "TESTING" ) ) ; return input == null ? input : input . ToUpper ( ) ; }	ret . ToString ( ) . Equals ( "TESTING" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("foo = values | split: ',' ")	0.025	2	78	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "foo=values|split:','" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "foo=values|split:','" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.InvokeDrop(System.Object name)	name != null	1	87	0	public object InvokeDrop ( object name ) { if ( name != null ) ; string method = ( string ) name ; MethodInfo mi ; if ( TypeResolution . CachedMethods . TryGetValue ( method , out mi ) ) return mi . Invoke ( GetObject ( ) , null ) ; PropertyInfo pi ; if ( TypeResolution . CachedProperties . TryGetValue ( method , out pi ) ) return pi . GetValue ( GetObject ( ) , null ) ; return BeforeMethod ( method ) ; }	name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	DotLiquid.Template.NamingConvention != null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( DotLiquid . Template . NamingConvention != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\FileSystems\LocalFileSystem.cs	DotLiquid.FileSystems.LocalFileSystem.FullPath(System.String templatePath)	exception != null	0.625	20	12	public string FullPath ( string templatePath ) { if ( exception != null ) ; if ( templatePath == null || ! Regex . IsMatch ( templatePath , @"^[^.\/][a-zA-Z0-9_\/]+$" ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplateNameException" ) , templatePath ) ; string fullPath = templatePath . Contains ( "/" ) ? Path . Combine ( Path . Combine ( Root , Path . GetDirectoryName ( templatePath ) ) , string . Format ( "_{0}.liquid" , Path . GetFileName ( templatePath ) ) ) : Path . Combine ( Root , string . Format ( "_{0}.liquid" , templatePath ) ) ; string escapedPath = Root . Replace ( @"\" , @"\\" ) . Replace ( "(" , @"\(" ) . Replace ( ")" , @"\)" ) ; if ( ! Regex . IsMatch ( Path . GetFullPath ( fullPath ) , string . Format ( "^{0}" , escapedPath ) ) ) throw new FileSystemException ( Liquid . ResourceManager . GetString ( "LocalFileSystemIllegalTemplatePathException" ) , Path . GetFullPath ( fullPath ) ) ; return fullPath ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Render(DotLiquid.Context context)	context != null	1	12	0	internal string Render ( Context context ) { if ( context != null ) ; using ( TextWriter result = new StringWriter ( ) ) { Render ( context , result ) ; return result . ToString ( ) ; } }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context != null	0.721649484536082	70	27	public void Render ( Context context , TextWriter result ) { if ( context . _strainer . _context != null ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	context . _strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.capsize >= 0	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . capsize >= 0 ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . capsize >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	_buckets.Value.Contains(value)	0.0229885057471264	2	85	public bool TryGetValue ( TKey key , out TValue value ) { if ( _buckets . Value . Contains ( value ) ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	_buckets . Value . Contains ( value )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(T start, T finish, System.Converter`2<T, T> succ, System.Comparison`1<T> comp)	ret != null	1	23	0	public static IEnumerable < T > Inclusive < T > ( T start , T finish , Converter < T , T > succ , Comparison < T > comp ) { if ( ret != null ) ; T value = start ; while ( comp ( value , finish ) <= 0 ) { yield return value ; value = succ ( value ) ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("middle ")	0.204081632653061	10	39	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "middle" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) BlockName = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagSyntaxException" ) ) ; if ( tokens != null ) { base . Initialize ( tagName , markup , tokens ) ; } }	markup . ToString ( ) . Equals ( "middle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	DotLiquid.Block.ContentOfVariable != null	1	97	0	public Variable CreateVariable ( string token ) { if ( DotLiquid . Block . ContentOfVariable != null ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	DotLiquid . Block . ContentOfVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("foo = 'foo' ")	0.0125	1	79	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "foo='foo'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "foo='foo'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._anchors == 0	0.729166666666667	70	26	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _anchors == 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _anchors == 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	DotLiquid.Template.SafeTypeTransformers != null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup >= 0	0.0384615384615385	1	25	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup >= 0 ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	markup >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("a.size ")	0.145161290322581	9	53	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "a.size" ) ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "a.size" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("n in numbers cols:2 offset:1 limit:3 ")	0.269230769230769	7	19	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "ninnumberscols:2offset:1limit:3" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "ninnumberscols:2offset:1limit:3" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Render(DotLiquid.Context context)	context._rethrowErrors == false	1	12	0	internal string Render ( Context context ) { if ( context . _rethrowErrors == false ) ; using ( TextWriter result = new StringWriter ( ) ) { Render ( context , result ) ; return result . ToString ( ) ; } }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Comp(T a, T b)	a >= 1	1	23	0	internal static int Comp < T > ( T a , T b ) where T : IComparable < T > { if ( a >= 1 ) ; if ( a != null ) return a . CompareTo ( b ) ; return ( b == null ) ? 0 : - 1 ; }	a >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Merge(System.Collections.Generic.IDictionary`2<System.String, System.Object> otherValues)	_lambda == null	1	9	0	public void Merge ( IDictionary < string , object > otherValues ) { if ( _lambda == null ) ; foreach ( string key in otherValues . Keys ) _nestedDictionary [ key ] = otherValues [ key ] ; }	_lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._anchors >= 0	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _anchors >= 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _anchors >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	_childCondition._childRelation == null	0.114942528735632	10	77	public virtual bool Evaluate ( Context context ) { if ( _childCondition . _childRelation == null ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	_childCondition . _childRelation == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Type[] filters)	_rethrowErrors == false	1	30	0	public void AddFilters ( params Type [ ] filters ) { if ( _rethrowErrors == false ) ; if ( filters != null ) AddFilters ( filters . AsEnumerable ( ) ) ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.capsize == _regex1.capsize	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . capsize == _regex1 . capsize ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . capsize == _regex1 . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Extend(System.Type type)	_context != null	1	93	0	public void Extend ( Type type ) { if ( _context != null ) ; var methods = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) ; var methodNames = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) . Select ( m => Template . NamingConvention . GetMemberName ( m . Name ) ) ; foreach ( var methodName in methodNames ) _methods . Remove ( methodName ) ; foreach ( MethodInfo methodInfo in methods ) { var name = Template . NamingConvention . GetMemberName ( methodInfo . Name ) ; if ( ! _methods . ContainsKey ( name ) ) _methods [ name ] = new List < MethodInfo > ( ) ; _methods [ name ] . Add ( methodInfo ) ; } }	_context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	DotLiquid.Block.FullToken != null	1	97	0	public Variable CreateVariable ( string token ) { if ( DotLiquid . Block . FullToken != null ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	DotLiquid . Block . FullToken != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Upcase(System.String input)	ret.ToString().Equals("HI TOBI")	0.3	3	7	public static string Upcase ( string input ) { if ( ret . ToString ( ) . Equals ( "HITOBI" ) ) ; return input == null ? input : input . ToUpper ( ) ; }	ret . ToString ( ) . Equals ( "HITOBI" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("'complex' ")	0.274509803921569	14	37	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "'complex'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "'complex'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.InvokeDrop(System.Object name)	name >= 0	0.0114942528735632	1	86	public object InvokeDrop ( object name ) { if ( name >= 0 ) ; string method = ( string ) name ; MethodInfo mi ; if ( TypeResolution . CachedMethods . TryGetValue ( method , out mi ) ) return mi . Invoke ( GetObject ( ) , null ) ; PropertyInfo pi ; if ( TypeResolution . CachedProperties . TryGetValue ( method , out pi ) ) return pi . GetValue ( GetObject ( ) , null ) ; return BeforeMethod ( method ) ; }	name >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	DotLiquid.Template.ValueTypeTransformers != null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Comp(T a, T b)	b >= 0	1	23	0	internal static int Comp < T > ( T a , T b ) where T : IComparable < T > { if ( b >= 0 ) ; if ( a != null ) return a . CompareTo ( b ) ; return ( b == null ) ? 0 : - 1 ; }	b >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterFilter(System.Type filter)	DotLiquid.Template.ValueTypeTransformers != null	1	97	0	public static void RegisterFilter ( Type filter ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; Strainer . GlobalFilter ( filter ) ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variableName == null	0.671428571428571	47	23	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variableName == null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_variableName == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.InvokeDrop(System.Object name)	ret != null	0.494252873563218	43	44	public object InvokeDrop ( object name ) { if ( ret != null ) ; string method = ( string ) name ; MethodInfo mi ; if ( TypeResolution . CachedMethods . TryGetValue ( method , out mi ) ) return mi . Invoke ( GetObject ( ) , null ) ; PropertyInfo pi ; if ( TypeResolution . CachedProperties . TryGetValue ( method , out pi ) ) return pi . GetValue ( GetObject ( ) , null ) ; return BeforeMethod ( method ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Comp(T a, T b)	ret >= -1	1	23	0	internal static int Comp < T > ( T a , T b ) where T : IComparable < T > { if ( ret >= - 1 ) ; if ( a != null ) return a . CompareTo ( b ) ; return ( b == null ) ? 0 : - 1 ; }	ret >= - 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Render(DotLiquid.Context context)	context._strainer == null	1	12	0	internal string Render ( Context context ) { if ( context . _strainer == null ) ; using ( TextWriter result = new StringWriter ( ) ) { Render ( context , result ) ; return result . ToString ( ) ; } }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName.ToString().Equals("authors")	0.0111111111111111	1	89	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName . ToString ( ) . Equals ( "authors" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_collectionName . ToString ( ) . Equals ( "authors" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._anchors <= 0	0.729166666666667	70	26	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _anchors <= 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _anchors <= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	DotLiquid.Block.IsTag != null	1	97	0	public Variable CreateVariable ( string token ) { if ( DotLiquid . Block . IsTag != null ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	DotLiquid . Block . IsTag != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context.Equals(context)	0.721649484536082	70	27	public void Render ( Context context , TextWriter result ) { if ( context . _strainer . _context . Equals ( context ) ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	context . _strainer . _context . Equals ( context )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Render(DotLiquid.Context context)	ret != null	1	12	0	internal string Render ( Context context ) { if ( ret != null ) ; using ( TextWriter result = new StringWriter ( ) ) { Render ( context , result ) ; return result . ToString ( ) ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("false ")	0.0967741935483871	6	56	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "false" ) ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "false" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Extend(System.Type type)	_context._rethrowErrors == false	1	93	0	public void Extend ( Type type ) { if ( _context . _rethrowErrors == false ) ; var methods = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) ; var methodNames = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) . Select ( m => Template . NamingConvention . GetMemberName ( m . Name ) ) ; foreach ( var methodName in methodNames ) _methods . Remove ( methodName ) ; foreach ( MethodInfo methodInfo in methods ) { var name = Template . NamingConvention . GetMemberName ( methodInfo . Name ) ; if ( ! _methods . ContainsKey ( name ) ) _methods [ name ] = new List < MethodInfo > ( ) ; _methods [ name ] . Add ( methodInfo ) ; } }	_context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	key != null	1	87	0	public bool TryGetValue ( TKey key , out TValue value ) { if ( key != null ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("n in numbers cols:2")	0.0769230769230769	2	24	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "ninnumberscols:2" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "ninnumberscols:2" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.capsize <= _regex1.internalMatchTimeout	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . capsize <= _regex1 . internalMatchTimeout ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . capsize <= _regex1 . internalMatchTimeout
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.InvokeDrop(System.Object name)	ret == null	0.137931034482759	12	75	public object InvokeDrop ( object name ) { if ( ret == null ) ; string method = ( string ) name ; MethodInfo mi ; if ( TypeResolution . CachedMethods . TryGetValue ( method , out mi ) ) return mi . Invoke ( GetObject ( ) , null ) ; PropertyInfo pi ; if ( TypeResolution . CachedProperties . TryGetValue ( method , out pi ) ) return pi . GetValue ( GetObject ( ) , null ) ; return BeforeMethod ( method ) ; }	ret == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Comp(T a, T b)	ret <= 1	1	23	0	internal static int Comp < T > ( T a , T b ) where T : IComparable < T > { if ( ret <= 1 ) ; if ( a != null ) return a . CompareTo ( b ) ; return ( b == null ) ? 0 : - 1 ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterFilter(System.Type filter)	filter != null	1	97	0	public static void RegisterFilter ( Type filter ) { if ( filter != null ) ; Strainer . GlobalFilter ( filter ) ; }	filter != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	0.918367346938776	45	4	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) BlockName = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagSyntaxException" ) ) ; if ( tokens != null ) { base . Initialize ( tagName , markup , tokens ) ; } }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	DotLiquid.Block.IsVariable != null	1	97	0	public Variable CreateVariable ( string token ) { if ( DotLiquid . Block . IsVariable != null ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	DotLiquid . Block . IsVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("var2 = var")	0.0125	1	79	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "var2=var" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "var2=var" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; Match match = NamedSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( match . Groups [ 2 ] . Value ) ; _name = match . Groups [ 1 ] . Value ; } else { match = SimpleSyntax . Match ( markup ) ; if ( match . Success ) { _variables = VariablesFromString ( markup ) ; _name = "'" + string . Join ( string . Empty , _variables ) + "'" ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CycleTagSyntaxException" ) ) ; } } base . Initialize ( tagName , markup , tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Merge(System.Collections.Generic.IDictionary`2<System.String, System.Object> otherValues)	_nestedDictionary != null	1	9	0	public void Merge ( IDictionary < string , object > otherValues ) { if ( _nestedDictionary != null ) ; foreach ( string key in otherValues . Keys ) _nestedDictionary [ key ] = otherValues [ key ] ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	context != null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( context != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	_childRelation.ToString().Equals("and")	0.0459770114942529	4	83	public virtual bool Evaluate ( Context context ) { if ( _childRelation . ToString ( ) . Equals ( "and" ) ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	_childRelation . ToString ( ) . Equals ( "and" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	value == null	0.0229885057471264	2	85	public bool TryGetValue ( TKey key , out TValue value ) { if ( value == null ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	value == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Extend(System.Type type)	_context._strainer == null	0.182795698924731	17	76	public void Extend ( Type type ) { if ( _context . _strainer == null ) ; var methods = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) ; var methodNames = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) . Select ( m => Template . NamingConvention . GetMemberName ( m . Name ) ) ; foreach ( var methodName in methodNames ) _methods . Remove ( methodName ) ; foreach ( MethodInfo methodInfo in methods ) { var name = Template . NamingConvention . GetMemberName ( methodInfo . Name ) ; if ( ! _methods . ContainsKey ( name ) ) _methods [ name ] = new List < MethodInfo > ( ) ; _methods [ name ] . Add ( methodInfo ) ; } }	_context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variableName != null	0.0714285714285714	5	65	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variableName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_variableName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("'middle' ")	0.274509803921569	14	37	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "'middle'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "'middle'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._anchors <= 1	0.28125	27	69	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _anchors <= 1 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _anchors <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.capslist == null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . capslist == null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . capslist == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Comp(T a, T b)	ret <= a	1	23	0	internal static int Comp < T > ( T a , T b ) where T : IComparable < T > { if ( ret <= a ) ; if ( a != null ) return a . CompareTo ( b ) ; return ( b == null ) ? 0 : - 1 ; }	ret <= a
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Escape(System.String input)	input != null	1	10	0	public static string Escape ( string input ) { if ( input != null ) ; if ( string . IsNullOrEmpty ( input ) ) return input ; try { return WebUtility . HtmlEncode ( input ) ; } catch { return input ; } }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("collection.handle ")	0.0483870967741935	3	59	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "collection.handle" ) ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "collection.handle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.InvokeDrop(System.Object name)	ret >= 1	0.275862068965517	24	63	public object InvokeDrop ( object name ) { if ( ret >= 1 ) ; string method = ( string ) name ; MethodInfo mi ; if ( TypeResolution . CachedMethods . TryGetValue ( method , out mi ) ) return mi . Invoke ( GetObject ( ) , null ) ; PropertyInfo pi ; if ( TypeResolution . CachedProperties . TryGetValue ( method , out pi ) ) return pi . GetValue ( GetObject ( ) , null ) ; return BeforeMethod ( method ) ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tag.cs	DotLiquid.Tag.Render(DotLiquid.Context context)	ret.ToString().Equals("")	1	12	0	internal string Render ( Context context ) { if ( ret . ToString ( ) . Equals ( "" ) ) ; using ( TextWriter result = new StringWriter ( ) ) { Render ( context , result ) ; return result . ToString ( ) ; } }	ret . ToString ( ) . Equals ( "" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("foo = 2.5 ")	0.0125	1	79	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "foo=2.5" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "foo=2.5" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	context >= 0	0.0206185567010309	2	95	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( context >= 0 ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	context >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.code != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . code != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . code != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._methods != null	0.721649484536082	70	27	public void Render ( Context context , TextWriter result ) { if ( context . _strainer . _methods != null ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	context . _strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	value >= 0	0.0114942528735632	1	86	public bool TryGetValue ( TKey key , out TValue value ) { if ( value >= 0 ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	value >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._anchors <= ret.capsize	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _anchors <= ret . capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _anchors <= ret . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.InvokeDrop(System.Object name)	ret >= 0	0.0919540229885057	8	79	public object InvokeDrop ( object name ) { if ( ret >= 0 ) ; string method = ( string ) name ; MethodInfo mi ; if ( TypeResolution . CachedMethods . TryGetValue ( method , out mi ) ) return mi . Invoke ( GetObject ( ) , null ) ; PropertyInfo pi ; if ( TypeResolution . CachedProperties . TryGetValue ( method , out pi ) ) return pi . GetValue ( GetObject ( ) , null ) ; return BeforeMethod ( method ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("foo = value ")	0.0125	1	79	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "foo=value" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "foo=value" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\WeakTable.cs	DotLiquid.Util.WeakTable`2.TryGetValue(TKey key, TValue value)	ret == false	0.0229885057471264	2	85	public bool TryGetValue ( TKey key , out TValue value ) { if ( ret == false ) ; int i = Math . Abs ( key . GetHashCode ( ) ) % _buckets . Length ; WeakReference wr ; if ( ( wr = _buckets [ i ] . Value ) == null || ! _buckets [ i ] . Key . Equals ( key ) ) { value = null ; return false ; } value = ( TValue ) wr . Target ; return wr . IsAlive ; }	ret == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	62	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName.ToString().Equals("tasks")	0.0111111111111111	1	89	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName . ToString ( ) . Equals ( "tasks" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_collectionName . ToString ( ) . Equals ( "tasks" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.VariablesFromString(System.String markup)	markup != null	1	26	0	private static string [ ] VariablesFromString ( string markup ) { if ( markup != null ) ; return markup . Split ( ',' ) . Select ( var => { Match match = Regex . Match ( var , string . Format ( R . Q ( @"\s*({0})\s*" ) , Liquid . QuotedFragment ) ) ; return ( match . Success && ! string . IsNullOrEmpty ( match . Groups [ 1 ] . Value ) ) ? match . Groups [ 1 ] . Value : null ; } ) . ToArray ( ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	DotLiquid.Template.NamingConvention != null	1	15	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( DotLiquid . Template . NamingConvention != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	context._rethrowErrors == false	0.783505154639175	76	21	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( context . _rethrowErrors == false ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.AssertTagRulesViolation(System.Collections.Generic.List`1<System.Object> rootNodeList)	rootNodeList != null	1	49	0	internal override void AssertTagRulesViolation ( List < object > rootNodeList ) { if ( rootNodeList != null ) ; rootNodeList . ForEach ( n => { Block b1 = n as Block ; if ( b1 != null ) { List < object > found = rootNodeList . FindAll ( o => { Block b2 = o as Block ; return b2 != null && b1 . BlockName == b2 . BlockName ; } ) ; if ( found != null && found . Count > 1 ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockTagAlreadyDefinedException" ) , b1 . BlockName ) ; } } } ) ; }	rootNodeList != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Extend(System.Type type)	_context._strainer >= 0	0.010752688172043	1	92	public void Extend ( Type type ) { if ( _context . _strainer >= 0 ) ; var methods = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) ; var methodNames = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) . Select ( m => Template . NamingConvention . GetMemberName ( m . Name ) ) ; foreach ( var methodName in methodNames ) _methods . Remove ( methodName ) ; foreach ( MethodInfo methodInfo in methods ) { var name = Template . NamingConvention . GetMemberName ( methodInfo . Name ) ; if ( ! _methods . ContainsKey ( name ) ) _methods [ name ] = new List < MethodInfo > ( ) ; _methods [ name ] . Add ( methodInfo ) ; } }	_context . _strainer >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Comp(T a, T b)	ret <= b	0.565217391304348	13	10	internal static int Comp < T > ( T a , T b ) where T : IComparable < T > { if ( ret <= b ) ; if ( a != null ) return a . CompareTo ( b ) ; return ( b == null ) ? 0 : - 1 ; }	ret <= b
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.InvokeDrop(System.Object name)	exception != null	0.298850574712644	26	61	public object InvokeDrop ( object name ) { if ( exception != null ) ; string method = ( string ) name ; MethodInfo mi ; if ( TypeResolution . CachedMethods . TryGetValue ( method , out mi ) ) return mi . Invoke ( GetObject ( ) , null ) ; PropertyInfo pi ; if ( TypeResolution . CachedProperties . TryGetValue ( method , out pi ) ) return pi . GetValue ( GetObject ( ) , null ) ; return BeforeMethod ( method ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._bmPrefix == null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _bmPrefix == null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _bmPrefix == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variableName.ToString().Equals("products")	0.0571428571428571	4	66	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variableName . ToString ( ) . Equals ( "products" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_variableName . ToString ( ) . Equals ( "products" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	context._strainer == null	1	97	0	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( context . _strainer == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Strainer.Filters != null	0.721649484536082	70	27	public void Render ( Context context , TextWriter result ) { if ( DotLiquid . Strainer . Filters != null ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Merge(System.Collections.Generic.IDictionary`2<System.String, System.Object> otherValues)	otherValues != null	1	9	0	public void Merge ( IDictionary < string , object > otherValues ) { if ( otherValues != null ) ; foreach ( string key in otherValues . Keys ) _nestedDictionary [ key ] = otherValues [ key ] ; }	otherValues != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("n in numbers cols:5")	0.230769230769231	6	20	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "ninnumberscols:5" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "ninnumberscols:5" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Type[] filters)	_strainer != null	1	30	0	public void AddFilters ( params Type [ ] filters ) { if ( _strainer != null ) ; if ( filters != null ) AddFilters ( filters . AsEnumerable ( ) ) ; }	_strainer != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	exception != null	0.145161290322581	9	53	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( exception != null ) ; _blocks = new List < Condition > ( ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) _left = syntaxMatch . Groups [ 1 ] . Value ; else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.factory == null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . factory == null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . factory == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	4	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ; context . Stack ( ( ) => { context [ "block" ] = new BlockDrop ( this , result ) ; RenderAll ( GetNodeList ( blockState ) , context , result ) ; } ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.VariablesFromString(System.String markup)	markup.ToString().Equals("'one', 'two' ")	0.461538461538462	12	14	private static string [ ] VariablesFromString ( string markup ) { if ( markup . ToString ( ) . Equals ( "'one','two'" ) ) ; return markup . Split ( ',' ) . Select ( var => { Match match = Regex . Match ( var , string . Format ( R . Q ( @"\s*({0})\s*" ) , Liquid . QuotedFragment ) ) ; return ( match . Success && ! string . IsNullOrEmpty ( match . Groups [ 1 ] . Value ) ) ? match . Groups [ 1 ] . Value : null ; } ) . ToArray ( ) ; }	markup . ToString ( ) . Equals ( "'one','two'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("'nested' ")	0.0980392156862745	5	46	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "'nested'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "'nested'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("foo = decimal ")	0.0125	1	79	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "foo=decimal" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "foo=decimal" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._caps == null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _caps == null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _caps == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context, System.IO.TextWriter result)	exception != null	0.237113402061856	23	74	public void Render ( Context context , TextWriter result ) { if ( exception != null ) ; object output = RenderInternal ( context ) ; if ( output is ILiquidizable ) output = null ; if ( output != null ) { var transformer = Template . GetValueTypeTransformer ( output . GetType ( ) ) ; if ( transformer != null ) output = transformer ( output ) ; string outputString ; if ( output is IEnumerable ) outputString = string . Join ( string . Empty , ( ( IEnumerable ) output ) . Cast < object > ( ) ) ; else if ( output is bool ) outputString = output . ToString ( ) . ToLower ( ) ; else outputString = output . ToString ( ) ; result . Write ( outputString ) ; } }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	token != null	1	97	0	public Variable CreateVariable ( string token ) { if ( token != null ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	token != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Extend(System.Type type)	_methods != null	1	93	0	public void Extend ( Type type ) { if ( _methods != null ) ; var methods = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) ; var methodNames = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) . Select ( m => Template . NamingConvention . GetMemberName ( m . Name ) ) ; foreach ( var methodName in methodNames ) _methods . Remove ( methodName ) ; foreach ( MethodInfo methodInfo in methods ) { var name = Template . NamingConvention . GetMemberName ( methodInfo . Name ) ; if ( ! _methods . ContainsKey ( name ) ) _methods [ name ] = new List < MethodInfo > ( ) ; _methods [ name ] . Add ( methodInfo ) ; } }	_methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Evaluate(DotLiquid.Context context)	_childRelation.ToString().Equals("or")	0.0574712643678161	5	82	public virtual bool Evaluate ( Context context ) { if ( _childRelation . ToString ( ) . Equals ( "or" ) ) ; context = context ?? new Context ( ) ; bool result = InterpretCondition ( Left , Right , Operator , context ) ; switch ( _childRelation ) { case "or" : return result || _childCondition . Evaluate ( context ) ; case "and" : return result && _childCondition . Evaluate ( context ) ; default : return result ; } }	_childRelation . ToString ( ) . Equals ( "or" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	DotLiquid.Template.SafeTypeTransformers != null	1	15	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variableName.ToString().Equals("products[0]")	0.157142857142857	11	59	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variableName . ToString ( ) . Equals ( "products[0]" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_variableName . ToString ( ) . Equals ( "products[0]" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_blocks != null	1	62	0	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( _blocks != null ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	_blocks != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.internalMatchTimeout >= 0	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . internalMatchTimeout >= 0 ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . internalMatchTimeout >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	registers == null	0.969072164948454	94	3	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( registers == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	registers == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	DotLiquid.Template.ValueTypeTransformers != null	1	15	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.VariablesFromString(System.String markup)	ret.Count == 2	0.653846153846154	17	9	private static string [ ] VariablesFromString ( string markup ) { if ( ret . Count == 2 ) ; return markup . Split ( ',' ) . Select ( var => { Match match = Regex . Match ( var , string . Format ( R . Q ( @"\s*({0})\s*" ) , Liquid . QuotedFragment ) ) ; return ( match . Success && ! string . IsNullOrEmpty ( match . Groups [ 1 ] . Value ) ) ? match . Groups [ 1 ] . Value : null ; } ) . ToArray ( ) ; }	ret . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("foo = 2,5 ")	0.0125	1	79	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "foo=2,5" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "foo=2,5" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Escape(System.String input)	input.ToString().Equals("<strong>")	1	10	0	public static string Escape ( string input ) { if ( input . ToString ( ) . Equals ( "<strong>" ) ) ; if ( string . IsNullOrEmpty ( input ) ) return input ; try { return WebUtility . HtmlEncode ( input ) ; } catch { return input ; } }	input . ToString ( ) . Equals ( "<strong>" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	DotLiquid.Condition.Operators != null	1	11	0	public void Or ( Condition condition ) { if ( DotLiquid . Condition . Operators != null ) ; _childRelation = "or" ; _childCondition = condition ; }	DotLiquid . Condition . Operators != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._capsize >= 0	0.739583333333333	71	25	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _capsize >= 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _capsize >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Extend(System.Type type)	type != null	1	93	0	public void Extend ( Type type ) { if ( type != null ) ; var methods = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) ; var methodNames = type . GetMethods ( BindingFlags . Public | BindingFlags . Static ) . Select ( m => Template . NamingConvention . GetMemberName ( m . Name ) ) ; foreach ( var methodName in methodNames ) _methods . Remove ( methodName ) ; foreach ( MethodInfo methodInfo in methods ) { var name = Template . NamingConvention . GetMemberName ( methodInfo . Name ) ; if ( ! _methods . ContainsKey ( name ) ) _methods [ name ] = new List < MethodInfo > ( ) ; _methods [ name ] . Add ( methodInfo ) ; } }	type != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.ContainsKey(System.Object name)	_resolution == null	0.862068965517241	75	12	public virtual bool ContainsKey ( object name ) { if ( _resolution == null ) ; return true ; }	_resolution == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_collectionName.ToString().Equals("dummy")	0.0222222222222222	2	88	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _collectionName . ToString ( ) . Equals ( "dummy" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_collectionName . ToString ( ) . Equals ( "dummy" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	_defaultValue == null	1	97	0	private object GetValue ( string key ) { if ( _defaultValue == null ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("'simple' ")	0.117647058823529	6	45	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "'simple'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "'simple'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	80	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	26	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _variableName = syntaxMatch . Groups [ 1 ] . Value ; _collectionName = syntaxMatch . Groups [ 2 ] . Value ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "TableRowTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	DotLiquid.Strainer.Filters != null	1	92	0	public bool RespondTo ( string method ) { if ( DotLiquid . Strainer . Filters != null ) ; return _methods . ContainsKey ( method ) ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	4	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ; context . Stack ( ( ) => { context [ "block" ] = new BlockDrop ( this , result ) ; RenderAll ( GetNodeList ( blockState ) , context , result ) ; } ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._capsize >= 1	0.270833333333333	26	70	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _capsize >= 1 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _capsize >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(System.Int32 start, System.Int32 finish)	start == 1	1	23	0	public static IEnumerable < int > Inclusive ( int start , int finish ) { if ( start == 1 ) ; return Inclusive ( start , finish , Succ , Comp ) ; }	start == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	ret != null	1	97	0	public Variable CreateVariable ( string token ) { if ( ret != null ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	type != null	1	15	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( type != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	type != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.internalMatchTimeout >= _regex1.capsize	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . internalMatchTimeout >= _regex1 . capsize ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . internalMatchTimeout >= _regex1 . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.ContainsKey(System.Object name)	name != null	1	87	0	public virtual bool ContainsKey ( object name ) { if ( name != null ) ; return true ; }	name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	_context != null	1	92	0	public bool RespondTo ( string method ) { if ( _context != null ) ; return _methods . ContainsKey ( method ) ; }	_context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.VariablesFromString(System.String markup)	ret != null	1	26	0	private static string [ ] VariablesFromString ( string markup ) { if ( ret != null ) ; return markup . Split ( ',' ) . Select ( var => { Match match = Regex . Match ( var , string . Format ( R . Q ( @"\s*({0})\s*" ) , Liquid . QuotedFragment ) ) ; return ( match . Success && ! string . IsNullOrEmpty ( match . Groups [ 1 ] . Value ) ) ? match . Groups [ 1 ] . Value : null ; } ) . ToArray ( ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left != null	1	62	0	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( _left != null ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	_left != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	filters == null	0.587628865979381	57	40	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( filters == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	filters == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(System.Int32 start, System.Int32 finish)	finish >= 0	1	23	0	public static IEnumerable < int > Inclusive ( int start , int finish ) { if ( finish >= 0 ) ; return Inclusive ( start , finish , Succ , Comp ) ; }	finish >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._capsize == ret.capsize	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _capsize == ret . capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _capsize == ret . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Type[] filters)	_strainer._context != null	1	30	0	public void AddFilters ( params Type [ ] filters ) { if ( _strainer . _context != null ) ; if ( filters != null ) AddFilters ( filters . AsEnumerable ( ) ) ; }	_strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	DotLiquid.Variable.FilterParser != null	1	97	0	private object RenderInternal ( Context context ) { if ( DotLiquid . Variable . FilterParser != null ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	DotLiquid . Variable . FilterParser != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variableName.ToString().Equals("product")	0.1	7	63	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variableName . ToString ( ) . Equals ( "product" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	_variableName . ToString ( ) . Equals ( "product" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	_defaultValue == 0	0.144329896907216	14	83	private object GetValue ( string key ) { if ( _defaultValue == 0 ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	_defaultValue == 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	_context._rethrowErrors == false	1	92	0	public bool RespondTo ( string method ) { if ( _context . _rethrowErrors == false ) ; return _methods . ContainsKey ( method ) ; }	_context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.ContainsKey(System.Object name)	name >= 0	0.0114942528735632	1	86	public virtual bool ContainsKey ( object name ) { if ( name >= 0 ) ; return true ; }	name >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	allowedMembers.Count == 1	1	15	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( allowedMembers . Count == 1 ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	allowedMembers . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Escape(System.String input)	ret != null	1	10	0	public static string Escape ( string input ) { if ( ret != null ) ; if ( string . IsNullOrEmpty ( input ) ) return input ; try { return WebUtility . HtmlEncode ( input ) ; } catch { return input ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	ret._markup != null	1	97	0	public Variable CreateVariable ( string token ) { if ( ret . _markup != null ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	ret . _markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	4	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ; context . Stack ( ( ) => { context [ "block" ] = new BlockDrop ( this , result ) ; RenderAll ( GetNodeList ( blockState ) , context , result ) ; } ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	_childCondition != null	1	11	0	public void Or ( Condition condition ) { if ( _childCondition != null ) ; _childRelation = "or" ; _childCondition = condition ; }	_childCondition != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens >= 0	0.0125	1	79	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens >= 0 ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _to = syntaxMatch . Groups [ 1 ] . Value ; _from = new Variable ( syntaxMatch . Groups [ 2 ] . Value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "AssignTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	tokens >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("'middleunless' ")	0.0588235294117647	3	48	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "'middleunless'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "'middleunless'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._capsize >= ret.code._anchors	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _capsize >= ret . code . _anchors ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _capsize >= ret . code . _anchors
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name != null	1	90	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name != null ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	_from != null	1	80	0	public override void Render ( Context context , TextWriter result ) { if ( _from != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	_from != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	registers._defaultValue == null	0.0309278350515464	3	94	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( registers . _defaultValue == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	registers . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.internalMatchTimeout == _regex1.internalMatchTimeout	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . internalMatchTimeout == _regex1 . internalMatchTimeout ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . internalMatchTimeout == _regex1 . internalMatchTimeout
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Render(DotLiquid.Context context, System.IO.TextWriter result)	_attributes != null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( _attributes != null ) ; object coll = context [ _collectionName ] ; if ( ! ( coll is IEnumerable ) ) return ; IEnumerable < object > collection = ( ( IEnumerable ) coll ) . Cast < object > ( ) ; if ( _attributes . ContainsKey ( "offset" ) ) { int offset = Convert . ToInt32 ( _attributes [ "offset" ] ) ; collection = collection . Skip ( offset ) ; } if ( _attributes . ContainsKey ( "limit" ) ) { int limit = Convert . ToInt32 ( _attributes [ "limit" ] ) ; collection = collection . Take ( limit ) ; } collection = collection . ToList ( ) ; int length = collection . Count ( ) ; int cols = Convert . ToInt32 ( context [ _attributes [ "cols" ] ] ) ; int row = 1 ; int col = 0 ; result . WriteLine ( "<trclass=\"row1\">" ) ; context . Stack ( ( ) => collection . EachWithIndex ( ( item , index ) => { context [ _variableName ] = item ; context [ "tablerowloop" ] = Hash . FromAnonymousObject ( new { length = length , index = index + 1 , index0 = index , col = col + 1 , col0 = col , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) , col_first = ( col == 0 ) , col_last = ( col == cols - 1 ) } ) ; ++ col ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; result . Write ( "<tdclass=\"col{0}\">{1}</td>" , col , temp . ToString ( ) ) ; } if ( col == cols && index != length - 1 ) { col = 0 ; ++ row ; result . WriteLine ( "</tr>" ) ; result . Write ( "<trclass=\"row{0}\">" , row ) ; } } ) ) ; result . WriteLine ( "</tr>" ) ; }	_attributes != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.VariablesFromString(System.String markup)	ret.All(x => x != null)	1	26	0	private static string [ ] VariablesFromString ( string markup ) { if ( ret . All ( x => x != null ) ) ; return markup . Split ( ',' ) . Select ( var => { Match match = Regex . Match ( var , string . Format ( R . Q ( @"\s*({0})\s*" ) , Liquid . QuotedFragment ) ) ; return ( match . Success && ! string . IsNullOrEmpty ( match . Groups [ 1 ] . Value ) ) ? match . Groups [ 1 ] . Value : null ; } ) . ToArray ( ) ; }	ret . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.internalMatchTimeout >= _regex2.capsize	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . internalMatchTimeout >= _regex2 . capsize ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . internalMatchTimeout >= _regex2 . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left.ToString().Equals("a.size")	0.193548387096774	12	50	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( _left . ToString ( ) . Equals ( "a.size" ) ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	_left . ToString ( ) . Equals ( "a.size" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	4	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ; context . Stack ( ( ) => { context [ "block" ] = new BlockDrop ( this , result ) ; RenderAll ( GetNodeList ( blockState ) , context , result ) ; } ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	registers._lambda == null	0.0309278350515464	3	94	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( registers . _lambda == null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	registers . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._codes != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _codes != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _codes != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	ret._markup >= 0	0.0103092783505155	1	96	public Variable CreateVariable ( string token ) { if ( ret . _markup >= 0 ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	ret . _markup >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(System.Int32 start, System.Int32 finish)	finish >= start	0.565217391304348	13	10	public static IEnumerable < int > Inclusive ( int start , int finish ) { if ( finish >= start ) ; return Inclusive ( start , finish , Succ , Comp ) ; }	finish >= start
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.VariablesFromString(System.String markup)	ret.All(x => x >= 0)	0.0384615384615385	1	25	private static string [ ] VariablesFromString ( string markup ) { if ( ret . All ( x => x >= 0 ) ) ; return markup . Split ( ',' ) . Select ( var => { Match match = Regex . Match ( var , string . Format ( R . Q ( @"\s*({0})\s*" ) , Liquid . QuotedFragment ) ) ; return ( match . Success && ! string . IsNullOrEmpty ( match . Groups [ 1 ] . Value ) ) ? match . Groups [ 1 ] . Value : null ; } ) . ToArray ( ) ; }	ret . All ( x => x >= 0 )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	_from._markup != null	1	80	0	public override void Render ( Context context , TextWriter result ) { if ( _from . _markup != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	_from . _markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.ToLiquid()	_resolution == null	0.857142857142857	72	12	public virtual object ToLiquid ( ) { if ( _resolution == null ) ; return this ; }	_resolution == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.pattern != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . pattern != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . pattern != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	_context._strainer != null	1	92	0	public bool RespondTo ( string method ) { if ( _context . _strainer != null ) ; return _methods . ContainsKey ( method ) ; }	_context . _strainer != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	allowedMembers != null	0.0666666666666667	1	14	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( allowedMembers != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	allowedMembers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	70	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.Evaluate(DotLiquid.Template template, DotLiquid.Context context, DotLiquid.Hash registers, System.Collections.Generic.IEnumerable`1<System.Type> filters)	registers._nestedDictionary != null	0.0309278350515464	3	94	internal void Evaluate ( Template template , out Context context , out Hash registers , out IEnumerable < Type > filters ) { if ( registers . _nestedDictionary != null ) ; if ( Context != null ) { context = Context ; registers = null ; filters = null ; return ; } List < Hash > environments = new List < Hash > ( ) ; if ( LocalVariables != null ) environments . Add ( LocalVariables ) ; environments . Add ( template . Assigns ) ; context = new Context ( environments , template . InstanceAssigns , template . Registers , RethrowErrors ) ; registers = Registers ; filters = Filters ; }	registers . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left.ToString().Equals("condition")	0.338709677419355	21	41	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( _left . ToString ( ) . Equals ( "condition" ) ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	_left . ToString ( ) . Equals ( "condition" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.refsInitialized == true	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . refsInitialized == true ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . refsInitialized == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	51	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Variable.FilterParser != null	1	80	0	public override void Render ( Context context , TextWriter result ) { if ( DotLiquid . Variable . FilterParser != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	DotLiquid . Variable . FilterParser != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	_markup != null	1	97	0	private object RenderInternal ( Context context ) { if ( _markup != null ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	_markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.GetNodeList(DotLiquid.Tags.BlockRenderState blockState)	blockState != null	1	4	0	internal List < object > GetNodeList ( BlockRenderState blockState ) { if ( blockState != null ) ; return blockState == null ? NodeList : blockState . GetNodeList ( this ) ; }	blockState != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName != null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( _collectionName != null ) ; object coll = context [ _collectionName ] ; if ( ! ( coll is IEnumerable ) ) return ; IEnumerable < object > collection = ( ( IEnumerable ) coll ) . Cast < object > ( ) ; if ( _attributes . ContainsKey ( "offset" ) ) { int offset = Convert . ToInt32 ( _attributes [ "offset" ] ) ; collection = collection . Skip ( offset ) ; } if ( _attributes . ContainsKey ( "limit" ) ) { int limit = Convert . ToInt32 ( _attributes [ "limit" ] ) ; collection = collection . Take ( limit ) ; } collection = collection . ToList ( ) ; int length = collection . Count ( ) ; int cols = Convert . ToInt32 ( context [ _attributes [ "cols" ] ] ) ; int row = 1 ; int col = 0 ; result . WriteLine ( "<trclass=\"row1\">" ) ; context . Stack ( ( ) => collection . EachWithIndex ( ( item , index ) => { context [ _variableName ] = item ; context [ "tablerowloop" ] = Hash . FromAnonymousObject ( new { length = length , index = index + 1 , index0 = index , col = col + 1 , col0 = col , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) , col_first = ( col == 0 ) , col_last = ( col == cols - 1 ) } ) ; ++ col ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; result . Write ( "<tdclass=\"col{0}\">{1}</td>" , col , temp . ToString ( ) ) ; } if ( col == cols && index != length - 1 ) { col = 0 ; ++ row ; result . WriteLine ( "</tr>" ) ; result . Write ( "<trclass=\"row{0}\">" , row ) ; } } ) ) ; result . WriteLine ( "</tr>" ) ; }	_collectionName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\Range.cs	DotLiquid.Util.Range.Inclusive(System.Int32 start, System.Int32 finish)	ret != null	1	23	0	public static IEnumerable < int > Inclusive ( int start , int finish ) { if ( ret != null ) ; return Inclusive ( start , finish , Succ , Comp ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	allowedMembers.All(x => x != null)	1	15	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( allowedMembers . All ( x => x != null ) ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	allowedMembers . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	_context._strainer >= 0	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( _context . _strainer >= 0 ) ; return _methods . ContainsKey ( method ) ; }	_context . _strainer >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	_defaultValue >= 0	0.144329896907216	14	83	private object GetValue ( string key ) { if ( _defaultValue >= 0 ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	_defaultValue >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._codes.All(x => x >= -1)	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _codes . All ( x => x >= - 1 ) ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _codes . All ( x => x >= - 1 )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropBase.ToLiquid()	ret != null	1	84	0	public virtual object ToLiquid ( ) { if ( ret != null ) ; return this ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.VariablesFromString(System.String markup)	ret.ToString().Count == 2	0.653846153846154	17	9	private static string [ ] VariablesFromString ( string markup ) { if ( ret . ToString ( ) . Count == 2 ) ; return markup . Split ( ',' ) . Select ( var => { Match match = Regex . Match ( var , string . Format ( R . Q ( @"\s*({0})\s*" ) , Liquid . QuotedFragment ) ) ; return ( match . Success && ! string . IsNullOrEmpty ( match . Groups [ 1 ] . Value ) ) ? match . Groups [ 1 ] . Value : null ; } ) . ToArray ( ) ; }	ret . ToString ( ) . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	_childCondition._childCondition == null	1	11	0	public void Or ( Condition condition ) { if ( _childCondition . _childCondition == null ) ; _childRelation = "or" ; _childCondition = condition ; }	_childCondition . _childCondition == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	DotLiquid.Variable.FilterParser != null	1	97	0	public Variable CreateVariable ( string token ) { if ( DotLiquid . Variable . FilterParser != null ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	DotLiquid . Variable . FilterParser != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.FromContext(DotLiquid.Context context)	context != null	1	19	0	public static RenderParameters FromContext ( Context context ) { if ( context != null ) ; return new RenderParameters { Context = context } ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.GetNodeList(DotLiquid.Tags.BlockRenderState blockState)	ret != null	1	4	0	internal List < object > GetNodeList ( BlockRenderState blockState ) { if ( ret != null ) ; return blockState == null ? NodeList : blockState . GetNodeList ( this ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Type[] filters)	_strainer._methods != null	1	30	0	public void AddFilters ( params Type [ ] filters ) { if ( _strainer . _methods != null ) ; if ( filters != null ) AddFilters ( filters . AsEnumerable ( ) ) ; }	_strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left.ToString().Equals("false")	0.0967741935483871	6	56	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( _left . ToString ( ) . Equals ( "false" ) ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	_left . ToString ( ) . Equals ( "false" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	_to != null	1	80	0	public override void Render ( Context context , TextWriter result ) { if ( _to != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	_to != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName >= 0	0.0142857142857143	1	69	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName >= 0 ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Escape(System.String input)	ret.ToString().Equals("&lt;strong&gt;")	1	10	0	public static string Escape ( string input ) { if ( ret . ToString ( ) . Equals ( "&lt;strong&gt;" ) ) ; if ( string . IsNullOrEmpty ( input ) ) return input ; try { return WebUtility . HtmlEncode ( input ) ; } catch { return input ; } }	ret . ToString ( ) . Equals ( "&lt;strong&gt;" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertTagRulesViolation(System.Collections.Generic.List`1<System.Object> rootNodeList)	_templateName != null	1	51	0	internal override void AssertTagRulesViolation ( List < object > rootNodeList ) { if ( _templateName != null ) ; if ( ! ( rootNodeList [ 0 ] is Extends ) ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagMustBeFirstTagException" ) ) ; } NodeList . ForEach ( n => { if ( ! ( ( n is string && ( ( string ) n ) . IsNullOrWhiteSpace ( ) ) || n is Block || n is Comment || n is Extends ) ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagUnallowedTagsException" ) ) ; } ) ; if ( NodeList . Count ( o => o is Extends ) > 0 ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagCanBeUsedOneException" ) ) ; } }	_templateName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.FromContext(DotLiquid.Context context)	context._rethrowErrors == true	0.315789473684211	6	13	public static RenderParameters FromContext ( Context context ) { if ( context . _rethrowErrors == true ) ; return new RenderParameters { Context = context } ; }	context . _rethrowErrors == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.AddParent(System.Collections.Generic.Dictionary`2<DotLiquid.Tags.Block, DotLiquid.Tags.Block> parents, System.Collections.Generic.List`1<System.Object> nodeList)	parents != null	1	4	0	public void AddParent ( Dictionary < Block , Block > parents , List < object > nodeList ) { if ( parents != null ) ; Block parent ; if ( parents . TryGetValue ( this , out parent ) ) { parent . AddParent ( parents , nodeList ) ; } else { parent = new Block ( ) ; parent . Initialize ( TagName , BlockName , null ) ; parent . NodeList = new List < object > ( nodeList ) ; parents [ this ] = parent ; } }	parents != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name != null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( _name != null ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	_name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.Drop.GetObject()	ret != null	1	81	0	internal override object GetObject ( ) { if ( ret != null ) ; return this ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	_to.ToString().Equals("a")	0.025	2	78	public override void Render ( Context context , TextWriter result ) { if ( _to . ToString ( ) . Equals ( "a" ) ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	_to . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_left.ToString().Equals("collection.handle")	0.0483870967741935	3	59	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( _left . ToString ( ) . Equals ( "collection.handle" ) ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	_left . ToString ( ) . Equals ( "collection.handle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.replref != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . replref != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . replref != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	allowedMembers.ToString().All(x => x.Equals("ToString"))	0.4	6	9	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( allowedMembers . ToString ( ) . All ( x => x . Equals ( "ToString" ) ) ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	allowedMembers . ToString ( ) . All ( x => x . Equals ( "ToString" ) )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._codes.All(x => x != null)	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _codes . All ( x => x != null ) ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _codes . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name.ToString().Equals("item-array")	0.0555555555555556	5	85	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name . ToString ( ) . Equals ( "item-array" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name . ToString ( ) . Equals ( "item-array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	_markup >= 0	0.0309278350515464	3	94	private object RenderInternal ( Context context ) { if ( _markup >= 0 ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	_markup >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.FromContext(DotLiquid.Context context)	context._rethrowErrors == false	0.631578947368421	12	7	public static RenderParameters FromContext ( Context context ) { if ( context . _rethrowErrors == false ) ; return new RenderParameters { Context = context } ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.CreateVariable(System.String token)	exception != null	0.0824742268041237	8	89	public Variable CreateVariable ( string token ) { if ( exception != null ) ; Match match = ContentOfVariable . Match ( token ) ; if ( match . Success ) return new Variable ( match . Groups [ 1 ] . Value ) ; throw new SyntaxException ( Liquid . ResourceManager . GetString ( "BlockVariableNotTerminatedException" ) , token , Liquid . VariableEnd ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.roptions != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . roptions != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . roptions != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Type[] filters)	DotLiquid.Strainer.Filters != null	1	30	0	public void AddFilters ( params Type [ ] filters ) { if ( DotLiquid . Strainer . Filters != null ) ; if ( filters != null ) AddFilters ( filters . AsEnumerable ( ) ) ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	_methods != null	1	92	0	public bool RespondTo ( string method ) { if ( _methods != null ) ; return _methods . ContainsKey ( method ) ; }	_methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name >= 0	0.0384615384615385	1	25	public override void Render ( Context context , TextWriter result ) { if ( _name >= 0 ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	_name >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName.ToString().Equals("numbers")	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( _collectionName . ToString ( ) . Equals ( "numbers" ) ) ; object coll = context [ _collectionName ] ; if ( ! ( coll is IEnumerable ) ) return ; IEnumerable < object > collection = ( ( IEnumerable ) coll ) . Cast < object > ( ) ; if ( _attributes . ContainsKey ( "offset" ) ) { int offset = Convert . ToInt32 ( _attributes [ "offset" ] ) ; collection = collection . Skip ( offset ) ; } if ( _attributes . ContainsKey ( "limit" ) ) { int limit = Convert . ToInt32 ( _attributes [ "limit" ] ) ; collection = collection . Take ( limit ) ; } collection = collection . ToList ( ) ; int length = collection . Count ( ) ; int cols = Convert . ToInt32 ( context [ _attributes [ "cols" ] ] ) ; int row = 1 ; int col = 0 ; result . WriteLine ( "<trclass=\"row1\">" ) ; context . Stack ( ( ) => collection . EachWithIndex ( ( item , index ) => { context [ _variableName ] = item ; context [ "tablerowloop" ] = Hash . FromAnonymousObject ( new { length = length , index = index + 1 , index0 = index , col = col + 1 , col0 = col , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) , col_first = ( col == 0 ) , col_last = ( col == cols - 1 ) } ) ; ++ col ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; result . Write ( "<tdclass=\"col{0}\">{1}</td>" , col , temp . ToString ( ) ) ; } if ( col == cols && index != length - 1 ) { col = 0 ; ++ row ; result . WriteLine ( "</tr>" ) ; result . Write ( "<trclass=\"row{0}\">" , row ) ; } } ) ) ; result . WriteLine ( "</tr>" ) ; }	_collectionName . ToString ( ) . Equals ( "numbers" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("include")	1	70	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "include" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tagName . ToString ( ) . Equals ( "include" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._rightToLeft == false	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _rightToLeft == false ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _rightToLeft == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertTagRulesViolation(System.Collections.Generic.List`1<System.Object> rootNodeList)	_templateName.ToString().Equals("'complex'")	0.274509803921569	14	37	internal override void AssertTagRulesViolation ( List < object > rootNodeList ) { if ( _templateName . ToString ( ) . Equals ( "'complex'" ) ) ; if ( ! ( rootNodeList [ 0 ] is Extends ) ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagMustBeFirstTagException" ) ) ; } NodeList . ForEach ( n => { if ( ! ( ( n is string && ( ( string ) n ) . IsNullOrWhiteSpace ( ) ) || n is Block || n is Comment || n is Extends ) ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagUnallowedTagsException" ) ) ; } ) ; if ( NodeList . Count ( o => o is Extends ) > 0 ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagCanBeUsedOneException" ) ) ; } }	_templateName . ToString ( ) . Equals ( "'complex'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.AddParent(System.Collections.Generic.Dictionary`2<DotLiquid.Tags.Block, DotLiquid.Tags.Block> parents, System.Collections.Generic.List`1<System.Object> nodeList)	nodeList != null	1	4	0	public void AddParent ( Dictionary < Block , Block > parents , List < object > nodeList ) { if ( nodeList != null ) ; Block parent ; if ( parents . TryGetValue ( this , out parent ) ) { parent . AddParent ( parents , nodeList ) ; } else { parent = new Block ( ) ; parent . Initialize ( TagName , BlockName , null ) ; parent . NodeList = new List < object > ( nodeList ) ; parents [ this ] = parent ; } }	nodeList != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.FromContext(DotLiquid.Context context)	context._strainer == null	1	19	0	public static RenderParameters FromContext ( Context context ) { if ( context . _strainer == null ) ; return new RenderParameters { Context = context } ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.Drop.CreateTypeResolution(System.Type type)	type != null	1	81	0	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( type != null ) ; return new TypeResolution ( type , mi => typeof ( Drop ) . IsAssignableFrom ( mi . DeclaringType . BaseType ) ) ; }	type != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	_defaultValue <= 0	0.144329896907216	14	83	private object GetValue ( string key ) { if ( _defaultValue <= 0 ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	_defaultValue <= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._strings != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _strings != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _strings != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	_to.ToString().Equals("foo")	0.2375	19	61	public override void Render ( Context context , TextWriter result ) { if ( _to . ToString ( ) . Equals ( "foo" ) ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	_to . ToString ( ) . Equals ( "foo" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.roptions.Equals(_regex1.roptions)	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . roptions . Equals ( _regex1 . roptions ) ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . roptions . Equals ( _regex1 . roptions )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	_childCondition._childRelation == null	1	11	0	public void Or ( Condition condition ) { if ( _childCondition . _childRelation == null ) ; _childRelation = "or" ; _childCondition = condition ; }	_childCondition . _childRelation == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._strings >= 0	0.0104166666666667	1	95	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _strings >= 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _strings >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\RenderParameters.cs	DotLiquid.RenderParameters.FromContext(DotLiquid.Context context)	ret != null	1	19	0	public static RenderParameters FromContext ( Context context ) { if ( ret != null ) ; return new RenderParameters { Context = context } ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variables.Count == 2	0.653846153846154	17	9	public override void Render ( Context context , TextWriter result ) { if ( _variables . Count == 2 ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	_variables . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	_to.ToString().Equals("var2")	0.0125	1	79	public override void Render ( Context context , TextWriter result ) { if ( _to . ToString ( ) . Equals ( "var2" ) ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	_to . ToString ( ) . Equals ( "var2" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method != null	1	92	0	public bool RespondTo ( string method ) { if ( method != null ) ; return _methods . ContainsKey ( method ) ; }	method != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tag != null	1	62	0	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( tag != null ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	tag != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	70	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Block.ContentOfVariable != null	1	97	0	public override void Render ( Context context , TextWriter result ) { if ( DotLiquid . Block . ContentOfVariable != null ) ; RenderAll ( NodeList , context , result ) ; }	DotLiquid . Block . ContentOfVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.Drop.CreateTypeResolution(System.Type type)	ret != null	1	81	0	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( ret != null ) ; return new TypeResolution ( type , mi => typeof ( Drop ) . IsAssignableFrom ( mi . DeclaringType . BaseType ) ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	allowedMembers.ToString().All(x => x.Equals("Name"))	0.6	9	6	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) ) ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variableName != null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( _variableName != null ) ; object coll = context [ _collectionName ] ; if ( ! ( coll is IEnumerable ) ) return ; IEnumerable < object > collection = ( ( IEnumerable ) coll ) . Cast < object > ( ) ; if ( _attributes . ContainsKey ( "offset" ) ) { int offset = Convert . ToInt32 ( _attributes [ "offset" ] ) ; collection = collection . Skip ( offset ) ; } if ( _attributes . ContainsKey ( "limit" ) ) { int limit = Convert . ToInt32 ( _attributes [ "limit" ] ) ; collection = collection . Take ( limit ) ; } collection = collection . ToList ( ) ; int length = collection . Count ( ) ; int cols = Convert . ToInt32 ( context [ _attributes [ "cols" ] ] ) ; int row = 1 ; int col = 0 ; result . WriteLine ( "<trclass=\"row1\">" ) ; context . Stack ( ( ) => collection . EachWithIndex ( ( item , index ) => { context [ _variableName ] = item ; context [ "tablerowloop" ] = Hash . FromAnonymousObject ( new { length = length , index = index + 1 , index0 = index , col = col + 1 , col0 = col , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) , col_first = ( col == 0 ) , col_last = ( col == cols - 1 ) } ) ; ++ col ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; result . Write ( "<tdclass=\"col{0}\">{1}</td>" , col , temp . ToString ( ) ) ; } if ( col == cols && index != length - 1 ) { col = 0 ; ++ row ; result . WriteLine ( "</tr>" ) ; result . Write ( "<trclass=\"row{0}\">" , row ) ; } } ) ) ; result . WriteLine ( "</tr>" ) ; }	_variableName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	_regex2.runnerref != null	1	94	0	public string GetMemberName ( string name ) { if ( _regex2 . runnerref != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	_regex2 . runnerref != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Block.FullToken != null	1	97	0	public override void Render ( Context context , TextWriter result ) { if ( DotLiquid . Block . FullToken != null ) ; RenderAll ( NodeList , context , result ) ; }	DotLiquid . Block . FullToken != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	_markup.ToString().Equals(" s ")	0.0103092783505155	1	96	private object RenderInternal ( Context context ) { if ( _markup . ToString ( ) . Equals ( "s" ) ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	_markup . ToString ( ) . Equals ( "s" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variables != null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( _variables != null ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	_variables != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.CallSuper(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	1	0	public void CallSuper ( Context context , TextWriter result ) { if ( context != null ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ; Block parent ; if ( blockState != null && blockState . Parents . TryGetValue ( this , out parent ) && parent != null ) { parent . Render ( context , result ) ; } }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.H(System.String input)	input != null	1	10	0	public static string H ( string input ) { if ( input != null ) ; return Escape ( input ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	_to.ToString().Equals("ptitle")	0.0125	1	79	public override void Render ( Context context , TextWriter result ) { if ( _to . ToString ( ) . Equals ( "ptitle" ) ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	_to . ToString ( ) . Equals ( "ptitle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("cite_funny")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "cite_funny" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "cite_funny" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertTagRulesViolation(System.Collections.Generic.List`1<System.Object> rootNodeList)	_templateName.ToString().Equals("'middle'")	0.274509803921569	14	37	internal override void AssertTagRulesViolation ( List < object > rootNodeList ) { if ( _templateName . ToString ( ) . Equals ( "'middle'" ) ) ; if ( ! ( rootNodeList [ 0 ] is Extends ) ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagMustBeFirstTagException" ) ) ; } NodeList . ForEach ( n => { if ( ! ( ( n is string && ( ( string ) n ) . IsNullOrWhiteSpace ( ) ) || n is Block || n is Comment || n is Extends ) ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagUnallowedTagsException" ) ) ; } ) ; if ( NodeList . Count ( o => o is Extends ) > 0 ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagCanBeUsedOneException" ) ) ; } }	_templateName . ToString ( ) . Equals ( "'middle'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.Drop.CreateTypeResolution(System.Type type)	ret >= 0	0.0123456790123457	1	80	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( ret >= 0 ) ; return new TypeResolution ( type , mi => typeof ( Drop ) . IsAssignableFrom ( mi . DeclaringType . BaseType ) ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	_lambda == null	0.927835051546392	90	7	private object GetValue ( string key ) { if ( _lambda == null ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	_lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tag >= 0	0.0161290322580645	1	61	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( tag >= 0 ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	tag >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variables.All(x => x != null)	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( _variables . All ( x => x != null ) ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	_variables . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name.ToString().Equals("i-(1..2)")	0.0111111111111111	1	89	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name . ToString ( ) . Equals ( "i-(1..2)" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name . ToString ( ) . Equals ( "i-(1..2)" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers)	allowedMembers.ToString().Count == 1	1	15	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers ) { if ( allowedMembers . ToString ( ) . Count == 1 ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers ) ) ; }	allowedMembers . ToString ( ) . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.CallSuper(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	1	0	public void CallSuper ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ; Block parent ; if ( blockState != null && blockState . Parents . TryGetValue ( this , out parent ) && parent != null ) { parent . Render ( context , result ) ; } }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._strings >= ret.capsize	0.0104166666666667	1	95	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _strings >= ret . capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _strings >= ret . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Type[] filters)	filters.Count == 1	1	30	0	public void AddFilters ( params Type [ ] filters ) { if ( filters . Count == 1 ) ; if ( filters != null ) AddFilters ( filters . AsEnumerable ( ) ) ; }	filters . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	name != null	1	94	0	public string GetMemberName ( string name ) { if ( name != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	_childRelation != null	1	11	0	public void Or ( Condition condition ) { if ( _childRelation != null ) ; _childRelation = "or" ; _childCondition = condition ; }	_childRelation != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	80	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variableName.ToString().Equals("n")	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( _variableName . ToString ( ) . Equals ( "n" ) ) ; object coll = context [ _collectionName ] ; if ( ! ( coll is IEnumerable ) ) return ; IEnumerable < object > collection = ( ( IEnumerable ) coll ) . Cast < object > ( ) ; if ( _attributes . ContainsKey ( "offset" ) ) { int offset = Convert . ToInt32 ( _attributes [ "offset" ] ) ; collection = collection . Skip ( offset ) ; } if ( _attributes . ContainsKey ( "limit" ) ) { int limit = Convert . ToInt32 ( _attributes [ "limit" ] ) ; collection = collection . Take ( limit ) ; } collection = collection . ToList ( ) ; int length = collection . Count ( ) ; int cols = Convert . ToInt32 ( context [ _attributes [ "cols" ] ] ) ; int row = 1 ; int col = 0 ; result . WriteLine ( "<trclass=\"row1\">" ) ; context . Stack ( ( ) => collection . EachWithIndex ( ( item , index ) => { context [ _variableName ] = item ; context [ "tablerowloop" ] = Hash . FromAnonymousObject ( new { length = length , index = index + 1 , index0 = index , col = col + 1 , col0 = col , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) , col_first = ( col == 0 ) , col_last = ( col == cols - 1 ) } ) ; ++ col ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; result . Write ( "<tdclass=\"col{0}\">{1}</td>" , col , temp . ToString ( ) ) ; } if ( col == cols && index != length - 1 ) { col = 0 ; ++ row ; result . WriteLine ( "</tr>" ) ; result . Write ( "<trclass=\"row{0}\">" , row ) ; } } ) ) ; result . WriteLine ( "</tr>" ) ; }	_variableName . ToString ( ) . Equals ( "n" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variables.All(x => x >= 0)	0.0384615384615385	1	25	public override void Render ( Context context , TextWriter result ) { if ( _variables . All ( x => x >= 0 ) ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	_variables . All ( x => x >= 0 )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("divided_by")	0.0217391304347826	2	90	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "divided_by" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "divided_by" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Block.IsTag != null	1	97	0	public override void Render ( Context context , TextWriter result ) { if ( DotLiquid . Block . IsTag != null ) ; RenderAll ( NodeList , context , result ) ; }	DotLiquid . Block . IsTag != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup >= 0	0.0142857142857143	1	69	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup >= 0 ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._strings >= ret.code._anchors	0.0104166666666667	1	95	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _strings >= ret . code . _anchors ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _strings >= ret . code . _anchors
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.CallSuper(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	1	0	public void CallSuper ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ; Block parent ; if ( blockState != null && blockState . Parents . TryGetValue ( this , out parent ) && parent != null ) { parent . Render ( context , result ) ; } }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	DotLiquid.Template.NamingConvention != null	1	19	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( DotLiquid . Template . NamingConvention != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertTagRulesViolation(System.Collections.Generic.List`1<System.Object> rootNodeList)	_templateName.ToString().Equals("'nested'")	0.0980392156862745	5	46	internal override void AssertTagRulesViolation ( List < object > rootNodeList ) { if ( _templateName . ToString ( ) . Equals ( "'nested'" ) ) ; if ( ! ( rootNodeList [ 0 ] is Extends ) ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagMustBeFirstTagException" ) ) ; } NodeList . ForEach ( n => { if ( ! ( ( n is string && ( ( string ) n ) . IsNullOrWhiteSpace ( ) ) || n is Block || n is Comment || n is Extends ) ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagUnallowedTagsException" ) ) ; } ) ; if ( NodeList . Count ( o => o is Extends ) > 0 ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagCanBeUsedOneException" ) ) ; } }	_templateName . ToString ( ) . Equals ( "'nested'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	context != null	1	97	0	private object RenderInternal ( Context context ) { if ( context != null ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	context >= 0	0.0125	1	79	public override void Render ( Context context , TextWriter result ) { if ( context >= 0 ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	context >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("strip_newlines")	0.0217391304347826	2	90	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "strip_newlines" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "strip_newlines" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; object coll = context [ _collectionName ] ; if ( ! ( coll is IEnumerable ) ) return ; IEnumerable < object > collection = ( ( IEnumerable ) coll ) . Cast < object > ( ) ; if ( _attributes . ContainsKey ( "offset" ) ) { int offset = Convert . ToInt32 ( _attributes [ "offset" ] ) ; collection = collection . Skip ( offset ) ; } if ( _attributes . ContainsKey ( "limit" ) ) { int limit = Convert . ToInt32 ( _attributes [ "limit" ] ) ; collection = collection . Take ( limit ) ; } collection = collection . ToList ( ) ; int length = collection . Count ( ) ; int cols = Convert . ToInt32 ( context [ _attributes [ "cols" ] ] ) ; int row = 1 ; int col = 0 ; result . WriteLine ( "<trclass=\"row1\">" ) ; context . Stack ( ( ) => collection . EachWithIndex ( ( item , index ) => { context [ _variableName ] = item ; context [ "tablerowloop" ] = Hash . FromAnonymousObject ( new { length = length , index = index + 1 , index0 = index , col = col + 1 , col0 = col , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) , col_first = ( col == 0 ) , col_last = ( col == cols - 1 ) } ) ; ++ col ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; result . Write ( "<tdclass=\"col{0}\">{1}</td>" , col , temp . ToString ( ) ) ; } if ( col == cols && index != length - 1 ) { col = 0 ; ++ row ; result . WriteLine ( "</tr>" ) ; result . Write ( "<trclass=\"row{0}\">" , row ) ; } } ) ) ; result . WriteLine ( "</tr>" ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	name >= 0	0.0106382978723404	1	93	public string GetMemberName ( string name ) { if ( name >= 0 ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	name >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variables.ToString().Count == 2	0.653846153846154	17	9	public override void Render ( Context context , TextWriter result ) { if ( _variables . ToString ( ) . Count == 2 ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	_variables . ToString ( ) . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Block.cs	DotLiquid.Tags.Block.CallSuper(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	1	0	public void CallSuper ( Context context , TextWriter result ) { if ( result != null ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ; Block parent ; if ( blockState != null && blockState . Parents . TryGetValue ( this , out parent ) && parent != null ) { parent . Render ( context , result ) ; } }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	_nestedDictionary != null	1	97	0	private object GetValue ( string key ) { if ( _nestedDictionary != null ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("'doesnotexist' ")	0.0428571428571429	3	67	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "'doesnotexist'" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "'doesnotexist'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tag.ToString().Equals("when")	0.564516129032258	35	27	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( tag . ToString ( ) . Equals ( "when" ) ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	tag . ToString ( ) . Equals ( "when" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_allowedMembers.Count == 1	0.708333333333333	17	7	public virtual object ConvertToValueType ( ) { if ( _allowedMembers . Count == 1 ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_allowedMembers . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name.ToString().Equals("i-array")	0.0111111111111111	1	89	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name . ToString ( ) . Equals ( "i-array" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name . ToString ( ) . Equals ( "i-array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	name >= _regex1.capsize	0.0106382978723404	1	93	public string GetMemberName ( string name ) { if ( name >= _regex1 . capsize ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	name >= _regex1 . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Block.IsVariable != null	1	97	0	public override void Render ( Context context , TextWriter result ) { if ( DotLiquid . Block . IsVariable != null ) ; RenderAll ( NodeList , context , result ) ; }	DotLiquid . Block . IsVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	80	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._strings >= ret.code._capsize	0.0104166666666667	1	95	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _strings >= ret . code . _capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _strings >= ret . code . _capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	name >= _regex1.internalMatchTimeout	0.0106382978723404	1	93	public string GetMemberName ( string name ) { if ( name >= _regex1 . internalMatchTimeout ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	name >= _regex1 . internalMatchTimeout
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	0.8625	69	11	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.H(System.String input)	input.ToString().Equals("<strong>")	1	10	0	public static string H ( string input ) { if ( input . ToString ( ) . Equals ( "<strong>" ) ) ; return Escape ( input ) ; }	input . ToString ( ) . Equals ( "<strong>" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	_childRelation.ToString().Equals("or")	1	11	0	public void Or ( Condition condition ) { if ( _childRelation . ToString ( ) . Equals ( "or" ) ) ; _childRelation = "or" ; _childCondition = condition ; }	_childRelation . ToString ( ) . Equals ( "or" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	DotLiquid.Template.SafeTypeTransformers != null	1	19	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("newline_to_br")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "newline_to_br" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "newline_to_br" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer != null	0.025	2	78	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	context . _strainer != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_allowedMembers.Count == 2	0.291666666666667	7	17	public virtual object ConvertToValueType ( ) { if ( _allowedMembers . Count == 2 ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_allowedMembers . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._strings.All(x => x != null)	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _strings . All ( x => x != null ) ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _strings . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	name >= _regex2.capsize	0.0106382978723404	1	93	public string GetMemberName ( string name ) { if ( name >= _regex2 . capsize ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	name >= _regex2 . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	80	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertTagRulesViolation(System.Collections.Generic.List`1<System.Object> rootNodeList)	_templateName.ToString().Equals("'simple'")	0.117647058823529	6	45	internal override void AssertTagRulesViolation ( List < object > rootNodeList ) { if ( _templateName . ToString ( ) . Equals ( "'simple'" ) ) ; if ( ! ( rootNodeList [ 0 ] is Extends ) ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagMustBeFirstTagException" ) ) ; } NodeList . ForEach ( n => { if ( ! ( ( n is string && ( ( string ) n ) . IsNullOrWhiteSpace ( ) ) || n is Block || n is Comment || n is Extends ) ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagUnallowedTagsException" ) ) ; } ) ; if ( NodeList . Count ( o => o is Extends ) > 0 ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagCanBeUsedOneException" ) ) ; } }	_templateName . ToString ( ) . Equals ( "'simple'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._trackcount >= 0	0.90625	87	9	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _trackcount >= 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _trackcount >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	62	0	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( markup != null ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	name >= _regex2.internalMatchTimeout	0.0106382978723404	1	93	public string GetMemberName ( string name ) { if ( name >= _regex2 . internalMatchTimeout ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	name >= _regex2 . internalMatchTimeout
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	name.ToString().Equals("HelloWorld")	0.0106382978723404	1	93	public string GetMemberName ( string name ) { if ( name . ToString ( ) . Equals ( "HelloWorld" ) ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	name . ToString ( ) . Equals ( "HelloWorld" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	key != null	1	97	0	private object GetValue ( string key ) { if ( key != null ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("hi")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "hi" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "hi" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Type[] filters)	filters != null	0.433333333333333	13	17	public void AddFilters ( params Type [ ] filters ) { if ( filters != null ) ; if ( filters != null ) AddFilters ( filters . AsEnumerable ( ) ) ; }	filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	DotLiquid.Template.ValueTypeTransformers != null	1	19	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context != null	0.1375	11	69	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer . _context != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	context . _strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; object coll = context [ _collectionName ] ; if ( ! ( coll is IEnumerable ) ) return ; IEnumerable < object > collection = ( ( IEnumerable ) coll ) . Cast < object > ( ) ; if ( _attributes . ContainsKey ( "offset" ) ) { int offset = Convert . ToInt32 ( _attributes [ "offset" ] ) ; collection = collection . Skip ( offset ) ; } if ( _attributes . ContainsKey ( "limit" ) ) { int limit = Convert . ToInt32 ( _attributes [ "limit" ] ) ; collection = collection . Take ( limit ) ; } collection = collection . ToList ( ) ; int length = collection . Count ( ) ; int cols = Convert . ToInt32 ( context [ _attributes [ "cols" ] ] ) ; int row = 1 ; int col = 0 ; result . WriteLine ( "<trclass=\"row1\">" ) ; context . Stack ( ( ) => collection . EachWithIndex ( ( item , index ) => { context [ _variableName ] = item ; context [ "tablerowloop" ] = Hash . FromAnonymousObject ( new { length = length , index = index + 1 , index0 = index , col = col + 1 , col0 = col , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) , col_first = ( col == 0 ) , col_last = ( col == cols - 1 ) } ) ; ++ col ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; result . Write ( "<tdclass=\"col{0}\">{1}</td>" , col , temp . ToString ( ) ) ; } if ( col == cols && index != length - 1 ) { col = 0 ; ++ row ; result . WriteLine ( "</tr>" ) ; result . Write ( "<trclass=\"row{0}\">" , row ) ; } } ) ) ; result . WriteLine ( "</tr>" ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_allowedMembers != null	0.375	9	15	public virtual object ConvertToValueType ( ) { if ( _allowedMembers != null ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_allowedMembers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	ret != null	1	94	0	public string GetMemberName ( string name ) { if ( ret != null ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._trackcount >= 32	0.104166666666667	10	86	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _trackcount >= 32 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _trackcount >= 32
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("notthere ")	0.1	7	63	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "notthere" ) ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	markup . ToString ( ) . Equals ( "notthere" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	context >= 0	0.0103092783505155	1	96	private object RenderInternal ( Context context ) { if ( context >= 0 ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	context >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup >= 0	0.0161290322580645	1	61	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( markup >= 0 ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	markup >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	97	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; RenderAll ( NodeList , context , result ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.H(System.String input)	ret != null	1	10	0	public static string H ( string input ) { if ( ret != null ) ; return Escape ( input ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\NamingConventions\RubyNamingConvention.cs	DotLiquid.NamingConventions.RubyNamingConvention.GetMemberName(System.String name)	ret.ToString().Equals("hello_world")	0.0106382978723404	1	93	public string GetMemberName ( string name ) { if ( ret . ToString ( ) . Equals ( "hello_world" ) ) ; return _regex2 . Replace ( _regex1 . Replace ( name , "$1_$2" ) , "$1_$2" ) . ToLower ( ) ; }	ret . ToString ( ) . Equals ( "hello_world" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	ret != null	0.0309278350515464	3	94	private object GetValue ( string key ) { if ( ret != null ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	type != null	1	19	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( type != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	type != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name.ToString().Equals("i-choices")	0.0333333333333333	3	87	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name . ToString ( ) . Equals ( "i-choices" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name . ToString ( ) . Equals ( "i-choices" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertTagRulesViolation(System.Collections.Generic.List`1<System.Object> rootNodeList)	_templateName.ToString().Equals("'middleunless'")	0.0588235294117647	3	48	internal override void AssertTagRulesViolation ( List < object > rootNodeList ) { if ( _templateName . ToString ( ) . Equals ( "'middleunless'" ) ) ; if ( ! ( rootNodeList [ 0 ] is Extends ) ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagMustBeFirstTagException" ) ) ; } NodeList . ForEach ( n => { if ( ! ( ( n is string && ( ( string ) n ) . IsNullOrWhiteSpace ( ) ) || n is Block || n is Comment || n is Extends ) ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagUnallowedTagsException" ) ) ; } ) ; if ( NodeList . Count ( o => o is Extends ) > 0 ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagCanBeUsedOneException" ) ) ; } }	_templateName . ToString ( ) . Equals ( "'middleunless'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context.Equals(context)	0.1375	11	69	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer . _context . Equals ( context ) ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	context . _strainer . _context . Equals ( context )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._trackcount >= ret.capsize	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _trackcount >= ret . capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _trackcount >= ret . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("add_tag")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "add_tag" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "add_tag" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_allowedMembers.All(x => x != null)	1	24	0	public virtual object ConvertToValueType ( ) { if ( _allowedMembers . All ( x => x != null ) ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_allowedMembers . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._methods != null	0.1375	11	69	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer . _methods != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	context . _strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	condition != null	1	11	0	public void Or ( Condition condition ) { if ( condition != null ) ; _childRelation = "or" ; _childCondition = condition ; }	condition != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; object coll = context [ _collectionName ] ; if ( ! ( coll is IEnumerable ) ) return ; IEnumerable < object > collection = ( ( IEnumerable ) coll ) . Cast < object > ( ) ; if ( _attributes . ContainsKey ( "offset" ) ) { int offset = Convert . ToInt32 ( _attributes [ "offset" ] ) ; collection = collection . Skip ( offset ) ; } if ( _attributes . ContainsKey ( "limit" ) ) { int limit = Convert . ToInt32 ( _attributes [ "limit" ] ) ; collection = collection . Take ( limit ) ; } collection = collection . ToList ( ) ; int length = collection . Count ( ) ; int cols = Convert . ToInt32 ( context [ _attributes [ "cols" ] ] ) ; int row = 1 ; int col = 0 ; result . WriteLine ( "<trclass=\"row1\">" ) ; context . Stack ( ( ) => collection . EachWithIndex ( ( item , index ) => { context [ _variableName ] = item ; context [ "tablerowloop" ] = Hash . FromAnonymousObject ( new { length = length , index = index + 1 , index0 = index , col = col + 1 , col0 = col , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) , col_first = ( col == 0 ) , col_last = ( col == cols - 1 ) } ) ; ++ col ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; result . Write ( "<tdclass=\"col{0}\">{1}</td>" , col , temp . ToString ( ) ) ; } if ( col == cols && index != length - 1 ) { col = 0 ; ++ row ; result . WriteLine ( "</tr>" ) ; result . Write ( "<trclass=\"row{0}\">" , row ) ; } } ) ) ; result . WriteLine ( "</tr>" ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	0.961538461538462	25	1	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._trackcount >= ret.code._anchors	0.90625	87	9	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _trackcount >= ret . code . _anchors ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _trackcount >= ret . code . _anchors
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	allowedMembers.Count == 1	0.631578947368421	12	7	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( allowedMembers . Count == 1 ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	allowedMembers . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup.ToString().Equals("")	0.0967741935483871	6	56	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( markup . ToString ( ) . Equals ( "" ) ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	markup . ToString ( ) . Equals ( "" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	ret == 1	0.0824742268041237	8	89	private object GetValue ( string key ) { if ( ret == 1 ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("replace_first")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "replace_first" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "replace_first" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Assign.cs	DotLiquid.Tags.Assign.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Strainer.Filters != null	0.1375	11	69	public override void Render ( Context context , TextWriter result ) { if ( DotLiquid . Strainer . Filters != null ) ; context . Scopes . Last ( ) [ _to ] = _from . Render ( context ) ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	70	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; Match syntaxMatch = Syntax . Match ( markup ) ; if ( syntaxMatch . Success ) { _templateName = syntaxMatch . Groups [ 1 ] . Value ; _variableName = syntaxMatch . Groups [ 3 ] . Value ; if ( _variableName == string . Empty ) _variableName = null ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else throw new SyntaxException ( Liquid . ResourceManager . GetString ( "IncludeTagSyntaxException" ) ) ; base . Initialize ( tagName , markup , tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._trackcount >= ret.code._capsize	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _trackcount >= ret . code . _capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _trackcount >= ret . code . _capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertTagRulesViolation(System.Collections.Generic.List`1<System.Object> rootNodeList)	rootNodeList != null	1	51	0	internal override void AssertTagRulesViolation ( List < object > rootNodeList ) { if ( rootNodeList != null ) ; if ( ! ( rootNodeList [ 0 ] is Extends ) ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagMustBeFirstTagException" ) ) ; } NodeList . ForEach ( n => { if ( ! ( ( n is string && ( ( string ) n ) . IsNullOrWhiteSpace ( ) ) || n is Block || n is Comment || n is Extends ) ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagUnallowedTagsException" ) ) ; } ) ; if ( NodeList . Count ( o => o is Extends ) > 0 ) { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ExtendsTagCanBeUsedOneException" ) ) ; } }	rootNodeList != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Cycle.cs	DotLiquid.Tags.Cycle.Render(DotLiquid.Context context, System.IO.TextWriter result)	result >= 0	0.0384615384615385	1	25	public override void Render ( Context context , TextWriter result ) { if ( result >= 0 ) ; context . Registers [ "cycle" ] = context . Registers [ "cycle" ] ?? new Hash ( 0 ) ; context . Stack ( ( ) => { string key = context [ _name ] . ToString ( ) ; int iteration = ( int ) ( ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] ?? 0 ) ; result . Write ( context [ _variables [ iteration ] ] . ToString ( ) ) ; ++ iteration ; if ( iteration >= _variables . Length ) iteration = 0 ; ( ( Hash ) context . Registers [ "cycle" ] ) [ key ] = iteration ; } ) ; }	result >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_allowedMembers.ToString().All(x => x.Equals("Name"))	0.458333333333333	11	13	public virtual object ConvertToValueType ( ) { if ( _allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) ) ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context >= 0	0.0103092783505155	1	96	public override void Render ( Context context , TextWriter result ) { if ( context >= 0 ) ; RenderAll ( NodeList , context , result ) ; }	context >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.code._trackcount <= ret.code._strings	0.0104166666666667	1	95	public static Regex B ( string format , params string [ ] args ) { if ( ret . code . _trackcount <= ret . code . _strings ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . code . _trackcount <= ret . code . _strings
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	context._rethrowErrors == false	0.907216494845361	88	9	private object RenderInternal ( Context context ) { if ( context . _rethrowErrors == false ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	62	0	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( tokens != null ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("make_funny")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "make_funny" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "make_funny" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.factory == null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . factory == null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . factory == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	ret == 0	0.0103092783505155	1	96	private object GetValue ( string key ) { if ( ret == 0 ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	ret == 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	allowedMembers.Count == 2	0.368421052631579	7	12	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( allowedMembers . Count == 2 ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	allowedMembers . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Html\TableRow.cs	DotLiquid.Tags.Html.TableRow.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	26	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; object coll = context [ _collectionName ] ; if ( ! ( coll is IEnumerable ) ) return ; IEnumerable < object > collection = ( ( IEnumerable ) coll ) . Cast < object > ( ) ; if ( _attributes . ContainsKey ( "offset" ) ) { int offset = Convert . ToInt32 ( _attributes [ "offset" ] ) ; collection = collection . Skip ( offset ) ; } if ( _attributes . ContainsKey ( "limit" ) ) { int limit = Convert . ToInt32 ( _attributes [ "limit" ] ) ; collection = collection . Take ( limit ) ; } collection = collection . ToList ( ) ; int length = collection . Count ( ) ; int cols = Convert . ToInt32 ( context [ _attributes [ "cols" ] ] ) ; int row = 1 ; int col = 0 ; result . WriteLine ( "<trclass=\"row1\">" ) ; context . Stack ( ( ) => collection . EachWithIndex ( ( item , index ) => { context [ _variableName ] = item ; context [ "tablerowloop" ] = Hash . FromAnonymousObject ( new { length = length , index = index + 1 , index0 = index , col = col + 1 , col0 = col , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) , col_first = ( col == 0 ) , col_last = ( col == cols - 1 ) } ) ; ++ col ; using ( TextWriter temp = new StringWriter ( ) ) { RenderAll ( NodeList , context , temp ) ; result . Write ( "<tdclass=\"col{0}\">{1}</td>" , col , temp . ToString ( ) ) ; } if ( col == cols && index != length - 1 ) { col = 0 ; ++ row ; result . WriteLine ( "</tr>" ) ; result . Write ( "<trclass=\"row{0}\">" , row ) ; } } ) ) ; result . WriteLine ( "</tr>" ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_attributes != null	1	70	0	protected override void Parse ( List < string > tokens ) { if ( _attributes != null ) ; }	_attributes != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_allowedMembers.ToString().All(x => x.Equals("ToString"))	0.208333333333333	5	19	public virtual object ConvertToValueType ( ) { if ( _allowedMembers . ToString ( ) . All ( x => x . Equals ( "ToString" ) ) ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_allowedMembers . ToString ( ) . All ( x => x . Equals ( "ToString" ) )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.internalMatchTimeout >= 0	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . internalMatchTimeout >= 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . internalMatchTimeout >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.H(System.String input)	ret.ToString().Equals("&lt;strong&gt;")	1	10	0	public static string H ( string input ) { if ( ret . ToString ( ) . Equals ( "&lt;strong&gt;" ) ) ; return Escape ( input ) ; }	ret . ToString ( ) . Equals ( "&lt;strong&gt;" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.UnknownTag(System.String tag, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	exception != null	0.112903225806452	7	55	public override void UnknownTag ( string tag , string markup , List < string > tokens ) { if ( exception != null ) ; NodeList = new List < object > ( ) ; switch ( tag ) { case "when" : RecordWhenCondition ( markup ) ; break ; case "else" : RecordElseCondition ( markup ) ; break ; default : base . UnknownTag ( tag , markup , tokens ) ; break ; } }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.internalMatchTimeout >= ret.capsize	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . internalMatchTimeout >= ret . capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . internalMatchTimeout >= ret . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.AddFilters(System.Type[] filters)	filters.All(x => x != null)	1	30	0	public void AddFilters ( params Type [ ] filters ) { if ( filters . All ( x => x != null ) ) ; if ( filters != null ) AddFilters ( filters . AsEnumerable ( ) ) ; }	filters . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertMissingDelimitation()	_templateName != null	1	51	0	protected override void AssertMissingDelimitation ( ) { if ( _templateName != null ) ; }	_templateName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.internalMatchTimeout >= ret.code._anchors	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . internalMatchTimeout >= ret . code . _anchors ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . internalMatchTimeout >= ret . code . _anchors
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("money")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "money" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "money" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	allowedMembers.All(x => x != null)	1	19	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( allowedMembers . All ( x => x != null ) ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	allowedMembers . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	condition.Equals(_childCondition)	1	11	0	public void Or ( Condition condition ) { if ( condition . Equals ( _childCondition ) ) ; _childRelation = "or" ; _childCondition = condition ; }	condition . Equals ( _childCondition )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name.ToString().Equals("i-array.items")	0.0222222222222222	2	88	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name . ToString ( ) . Equals ( "i-array.items" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name . ToString ( ) . Equals ( "i-array.items" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_attributes >= 0	0.0142857142857143	1	69	protected override void Parse ( List < string > tokens ) { if ( _attributes >= 0 ) ; }	_attributes >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	ret >= 0	0.371134020618557	36	61	private object GetValue ( string key ) { if ( ret >= 0 ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.internalMatchTimeout >= ret.code._capsize	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . internalMatchTimeout >= ret . code . _capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . internalMatchTimeout >= ret . code . _capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_allowedMembers.ToString().Count == 1	0.708333333333333	17	7	public virtual object ConvertToValueType ( ) { if ( _allowedMembers . ToString ( ) . Count == 1 ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_allowedMembers . ToString ( ) . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	_blocks != null	1	56	0	public override void Render ( Context context , TextWriter result ) { if ( _blocks != null ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	_blocks != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	0.762886597938144	74	23	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; RenderAll ( NodeList , context , result ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.internalMatchTimeout >= ret.code._trackcount	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . internalMatchTimeout >= ret . code . _trackcount ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . internalMatchTimeout >= ret . code . _trackcount
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	context._strainer == null	0.309278350515464	30	67	private object RenderInternal ( Context context ) { if ( context . _strainer == null ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.internalMatchTimeout <= ret.code._strings	0.0104166666666667	1	95	public static Regex B ( string format , params string [ ] args ) { if ( ret . internalMatchTimeout <= ret . code . _strings ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . internalMatchTimeout <= ret . code . _strings
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName != null	1	70	0	protected override void Parse ( List < string > tokens ) { if ( _templateName != null ) ; }	_templateName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertMissingDelimitation()	_templateName.ToString().Equals("'complex'")	0.274509803921569	14	37	protected override void AssertMissingDelimitation ( ) { if ( _templateName . ToString ( ) . Equals ( "'complex'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'complex'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("times")	0.0217391304347826	2	90	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "times" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "times" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.pattern != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . pattern != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . pattern != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	_left != null	1	56	0	public override void Render ( Context context , TextWriter result ) { if ( _left != null ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	_left != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	allowedMembers.ToString().All(x => x.Equals("Name"))	0.631578947368421	12	7	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) ) ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_allowedMembers.ToString().Count == 2	0.291666666666667	7	17	public virtual object ConvertToValueType ( ) { if ( _allowedMembers . ToString ( ) . Count == 2 ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_allowedMembers . ToString ( ) . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	ret >= 1	0.494845360824742	48	49	private object GetValue ( string key ) { if ( ret >= 1 ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.refsInitialized == true	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . refsInitialized == true ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . refsInitialized == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName >= 0	0.0142857142857143	1	69	protected override void Parse ( List < string > tokens ) { if ( _templateName >= 0 ) ; }	_templateName >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	_left.ToString().Equals("a.size")	0.196428571428571	11	45	public override void Render ( Context context , TextWriter result ) { if ( _left . ToString ( ) . Equals ( "a.size" ) ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	_left . ToString ( ) . Equals ( "a.size" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.replref != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . replref != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . replref != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	0.309278350515464	30	67	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; RenderAll ( NodeList , context , result ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("date")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "date" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "date" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.replref._locked == 0	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . replref . _locked == 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . replref . _locked == 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_proxiedObject != null	1	24	0	public virtual object ConvertToValueType ( ) { if ( _proxiedObject != null ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_proxiedObject != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	allowedMembers.ToString().Count == 1	0.631578947368421	12	7	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( allowedMembers . ToString ( ) . Count == 1 ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	allowedMembers . ToString ( ) . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.replref._locked <= ret.capsize	0.739583333333333	71	25	public static Regex B ( string format , params string [ ] args ) { if ( ret . replref . _locked <= ret . capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . replref . _locked <= ret . capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	ret != null	0.474226804123711	46	51	private object RenderInternal ( Context context ) { if ( ret != null ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	_left.ToString().Equals("condition")	0.392857142857143	22	34	public override void Render ( Context context , TextWriter result ) { if ( _left . ToString ( ) . Equals ( "condition" ) ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	_left . ToString ( ) . Equals ( "condition" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertMissingDelimitation()	_templateName.ToString().Equals("'middle'")	0.274509803921569	14	37	protected override void AssertMissingDelimitation ( ) { if ( _templateName . ToString ( ) . Equals ( "'middle'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'middle'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	ret <= 1	0.0927835051546392	9	88	private object GetValue ( string key ) { if ( ret <= 1 ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.replref._locked <= ret.code._capsize	0.739583333333333	71	25	public static Regex B ( string format , params string [ ] args ) { if ( ret . replref . _locked <= ret . code . _capsize ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . replref . _locked <= ret . code . _capsize
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("modulo")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "modulo" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "modulo" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.replref._locked <= ret.internalMatchTimeout	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . replref . _locked <= ret . internalMatchTimeout ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . replref . _locked <= ret . internalMatchTimeout
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'doesnotexist'")	0.0428571428571429	3	67	protected override void Parse ( List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'doesnotexist'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'doesnotexist'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_value != null	0.75	18	6	public virtual object ConvertToValueType ( ) { if ( _value != null ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_value != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	_left.ToString().Equals("collection.handle")	0.0535714285714286	3	53	public override void Render ( Context context , TextWriter result ) { if ( _left . ToString ( ) . Equals ( "collection.handle" ) ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	_left . ToString ( ) . Equals ( "collection.handle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	condition._childCondition == null	1	11	0	public void Or ( Condition condition ) { if ( condition . _childCondition == null ) ; _childRelation = "or" ; _childCondition = condition ; }	condition . _childCondition == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	97	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; RenderAll ( NodeList , context , result ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	ret <= 0	0.0103092783505155	1	96	private object GetValue ( string key ) { if ( ret <= 0 ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	ret <= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	allowedMembers.ToString().Count == 2	0.368421052631579	7	12	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( allowedMembers . ToString ( ) . Count == 2 ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	allowedMembers . ToString ( ) . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name.ToString().Equals("text-product.texts.array")	0.0111111111111111	1	89	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name . ToString ( ) . Equals ( "text-product.texts.array" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name . ToString ( ) . Equals ( "text-product.texts.array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	ret == 1	0.0515463917525773	5	92	private object RenderInternal ( Context context ) { if ( ret == 1 ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("notthere")	0.1	7	63	protected override void Parse ( List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "notthere" ) ) ; }	_templateName . ToString ( ) . Equals ( "notthere" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("split")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "split" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "split" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.replref._ref != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . replref . _ref != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . replref . _ref != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Truncate(System.String input, System.Int32 length, System.String truncateString)	input != null	1	10	0	public static string Truncate ( string input , int length , string truncateString ) { if ( input != null ) ; else public static string Truncate ( string input , int length = 50 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; int l = length - truncateString . Length ; return input . Length > length ? input . Substring ( 0 , l < 0 ? 0 : l ) + truncateString : input ; } }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertMissingDelimitation()	_templateName.ToString().Equals("'nested'")	0.0980392156862745	5	46	protected override void AssertMissingDelimitation ( ) { if ( _templateName . ToString ( ) . Equals ( "'nested'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'nested'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	_value == null	0.208333333333333	5	19	public virtual object ConvertToValueType ( ) { if ( _value == null ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	_value == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_rethrowErrors == false	1	92	0	public object Invoke ( string method , List < object > args ) { if ( _rethrowErrors == false ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	56	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.String[] allowedMembers, System.Func`2<System.Object, System.Object> func)	func != null	1	19	0	public static void RegisterSafeType ( Type type , string [ ] allowedMembers , Func < object , object > func ) { if ( func != null ) ; RegisterSafeType ( type , x => new DropProxy ( x , allowedMembers , func ) ) ; }	func != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	exception != null	0.649484536082474	63	34	public override void Render ( Context context , TextWriter result ) { if ( exception != null ) ; RenderAll ( NodeList , context , result ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	ret != null	0.75	18	6	public virtual object ConvertToValueType ( ) { if ( ret != null ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.roptions != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . roptions != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . roptions != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'loop'")	0.0857142857142857	6	64	protected override void Parse ( List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'loop'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'loop'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.ConvertToValueType()	ret == null	0.208333333333333	5	19	public virtual object ConvertToValueType ( ) { if ( ret == null ) ; if ( _value == null ) return null ; return _value ( _proxiedObject ) ; }	ret == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.runnerref != null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . runnerref != null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . runnerref != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	56	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("remove")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "remove" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "remove" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.Func`2<System.Object, System.Object> func)	DotLiquid.Template.NamingConvention != null	1	56	0	public static void RegisterSafeType ( Type type , Func < object , object > func ) { if ( DotLiquid . Template . NamingConvention != null ) ; SafeTypeTransformers [ type ] = func ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.runnerref._locked == 0	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . runnerref . _locked == 0 ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . runnerref . _locked == 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertMissingDelimitation()	_templateName.ToString().Equals("'simple'")	0.117647058823529	6	45	protected override void AssertMissingDelimitation ( ) { if ( _templateName . ToString ( ) . Equals ( "'simple'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'simple'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	ret >= 1	0.567010309278351	55	42	private object RenderInternal ( Context context ) { if ( ret >= 1 ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_allowedMembers.Count == 1	0.844444444444444	38	7	internal override object GetObject ( ) { if ( _allowedMembers . Count == 1 ) ; return _proxiedObject ; }	_allowedMembers . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.runnerref._locked <= ret.internalMatchTimeout	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . runnerref . _locked <= ret . internalMatchTimeout ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . runnerref . _locked <= ret . internalMatchTimeout
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	56	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'locale_variables'")	0.142857142857143	10	60	protected override void Parse ( List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'locale_variables'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'locale_variables'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	method.ToString().Equals("add_smiley")	0.0108695652173913	1	91	public bool RespondTo ( string method ) { if ( method . ToString ( ) . Equals ( "add_smiley" ) ) ; return _methods . ContainsKey ( method ) ; }	method . ToString ( ) . Equals ( "add_smiley" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.runnerref._obj == null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . runnerref . _obj == null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . runnerref . _obj == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.Func`2<System.Object, System.Object> func)	DotLiquid.Template.SafeTypeTransformers != null	1	56	0	public static void RegisterSafeType ( Type type , Func < object , object > func ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; SafeTypeTransformers [ type ] = func ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context != null	0.690721649484536	67	30	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer . _context != null ) ; RenderAll ( NodeList , context , result ) ; }	context . _strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.B(System.String format, System.String[] args)	ret.runnerref._ref == null	1	96	0	public static Regex B ( string format , params string [ ] args ) { if ( ret . runnerref . _ref == null ) ; string pattern = string . Format ( format , args ) ; return new Regex ( pattern ) ; }	ret . runnerref . _ref == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Or(DotLiquid.Condition condition)	condition._childRelation == null	1	11	0	public void Or ( Condition condition ) { if ( condition . _childRelation == null ) ; _childRelation = "or" ; _childCondition = condition ; }	condition . _childRelation == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	56	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_allowedMembers.Count == 2	0.0888888888888889	4	41	internal override object GetObject ( ) { if ( _allowedMembers . Count == 2 ) ; return _proxiedObject ; }	_allowedMembers . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	ret == true	0.652173913043478	60	32	public bool RespondTo ( string method ) { if ( ret == true ) ; return _methods . ContainsKey ( method ) ; }	ret == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern)	input != null	1	97	0	public static List < string > Scan ( string input , string pattern ) { if ( input != null ) ; return Regex . Matches ( input , pattern ) . Cast < Match > ( ) . Select ( m => ( m . Groups . Count == 2 ) ? m . Groups [ 1 ] . Value : m . Value ) . ToList ( ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'product'")	0.128571428571429	9	61	protected override void Parse ( List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'product'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'product'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	ret >= 0	0.350515463917526	34	63	private object RenderInternal ( Context context ) { if ( ret >= 0 ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern)	pattern != null	1	97	0	public static List < string > Scan ( string input , string pattern ) { if ( pattern != null ) ; return Regex . Matches ( input , pattern ) . Cast < Match > ( ) . Select ( m => ( m . Groups . Count == 2 ) ? m . Groups [ 1 ] . Value : m . Value ) . ToList ( ) ; }	pattern != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.Func`2<System.Object, System.Object> func)	DotLiquid.Template.ValueTypeTransformers != null	1	56	0	public static void RegisterSafeType ( Type type , Func < object , object > func ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; SafeTypeTransformers [ type ] = func ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	ret >= _defaultValue	0.0412371134020619	4	93	private object GetValue ( string key ) { if ( ret >= _defaultValue ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	ret >= _defaultValue
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name.ToString().Equals("item-authors")	0.0111111111111111	1	89	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name . ToString ( ) . Equals ( "item-authors" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name . ToString ( ) . Equals ( "item-authors" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.Render(DotLiquid.Context context, System.IO.TextWriter result)	result >= 0	0.0178571428571429	1	55	public override void Render ( Context context , TextWriter result ) { if ( result >= 0 ) ; context . Stack ( ( ) => { bool executeElseBlock = true ; _blocks . ForEach ( block => { if ( block . IsElse ) { if ( executeElseBlock ) { RenderAll ( block . Attachment , context , result ) ; return ; } } else if ( block . Evaluate ( context ) ) { executeElseBlock = false ; RenderAll ( block . Attachment , context , result ) ; } } ) ; } ) ; }	result >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.RespondTo(System.String method)	ret == false	0.0652173913043478	6	86	public bool RespondTo ( string method ) { if ( ret == false ) ; return _methods . ContainsKey ( method ) ; }	ret == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.AssertMissingDelimitation()	_templateName.ToString().Equals("'middleunless'")	0.0588235294117647	3	48	protected override void AssertMissingDelimitation ( ) { if ( _templateName . ToString ( ) . Equals ( "'middleunless'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'middleunless'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern)	pattern.ToString().Equals("(?-mix:\\[[^\\]]+\\]|(?-mix:[\\w\\-])+\\??)")	0.185567010309278	18	79	public static List < string > Scan ( string input , string pattern ) { if ( pattern . ToString ( ) . Equals ( "(?-mix:\\[[^\\]]+\\]|(?-mix:[\\w\\-])+\\??)" ) ) ; return Regex . Matches ( input , pattern ) . Cast < Match > ( ) . Select ( m => ( m . Groups . Count == 2 ) ? m . Groups [ 1 ] . Value : m . Value ) . ToList ( ) ; }	pattern . ToString ( ) . Equals ( "(?-mix:\\[[^\\]]+\\]|(?-mix:[\\w\\-])+\\??)" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'body'")	0.0285714285714286	2	68	protected override void Parse ( List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'body'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'body'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	DotLiquid.Condition.Operators != null	1	6	0	public void And ( Condition condition ) { if ( DotLiquid . Condition . Operators != null ) ; _childRelation = "and" ; _childCondition = condition ; }	DotLiquid . Condition . Operators != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern)	ret != null	1	97	0	public static List < string > Scan ( string input , string pattern ) { if ( ret != null ) ; return Regex . Matches ( input , pattern ) . Cast < Match > ( ) . Select ( m => ( m . Groups . Count == 2 ) ? m . Groups [ 1 ] . Value : m . Value ) . ToList ( ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_allowedMembers != null	1	45	0	internal override object GetObject ( ) { if ( _allowedMembers != null ) ; return _proxiedObject ; }	_allowedMembers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern)	ret >= 0	0.0103092783505155	1	96	public static List < string > Scan ( string input , string pattern ) { if ( ret >= 0 ) ; return Regex . Matches ( input , pattern ) . Cast < Match > ( ) . Select ( m => ( m . Groups . Count == 2 ) ? m . Groups [ 1 ] . Value : m . Value ) . ToList ( ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.Func`2<System.Object, System.Object> func)	type != null	1	56	0	public static void RegisterSafeType ( Type type , Func < object , object > func ) { if ( type != null ) ; SafeTypeTransformers [ type ] = func ; }	type != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context.Equals(context)	0.690721649484536	67	30	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer . _context . Equals ( context ) ) ; RenderAll ( NodeList , context , result ) ; }	context . _strainer . _context . Equals ( context )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.GetValue(System.String key)	exception != null	0.0515463917525773	5	92	private object GetValue ( string key ) { if ( exception != null ) ; if ( _nestedDictionary . ContainsKey ( key ) ) return _nestedDictionary [ key ] ; if ( _lambda != null ) return _lambda ( this , key ) ; if ( _defaultValue != null ) return _defaultValue ; return null ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	ret <= 1	0.0618556701030928	6	91	private object RenderInternal ( Context context ) { if ( ret <= 1 ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	DotLiquid.Strainer.Filters != null	1	86	0	public object Invoke ( string method , List < object > args ) { if ( DotLiquid . Strainer . Filters != null ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("'pick_a_source'")	0.0428571428571429	3	67	protected override void Parse ( List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "'pick_a_source'" ) ) ; }	_templateName . ToString ( ) . Equals ( "'pick_a_source'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_allowedMembers.All(x => x != null)	0.844444444444444	38	7	internal override object GetObject ( ) { if ( _allowedMembers . All ( x => x != null ) ) ; return _proxiedObject ; }	_allowedMembers . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	input != null	1	95	0	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( input != null ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	_blocks != null	1	62	0	private void RecordWhenCondition ( string markup ) { if ( _blocks != null ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	_blocks != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterSafeType(System.Type type, System.Func`2<System.Object, System.Object> func)	func != null	1	56	0	public static void RegisterSafeType ( Type type , Func < object , object > func ) { if ( func != null ) ; SafeTypeTransformers [ type ] = func ; }	func != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Truncate(System.String input, System.Int32 length, System.String truncateString)	input.ToString().Equals("1234567890")	1	10	0	public static string Truncate ( string input , int length , string truncateString ) { if ( input . ToString ( ) . Equals ( "1234567890" ) ) ; else public static string Truncate ( string input , int length = 50 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; int l = length - truncateString . Length ; return input . Length > length ? input . Substring ( 0 , l < 0 ? 0 : l ) + truncateString : input ; } }	input . ToString ( ) . Equals ( "1234567890" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName != null	1	51	0	public override void Render ( Context context , TextWriter result ) { if ( _templateName != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	input >= 0	0.0105263157894737	1	94	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( input >= 0 ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	input >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_context != null	1	86	0	public object Invoke ( string method , List < object > args ) { if ( _context != null ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	_context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	input.ToString().Equals("n in numbers cols:3")	0.0210526315789474	2	93	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( input . ToString ( ) . Equals ( "ninnumberscols:3" ) ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	input . ToString ( ) . Equals ( "ninnumberscols:3" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterValueTypeTransformer(System.Type type, System.Func`2<System.Object, System.Object> func)	DotLiquid.Template.NamingConvention != null	1	17	0	public static void RegisterValueTypeTransformer ( Type type , Func < object , object > func ) { if ( DotLiquid . Template . NamingConvention != null ) ; ValueTypeTransformers [ type ] = func ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_templateName.ToString().Equals("template")	0.0142857142857143	1	69	protected override void Parse ( List < string > tokens ) { if ( _templateName . ToString ( ) . Equals ( "template" ) ) ; }	_templateName . ToString ( ) . Equals ( "template" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_allowedMembers.ToString().All(x => x.Equals("Name"))	0.733333333333333	33	12	internal override object GetObject ( ) { if ( _allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) ) ) ; return _proxiedObject ; }	_allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	input.ToString().Equals("'loop' ")	0.0105263157894737	1	94	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( input . ToString ( ) . Equals ( "'loop'" ) ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	input . ToString ( ) . Equals ( "'loop'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	_left != null	1	62	0	private void RecordWhenCondition ( string markup ) { if ( _left != null ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	_left != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	input.ToString().Equals("item in array")	0.0105263157894737	1	94	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( input . ToString ( ) . Equals ( "iteminarray" ) ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	input . ToString ( ) . Equals ( "iteminarray" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterValueTypeTransformer(System.Type type, System.Func`2<System.Object, System.Object> func)	DotLiquid.Template.SafeTypeTransformers != null	1	17	0	public static void RegisterValueTypeTransformer ( Type type , Func < object , object > func ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; ValueTypeTransformers [ type ] = func ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_context._rethrowErrors == false	1	86	0	public object Invoke ( string method , List < object > args ) { if ( _context . _rethrowErrors == false ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	_context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._methods != null	0.690721649484536	67	30	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer . _methods != null ) ; RenderAll ( NodeList , context , result ) ; }	context . _strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_variableName == null	0.671428571428571	47	23	protected override void Parse ( List < string > tokens ) { if ( _variableName == null ) ; }	_variableName == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_allowedMembers.ToString().Count == 1	0.844444444444444	38	7	internal override object GetObject ( ) { if ( _allowedMembers . ToString ( ) . Count == 1 ) ; return _proxiedObject ; }	_allowedMembers . ToString ( ) . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	input.ToString().Equals("a in dummy ")	0.0105263157894737	1	94	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( input . ToString ( ) . Equals ( "aindummy" ) ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	input . ToString ( ) . Equals ( "aindummy" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name.ToString().Equals("item-tasks")	0.0111111111111111	1	89	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name . ToString ( ) . Equals ( "item-tasks" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name . ToString ( ) . Equals ( "item-tasks" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'complex'")	0.274509803921569	14	37	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'complex'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'complex'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	pattern != null	1	95	0	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( pattern != null ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	pattern != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	ret <= _markup	0.0206185567010309	2	95	private object RenderInternal ( Context context ) { if ( ret <= _markup ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	ret <= _markup
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterValueTypeTransformer(System.Type type, System.Func`2<System.Object, System.Object> func)	DotLiquid.Template.ValueTypeTransformers != null	1	17	0	public static void RegisterValueTypeTransformer ( Type type , Func < object , object > func ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; ValueTypeTransformers [ type ] = func ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_strainer != null	1	92	0	public object Invoke ( string method , List < object > args ) { if ( _strainer != null ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	_strainer != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	_left.ToString().Equals("a.size")	0.258064516129032	16	46	private void RecordWhenCondition ( string markup ) { if ( _left . ToString ( ) . Equals ( "a.size" ) ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	_left . ToString ( ) . Equals ( "a.size" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	_childCondition != null	1	6	0	public void And ( Condition condition ) { if ( _childCondition != null ) ; _childRelation = "and" ; _childCondition = condition ; }	_childCondition != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_context._strainer != null	1	86	0	public object Invoke ( string method , List < object > args ) { if ( _context . _strainer != null ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	_context . _strainer != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.Render(DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Strainer.Filters != null	0.690721649484536	67	30	public override void Render ( Context context , TextWriter result ) { if ( DotLiquid . Strainer . Filters != null ) ; RenderAll ( NodeList , context , result ) ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Get(System.String key)	_defaultValue == null	1	83	0	public T Get < T > ( string key ) { if ( _defaultValue == null ) ; return ( T ) this [ key ] ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_allowedMembers.ToString().Count == 2	0.0888888888888889	4	41	internal override object GetObject ( ) { if ( _allowedMembers . ToString ( ) . Count == 2 ) ; return _proxiedObject ; }	_allowedMembers . ToString ( ) . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_variableName != null	0.0714285714285714	5	65	protected override void Parse ( List < string > tokens ) { if ( _variableName != null ) ; }	_variableName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	pattern.ToString().Equals("(?-mix:(\\w+)\\s*\\:\\s*((?-mix:(?-mix:\"[^\"]*\"|'[^']*')|(?:[^\\s,\\|'\"]|(?-mix:\"[^\"]*\"|'[^']*'))+)))")	1	95	0	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( pattern . ToString ( ) . Equals ( "(?-mix:(\\w+)\\s*\\:\\s*((?-mix:(?-mix:\"[^\"]*\"|'[^']*')|(?:[^\\s,\\|'\"]|(?-mix:\"[^\"]*\"|'[^']*'))+)))" ) ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	pattern . ToString ( ) . Equals ( "(?-mix:(\\w+)\\s*\\:\\s*((?-mix:(?-mix:\"[^\"]*\"|'[^']*')|(?:[^\\s,\\|'\"]|(?-mix:\"[^\"]*\"|'[^']*'))+)))" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	callback != null	1	95	0	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( callback != null ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	callback != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Block.ContentOfVariable != null	1	97	0	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( DotLiquid . Block . ContentOfVariable != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	DotLiquid . Block . ContentOfVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_proxiedObject != null	1	45	0	internal override object GetObject ( ) { if ( _proxiedObject != null ) ; return _proxiedObject ; }	_proxiedObject != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_context._strainer >= 0	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( _context . _strainer >= 0 ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	_context . _strainer >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Util\R.cs	DotLiquid.Util.R.Scan(System.String input, System.String pattern, System.Action`2<System.String, System.String> callback)	callback >= 0	0.0105263157894737	1	94	public static void Scan ( string input , string pattern , Action < string , string > callback ) { if ( callback >= 0 ) ; foreach ( Match match in Regex . Matches ( input , pattern ) ) callback ( match . Groups [ 1 ] . Value , match . Groups [ 2 ] . Value ) ; }	callback >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'middle'")	0.274509803921569	14	37	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'middle'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'middle'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterValueTypeTransformer(System.Type type, System.Func`2<System.Object, System.Object> func)	type != null	1	17	0	public static void RegisterValueTypeTransformer ( Type type , Func < object , object > func ) { if ( type != null ) ; ValueTypeTransformers [ type ] = func ; }	type != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Block.FullToken != null	1	97	0	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( DotLiquid . Block . FullToken != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	DotLiquid . Block . FullToken != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	_left.ToString().Equals("condition")	0.387096774193548	24	38	private void RecordWhenCondition ( string markup ) { if ( _left . ToString ( ) . Equals ( "condition" ) ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	_left . ToString ( ) . Equals ( "condition" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_variableName.ToString().Equals("products")	0.0571428571428571	4	66	protected override void Parse ( List < string > tokens ) { if ( _variableName . ToString ( ) . Equals ( "products" ) ) ; }	_variableName . ToString ( ) . Equals ( "products" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_value == null	0.577777777777778	26	19	internal override object GetObject ( ) { if ( _value == null ) ; return _proxiedObject ; }	_value == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	context._strainer._context != null	0.690721649484536	67	30	private object RenderInternal ( Context context ) { if ( context . _strainer . _context != null ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	context . _strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.RegisterValueTypeTransformer(System.Type type, System.Func`2<System.Object, System.Object> func)	func != null	1	17	0	public static void RegisterValueTypeTransformer ( Type type , Func < object , object > func ) { if ( func != null ) ; ValueTypeTransformers [ type ] = func ; }	func != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_methods != null	1	86	0	public object Invoke ( string method , List < object > args ) { if ( _methods != null ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	_methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Block.IsTag != null	1	97	0	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( DotLiquid . Block . IsTag != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	DotLiquid . Block . IsTag != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_variableName.ToString().Equals("products[0]")	0.157142857142857	11	59	protected override void Parse ( List < string > tokens ) { if ( _variableName . ToString ( ) . Equals ( "products[0]" ) ) ; }	_variableName . ToString ( ) . Equals ( "products[0]" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Truncate(System.String input, System.Int32 length, System.String truncateString)	length >= 0	1	10	0	public static string Truncate ( string input , int length , string truncateString ) { if ( length >= 0 ) ; else public static string Truncate ( string input , int length = 50 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; int l = length - truncateString . Length ; return input . Length > length ? input . Substring ( 0 , l < 0 ? 0 : l ) + truncateString : input ; } }	length >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	_left.ToString().Equals("false")	0.0967741935483871	6	56	private void RecordWhenCondition ( string markup ) { if ( _left . ToString ( ) . Equals ( "false" ) ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	_left . ToString ( ) . Equals ( "false" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Get(System.String key)	_lambda == null	1	83	0	public T Get < T > ( string key ) { if ( _lambda == null ) ; return ( T ) this [ key ] ; }	_lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	_value != null	0.288888888888889	13	32	internal override object GetObject ( ) { if ( _value != null ) ; return _proxiedObject ; }	_value != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'nested'")	0.0980392156862745	5	46	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'nested'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'nested'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetValueTypeTransformer(System.Type type)	DotLiquid.Template.NamingConvention != null	1	97	0	public static Func < object , object > GetValueTypeTransformer ( Type type ) { if ( DotLiquid . Template . NamingConvention != null ) ; if ( ValueTypeTransformers . ContainsKey ( type ) ) return ValueTypeTransformers [ type ] ; foreach ( var interfaceType in ValueTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_name.ToString().Equals("a-dummy")	0.0222222222222222	2	88	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _name . ToString ( ) . Equals ( "a-dummy" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_name . ToString ( ) . Equals ( "a-dummy" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Block.IsVariable != null	1	97	0	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( DotLiquid . Block . IsVariable != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	DotLiquid . Block . IsVariable != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	ret != null	1	45	0	internal override object GetObject ( ) { if ( ret != null ) ; return _proxiedObject ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method != null	1	86	0	public object Invoke ( string method , List < object > args ) { if ( method != null ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	_variableName.ToString().Equals("product")	0.1	7	63	protected override void Parse ( List < string > tokens ) { if ( _variableName . ToString ( ) . Equals ( "product" ) ) ; }	_variableName . ToString ( ) . Equals ( "product" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	_left.ToString().Equals("collection.handle")	0.0483870967741935	3	59	private void RecordWhenCondition ( string markup ) { if ( _left . ToString ( ) . Equals ( "collection.handle" ) ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	_left . ToString ( ) . Equals ( "collection.handle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	context._strainer._context.Equals(context)	0.690721649484536	67	30	private object RenderInternal ( Context context ) { if ( context . _strainer . _context . Equals ( context ) ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	context . _strainer . _context . Equals ( context )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetValueTypeTransformer(System.Type type)	DotLiquid.Template.SafeTypeTransformers != null	1	97	0	public static Func < object , object > GetValueTypeTransformer ( Type type ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; if ( ValueTypeTransformers . ContainsKey ( type ) ) return ValueTypeTransformers [ type ] ; foreach ( var interfaceType in ValueTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.GetObject()	ret.Equals(_proxiedObject)	1	45	0	internal override object GetObject ( ) { if ( ret . Equals ( _proxiedObject ) ) ; return _proxiedObject ; }	ret . Equals ( _proxiedObject )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Parse(System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	70	0	protected override void Parse ( List < string > tokens ) { if ( tokens != null ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	_childCondition._childCondition == null	1	6	0	public void And ( Condition condition ) { if ( _childCondition . _childCondition == null ) ; _childRelation = "and" ; _childCondition = condition ; }	_childCondition . _childCondition == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("cite_funny")	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "cite_funny" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "cite_funny" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	markup == null	0.887096774193548	55	7	private void RecordWhenCondition ( string markup ) { if ( markup == null ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	markup == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetValueTypeTransformer(System.Type type)	DotLiquid.Template.ValueTypeTransformers != null	1	97	0	public static Func < object , object > GetValueTypeTransformer ( Type type ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; if ( ValueTypeTransformers . ContainsKey ( type ) ) return ValueTypeTransformers [ type ] ; foreach ( var interfaceType in ValueTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_allowedMembers.Count == 1	0.844444444444444	38	7	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _allowedMembers . Count == 1 ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_allowedMembers . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'simple'")	0.117647058823529	6	45	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'simple'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'simple'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	list != null	1	97	0	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( list != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	list != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Get(System.String key)	_nestedDictionary != null	1	83	0	public T Get < T > ( string key ) { if ( _nestedDictionary != null ) ; return ( T ) this [ key ] ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("add_smiley")	0.0232558139534884	2	84	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "add_smiley" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "add_smiley" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	markup != null	0.0967741935483871	6	56	private void RecordWhenCondition ( string markup ) { if ( markup != null ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetValueTypeTransformer(System.Type type)	type != null	1	97	0	public static Func < object , object > GetValueTypeTransformer ( Type type ) { if ( type != null ) ; if ( ValueTypeTransformers . ContainsKey ( type ) ) return ValueTypeTransformers [ type ] ; foreach ( var interfaceType in ValueTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	type != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_attributes != null	1	70	0	public override void Render ( Context context , TextWriter result ) { if ( _attributes != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_attributes != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	context._strainer._methods != null	0.690721649484536	67	30	private object RenderInternal ( Context context ) { if ( context . _strainer . _methods != null ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	context . _strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_strainer >= 0	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( _strainer >= 0 ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	_strainer >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_allowedMembers.Count == 2	0.0888888888888889	4	41	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _allowedMembers . Count == 2 ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_allowedMembers . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_reversed == false	0.911111111111111	82	8	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _reversed == false ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_reversed == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName != null	1	70	0	public override void Render ( Context context , TextWriter result ) { if ( _templateName != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'middleunless'")	0.0588235294117647	3	48	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'middleunless'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'middleunless'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetValueTypeTransformer(System.Type type)	ret == null	0.845360824742268	82	15	public static Func < object , object > GetValueTypeTransformer ( Type type ) { if ( ret == null ) ; if ( ValueTypeTransformers . ContainsKey ( type ) ) return ValueTypeTransformers [ type ] ; foreach ( var interfaceType in ValueTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	ret == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("divided_by")	0.0232558139534884	2	84	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "divided_by" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "divided_by" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	markup.ToString().Equals("")	0.112903225806452	7	55	private void RecordWhenCondition ( string markup ) { if ( markup . ToString ( ) . Equals ( "" ) ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	markup . ToString ( ) . Equals ( "" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	97	0	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( context != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_allowedMembers != null	0.266666666666667	12	33	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _allowedMembers != null ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_allowedMembers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	DotLiquid.Strainer.Filters != null	0.690721649484536	67	30	private object RenderInternal ( Context context ) { if ( DotLiquid . Strainer . Filters != null ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	_childCondition._childRelation == null	1	6	0	public void And ( Condition condition ) { if ( _childCondition . _childRelation == null ) ; _childRelation = "and" ; _childCondition = condition ; }	_childCondition . _childRelation == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName >= 0	0.0142857142857143	1	69	public override void Render ( Context context , TextWriter result ) { if ( _templateName >= 0 ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Get(System.String key)	_nestedDictionary >= 0	0.0120481927710843	1	82	public T Get < T > ( string key ) { if ( _nestedDictionary >= 0 ) ; return ( T ) this [ key ] ; }	_nestedDictionary >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetValueTypeTransformer(System.Type type)	ret != null	0.0103092783505155	1	96	public static Func < object , object > GetValueTypeTransformer ( Type type ) { if ( ret != null ) ; if ( ValueTypeTransformers . ContainsKey ( type ) ) return ValueTypeTransformers [ type ] ; foreach ( var interfaceType in ValueTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("strip_newlines")	0.0232558139534884	2	84	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "strip_newlines" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "strip_newlines" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordWhenCondition(System.String markup)	exception != null	0.112903225806452	7	55	private void RecordWhenCondition ( string markup ) { if ( exception != null ) ; while ( markup != null ) { Match whenSyntaxMatch = WhenSyntax . Match ( markup ) ; if ( ! whenSyntaxMatch . Success ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagWhenSyntaxException" ) ) ; markup = whenSyntaxMatch . Groups [ 2 ] . Value ; if ( string . IsNullOrEmpty ( markup ) ) markup = null ; Condition block = new Condition ( _left , "==" , whenSyntaxMatch . Groups [ 1 ] . Value ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; } }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_allowedMembers.All(x => x != null)	0.844444444444444	38	7	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _allowedMembers . All ( x => x != null ) ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_allowedMembers . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	51	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Truncate(System.String input, System.Int32 length, System.String truncateString)	truncateString != null	1	10	0	public static string Truncate ( string input , int length , string truncateString ) { if ( truncateString != null ) ; else public static string Truncate ( string input , int length = 50 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; int l = length - truncateString . Length ; return input . Length > length ? input . Substring ( 0 , l < 0 ? 0 : l ) + truncateString : input ; } }	truncateString != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.RenderInternal(DotLiquid.Context context)	exception != null	0.22680412371134	22	75	private object RenderInternal ( Context context ) { if ( exception != null ) ; if ( Name == null ) return null ; object output = context [ Name ] ; Filters . ToList ( ) . ForEach ( filter => { List < object > filterArgs = filter . Arguments . Select ( a => context [ a ] ) . ToList ( ) ; try { filterArgs . Insert ( 0 , output ) ; output = context . Invoke ( filter . Name , filterArgs ) ; } catch ( FilterNotFoundException ex ) { throw new FilterNotFoundException ( string . Format ( Liquid . ResourceManager . GetString ( "VariableFilterNotFoundException" ) , filter . Name , _markup . Trim ( ) ) , ex ) ; } } ) ; if ( output is IValueTypeConvertible ) output = ( ( IValueTypeConvertible ) output ) . ConvertToValueType ( ) ; return output ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'doesnotexist'")	0.0428571428571429	3	67	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'doesnotexist'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'doesnotexist'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetSafeTypeTransformer(System.Type type)	DotLiquid.Template.NamingConvention != null	1	70	0	public static Func < object , object > GetSafeTypeTransformer ( Type type ) { if ( DotLiquid . Template . NamingConvention != null ) ; if ( SafeTypeTransformers . ContainsKey ( type ) ) return SafeTypeTransformers [ type ] ; foreach ( var interfaceType in SafeTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	context >= 0	0.0103092783505155	1	96	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( context >= 0 ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	context >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	DotLiquid.Variable.FilterParser != null	1	80	0	internal object Render ( Context context ) { if ( DotLiquid . Variable . FilterParser != null ) ; return RenderInternal ( context ) ; }	DotLiquid . Variable . FilterParser != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_allowedMembers.ToString().All(x => x.Equals("Name"))	0.733333333333333	33	12	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) ) ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_allowedMembers . ToString ( ) . All ( x => x . Equals ( "Name" ) )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("newline_to_br")	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "newline_to_br" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "newline_to_br" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordElseCondition(System.String markup)	_blocks != null	1	27	0	private void RecordElseCondition ( string markup ) { if ( _blocks != null ) ; if ( markup . Trim ( ) != string . Empty ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagElseSyntaxException" ) ) ; ElseCondition block = new ElseCondition ( ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; }	_blocks != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	_variableName != null	1	90	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( _variableName != null ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	_variableName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("notthere")	0.1	7	63	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "notthere" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "notthere" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	51	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetSafeTypeTransformer(System.Type type)	DotLiquid.Template.SafeTypeTransformers != null	1	70	0	public static Func < object , object > GetSafeTypeTransformer ( Type type ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; if ( SafeTypeTransformers . ContainsKey ( type ) ) return SafeTypeTransformers [ type ] ; foreach ( var interfaceType in SafeTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Get(System.String key)	key != null	1	83	0	public T Get < T > ( string key ) { if ( key != null ) ; return ( T ) this [ key ] ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_allowedMembers.ToString().Count == 1	0.844444444444444	38	7	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _allowedMembers . ToString ( ) . Count == 1 ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_allowedMembers . ToString ( ) . Count == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("hi")	0.0465116279069767	4	82	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "hi" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "hi" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordElseCondition(System.String markup)	_left != null	1	27	0	private void RecordElseCondition ( string markup ) { if ( _left != null ) ; if ( markup . Trim ( ) != string . Empty ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagElseSyntaxException" ) ) ; ElseCondition block = new ElseCondition ( ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; }	_left != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	_childRelation != null	1	6	0	public void And ( Condition condition ) { if ( _childRelation != null ) ; _childRelation = "and" ; _childCondition = condition ; }	_childRelation != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'loop'")	0.0857142857142857	6	64	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'loop'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'loop'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetSafeTypeTransformer(System.Type type)	DotLiquid.Template.ValueTypeTransformers != null	1	70	0	public static Func < object , object > GetSafeTypeTransformer ( Type type ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; if ( SafeTypeTransformers . ContainsKey ( type ) ) return SafeTypeTransformers [ type ] ; foreach ( var interfaceType in SafeTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	0.835051546391753	81	16	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup != null	1	80	0	internal object Render ( Context context ) { if ( _markup != null ) ; return RenderInternal ( context ) ; }	_markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("add_tag")	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "add_tag" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "add_tag" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_allowedMembers.ToString().Count == 2	0.0888888888888889	4	41	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _allowedMembers . ToString ( ) . Count == 2 ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_allowedMembers . ToString ( ) . Count == 2
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordElseCondition(System.String markup)	_left.ToString().Equals("a.size")	0.148148148148148	4	23	private void RecordElseCondition ( string markup ) { if ( _left . ToString ( ) . Equals ( "a.size" ) ) ; if ( markup . Trim ( ) != string . Empty ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagElseSyntaxException" ) ) ; ElseCondition block = new ElseCondition ( ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; }	_left . ToString ( ) . Equals ( "a.size" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'locale_variables'")	0.142857142857143	10	60	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'locale_variables'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'locale_variables'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	51	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetSafeTypeTransformer(System.Type type)	type != null	1	70	0	public static Func < object , object > GetSafeTypeTransformer ( Type type ) { if ( type != null ) ; if ( SafeTypeTransformers . ContainsKey ( type ) ) return SafeTypeTransformers [ type ] ; foreach ( var interfaceType in SafeTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	type != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_proxiedObject != null	1	45	0	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _proxiedObject != null ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_proxiedObject != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordElseCondition(System.String markup)	_left.ToString().Equals("collection.handle")	0.333333333333333	9	18	private void RecordElseCondition ( string markup ) { if ( _left . ToString ( ) . Equals ( "collection.handle" ) ) ; if ( markup . Trim ( ) != string . Empty ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagElseSyntaxException" ) ) ; ElseCondition block = new ElseCondition ( ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; }	_left . ToString ( ) . Equals ( "collection.handle" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_strainer._context != null	1	92	0	public object Invoke ( string method , List < object > args ) { if ( _strainer . _context != null ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	_strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName != null	1	90	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName != null ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	tagName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("replace_first")	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "replace_first" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "replace_first" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'product'")	0.128571428571429	9	61	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'product'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'product'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	0.402061855670103	39	58	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( context . _strainer == null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Get(System.String key)	key.ToString().Equals("for")	1	83	0	public T Get < T > ( string key ) { if ( key . ToString ( ) . Equals ( "for" ) ) ; return ( T ) this [ key ] ; }	key . ToString ( ) . Equals ( "for" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetSafeTypeTransformer(System.Type type)	ret == null	0.2	14	56	public static Func < object , object > GetSafeTypeTransformer ( Type type ) { if ( ret == null ) ; if ( SafeTypeTransformers . ContainsKey ( type ) ) return SafeTypeTransformers [ type ] ; foreach ( var interfaceType in SafeTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	ret == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_value == null	0.577777777777778	26	19	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _value == null ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_value == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("'variable'")	0.025	2	78	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "'variable'" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "'variable'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	51	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordElseCondition(System.String markup)	_left.ToString().Equals("condition")	0.111111111111111	3	24	private void RecordElseCondition ( string markup ) { if ( _left . ToString ( ) . Equals ( "condition" ) ) ; if ( markup . Trim ( ) != string . Empty ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagElseSyntaxException" ) ) ; ElseCondition block = new ElseCondition ( ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; }	_left . ToString ( ) . Equals ( "condition" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Truncate(System.String input, System.Int32 length, System.String truncateString)	truncateString.ToString().Equals("...")	1	10	0	public static string Truncate ( string input , int length , string truncateString ) { if ( truncateString . ToString ( ) . Equals ( "..." ) ) ; else public static string Truncate ( string input , int length = 50 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; int l = length - truncateString . Length ; return input . Length > length ? input . Substring ( 0 , l < 0 ? 0 : l ) + truncateString : input ; } }	truncateString . ToString ( ) . Equals ( "..." )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	_childRelation.ToString().Equals("and")	1	6	0	public void And ( Condition condition ) { if ( _childRelation . ToString ( ) . Equals ( "and" ) ) ; _childRelation = "and" ; _childCondition = condition ; }	_childRelation . ToString ( ) . Equals ( "and" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("money")	0.0232558139534884	2	84	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "money" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "money" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'body'")	0.0285714285714286	2	68	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'body'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'body'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Get(System.String key)	ret != null	1	83	0	public T Get < T > ( string key ) { if ( ret != null ) ; return ( T ) this [ key ] ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.GetSafeTypeTransformer(System.Type type)	ret != null	0.628571428571429	44	26	public static Func < object , object > GetSafeTypeTransformer ( Type type ) { if ( ret != null ) ; if ( SafeTypeTransformers . ContainsKey ( type ) ) return SafeTypeTransformers [ type ] ; foreach ( var interfaceType in SafeTypeTransformers . Where ( x => x . Key . IsInterface ) ) { if ( type . GetInterfaces ( ) . Contains ( interfaceType . Key ) ) return interfaceType . Value ; } return null ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	_value != null	0.288888888888889	13	32	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( _value != null ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	_value != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordElseCondition(System.String markup)	markup != null	1	27	0	private void RecordElseCondition ( string markup ) { if ( markup != null ) ; if ( markup . Trim ( ) != string . Empty ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagElseSyntaxException" ) ) ; ElseCondition block = new ElseCondition ( ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("make_funny")	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "make_funny" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "make_funny" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("'pick_a_source'")	0.0428571428571429	3	67	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "'pick_a_source'" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "'pick_a_source'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.Render(DotLiquid.Context context, System.IO.TextWriter result)	exception != null	0.941176470588235	48	3	public override void Render ( Context context , TextWriter result ) { if ( exception != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; object file = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template template = file as Template ; template = template ?? Template . Parse ( file == null ? null : file . ToString ( ) ) ; List < Block > parentBlocks = FindBlocks ( template . Root , null ) ; List < Block > orphanedBlocks = ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) ?? new List < Block > ( ) ; BlockRenderState blockState = BlockRenderState . Find ( context ) ?? new BlockRenderState ( ) ; context . Stack ( ( ) => { context [ "blockstate" ] = blockState ; context [ "extends" ] = new List < Block > ( ) ; foreach ( Block block in NodeList . OfType < Block > ( ) . Concat ( orphanedBlocks ) ) { Block pb = parentBlocks . Find ( b => b . BlockName == block . BlockName ) ; if ( pb != null ) { Block parent ; if ( blockState . Parents . TryGetValue ( block , out parent ) ) blockState . Parents [ pb ] = parent ; pb . AddParent ( blockState . Parents , pb . GetNodeList ( blockState ) ) ; blockState . NodeLists [ pb ] = block . GetNodeList ( blockState ) ; } else if ( IsExtending ( template ) ) { ( ( List < Block > ) context . Scopes [ 0 ] [ "extends" ] ) . Add ( block ) ; } } template . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	97	0	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( result != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Case.cs	DotLiquid.Tags.Case.RecordElseCondition(System.String markup)	markup.ToString().Equals("")	1	27	0	private void RecordElseCondition ( string markup ) { if ( markup . ToString ( ) . Equals ( "" ) ) ; if ( markup . Trim ( ) != string . Empty ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "CaseTagElseSyntaxException" ) ) ; ElseCondition block = new ElseCondition ( ) ; block . Attach ( NodeList ) ; _blocks . Add ( block ) ; }	markup . ToString ( ) . Equals ( "" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("'from instance assigns' ")	0.0375	3	77	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "'frominstanceassigns'" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "'frominstanceassigns'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	type != null	1	45	0	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( type != null ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	type != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	DotLiquid.Template.NamingConvention != null	1	97	0	public static Template Parse ( string source ) { if ( DotLiquid . Template . NamingConvention != null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	exception != null	0.536082474226804	52	45	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( exception != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Get(System.String key)	ret >= 0	0.0120481927710843	1	82	public T Get < T > ( string key ) { if ( ret >= 0 ) ; return ( T ) this [ key ] ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tagName.ToString().Equals("for")	1	90	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tagName . ToString ( ) . Equals ( "for" ) ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	tagName . ToString ( ) . Equals ( "for" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("date")	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "date" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "date" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_templateName.ToString().Equals("template")	0.0142857142857143	1	69	public override void Render ( Context context , TextWriter result ) { if ( _templateName . ToString ( ) . Equals ( "template" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_templateName . ToString ( ) . Equals ( "template" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.FindBlocks(System.Object node, System.Collections.Generic.List`1<DotLiquid.Tags.Block> blocks)	_templateName != null	1	4	0	private List < Block > FindBlocks ( object node , List < Block > blocks ) { if ( _templateName != null ) ; if ( blocks == null ) blocks = new List < Block > ( ) ; if ( node . RespondTo ( "NodeList" ) ) { List < object > nodeList = ( List < object > ) node . Send ( "NodeList" ) ; if ( nodeList != null ) { nodeList . ForEach ( n => { Block block = n as Block ; if ( block != null ) { if ( blocks . All ( bl => bl . BlockName != block . BlockName ) ) blocks . Add ( block ) ; } FindBlocks ( n , blocks ) ; } ) ; } } return blocks ; }	_templateName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Drop.cs	DotLiquid.DropProxy.CreateTypeResolution(System.Type type)	ret != null	1	45	0	internal override TypeResolution CreateTypeResolution ( Type type ) { if ( ret != null ) ; return new TypeResolution ( type , mi => _allowedMembers . Contains ( mi . Name ) ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	DotLiquid.Template.SafeTypeTransformers != null	1	97	0	public static Template Parse ( string source ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	condition != null	1	6	0	public void And ( Condition condition ) { if ( condition != null ) ; _childRelation = "and" ; _childCondition = condition ; }	condition != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("values | split: ',' ")	0.025	2	78	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "values|split:','" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "values|split:','" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variableName == null	0.671428571428571	47	23	public override void Render ( Context context , TextWriter result ) { if ( _variableName == null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_variableName == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("modulo")	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "modulo" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "modulo" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context != null	0.597938144329897	58	39	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( context . _strainer . _context != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	context . _strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.FindBlocks(System.Object node, System.Collections.Generic.List`1<DotLiquid.Tags.Block> blocks)	_templateName.ToString().Equals("'complex'")	1	4	0	private List < Block > FindBlocks ( object node , List < Block > blocks ) { if ( _templateName . ToString ( ) . Equals ( "'complex'" ) ) ; if ( blocks == null ) blocks = new List < Block > ( ) ; if ( node . RespondTo ( "NodeList" ) ) { List < object > nodeList = ( List < object > ) node . Send ( "NodeList" ) ; if ( nodeList != null ) { nodeList . ForEach ( n => { Block block = n as Block ; if ( block != null ) { if ( blocks . All ( bl => bl . BlockName != block . BlockName ) ) blocks . Add ( block ) ; } FindBlocks ( n , blocks ) ; } ) ; } } return blocks ; }	_templateName . ToString ( ) . Equals ( "'complex'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	DotLiquid.Template.ValueTypeTransformers != null	1	97	0	public static Template Parse ( string source ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variableName != null	0.0714285714285714	5	65	public override void Render ( Context context , TextWriter result ) { if ( _variableName != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_variableName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.System.Collections.IEnumerable.GetEnumerator()	_defaultValue == null	1	14	0	IEnumerator IEnumerable . GetEnumerator ( ) { if ( _defaultValue == null ) ; return _nestedDictionary . GetEnumerator ( ) ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("remove")	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "remove" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "remove" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Truncate(System.String input, System.Int32 length, System.String truncateString)	ret != null	1	10	0	public static string Truncate ( string input , int length , string truncateString ) { if ( ret != null ) ; else public static string Truncate ( string input , int length = 50 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; int l = length - truncateString . Length ; return input . Length > length ? input . Substring ( 0 , l < 0 ? 0 : l ) + truncateString : input ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	_strainer._methods != null	1	92	0	public object Invoke ( string method , List < object > args ) { if ( _strainer . _methods != null ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	_strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("'foo' ")	0.0125	1	79	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "'foo'" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "'foo'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	source != null	1	97	0	public static Template Parse ( string source ) { if ( source != null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	source != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variableName.ToString().Equals("products")	0.0571428571428571	4	66	public override void Render ( Context context , TextWriter result ) { if ( _variableName . ToString ( ) . Equals ( "products" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_variableName . ToString ( ) . Equals ( "products" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("times")	0.0116279069767442	1	85	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "times" ) ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	method . ToString ( ) . Equals ( "times" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.FindBlocks(System.Object node, System.Collections.Generic.List`1<DotLiquid.Tags.Block> blocks)	node != null	1	4	0	private List < Block > FindBlocks ( object node , List < Block > blocks ) { if ( node != null ) ; if ( blocks == null ) blocks = new List < Block > ( ) ; if ( node . RespondTo ( "NodeList" ) ) { List < object > nodeList = ( List < object > ) node . Send ( "NodeList" ) ; if ( nodeList != null ) { nodeList . ForEach ( n => { Block block = n as Block ; if ( block != null ) { if ( blocks . All ( bl => bl . BlockName != block . BlockName ) ) blocks . Add ( block ) ; } FindBlocks ( n , blocks ) ; } ) ; } } return blocks ; }	node != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	markup != null	1	90	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( markup != null ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	condition.Equals(_childCondition)	1	6	0	public void And ( Condition condition ) { if ( condition . Equals ( _childCondition ) ) ; _childRelation = "and" ; _childCondition = condition ; }	condition . Equals ( _childCondition )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._context.Equals(context)	0.597938144329897	58	39	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( context . _strainer . _context . Equals ( context ) ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	context . _strainer . _context . Equals ( context )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	exception != null	0.865979381443299	84	13	public static Template Parse ( string source ) { if ( exception != null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variableName.ToString().Equals("products[0]")	0.157142857142857	11	59	public override void Render ( Context context , TextWriter result ) { if ( _variableName . ToString ( ) . Equals ( "products[0]" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_variableName . ToString ( ) . Equals ( "products[0]" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	args != null	1	86	0	public object Invoke ( string method , List < object > args ) { if ( args != null ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	args != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.FindBlocks(System.Object node, System.Collections.Generic.List`1<DotLiquid.Tags.Block> blocks)	ret != null	1	4	0	private List < Block > FindBlocks ( object node , List < Block > blocks ) { if ( ret != null ) ; if ( blocks == null ) blocks = new List < Block > ( ) ; if ( node . RespondTo ( "NodeList" ) ) { List < object > nodeList = ( List < object > ) node . Send ( "NodeList" ) ; if ( nodeList != null ) { nodeList . ForEach ( n => { Block block = n as Block ; if ( block != null ) { if ( blocks . All ( bl => bl . BlockName != block . BlockName ) ) blocks . Add ( block ) ; } FindBlocks ( n , blocks ) ; } ) ; } } return blocks ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("var")	0.0125	1	79	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "var" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "var" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.System.Collections.IEnumerable.GetEnumerator()	_lambda == null	1	14	0	IEnumerator IEnumerable . GetEnumerator ( ) { if ( _lambda == null ) ; return _nestedDictionary . GetEnumerator ( ) ; }	_lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variableName.ToString().Equals("product")	0.1	7	63	public override void Render ( Context context , TextWriter result ) { if ( _variableName . ToString ( ) . Equals ( "product" ) ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	_variableName . ToString ( ) . Equals ( "product" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	ret != null	1	97	0	public static Template Parse ( string source ) { if ( ret != null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	ret != null	0.965116279069767	83	3	public object Invoke ( string method , List < object > args ) { if ( ret != null ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	context._strainer._methods != null	0.597938144329897	58	39	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( context . _strainer . _methods != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	context . _strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	70	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Extends.cs	DotLiquid.Tags.Extends.FindBlocks(System.Object node, System.Collections.Generic.List`1<DotLiquid.Tags.Block> blocks)	ret.Equals(blocks)	1	4	0	private List < Block > FindBlocks ( object node , List < Block > blocks ) { if ( ret . Equals ( blocks ) ) ; if ( blocks == null ) blocks = new List < Block > ( ) ; if ( node . RespondTo ( "NodeList" ) ) { List < object > nodeList = ( List < object > ) node . Send ( "NodeList" ) ; if ( nodeList != null ) { nodeList . ForEach ( n => { Block block = n as Block ; if ( block != null ) { if ( blocks . All ( bl => bl . BlockName != block . BlockName ) ) blocks . Add ( block ) ; } FindBlocks ( n , blocks ) ; } ) ; } } return blocks ; }	ret . Equals ( blocks )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	ret._assigns == null	1	97	0	public static Template Parse ( string source ) { if ( ret . _assigns == null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	ret . _assigns == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	ret == 1	0.0697674418604651	6	80	public object Invoke ( string method , List < object > args ) { if ( ret == 1 ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.System.Collections.IEnumerable.GetEnumerator()	_nestedDictionary != null	1	14	0	IEnumerator IEnumerable . GetEnumerator ( ) { if ( _nestedDictionary != null ) ; return _nestedDictionary . GetEnumerator ( ) ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("2.5 ")	0.0125	1	79	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "2.5" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "2.5" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	DotLiquid.Strainer.Filters != null	1	92	0	public object Invoke ( string method , List < object > args ) { if ( DotLiquid . Strainer . Filters != null ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Initialize(System.String tagName, System.String markup, System.Collections.Generic.List`1<System.String> tokens)	tokens != null	1	90	0	public override void Initialize ( string tagName , string markup , List < string > tokens ) { if ( tokens != null ) ; Match match = Syntax . Match ( markup ) ; if ( match . Success ) { _variableName = match . Groups [ 1 ] . Value ; _collectionName = match . Groups [ 2 ] . Value ; _name = string . Format ( "{0}-{1}" , _variableName , _collectionName ) ; _reversed = ( ! string . IsNullOrEmpty ( match . Groups [ 3 ] . Value ) ) ; _attributes = new Dictionary < string , string > ( Template . NamingConvention . StringComparer ) ; R . Scan ( markup , Liquid . TagAttributes , ( key , value ) => _attributes [ key ] = value ) ; } else { throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ForTagSyntaxException" ) ) ; } base . Initialize ( tagName , markup , tokens ) ; }	tokens != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	condition._childCondition == null	1	6	0	public void And ( Condition condition ) { if ( condition . _childCondition == null ) ; _childRelation = "and" ; _childCondition = condition ; }	condition . _childCondition == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Block.cs	DotLiquid.Block.RenderAll(System.Collections.Generic.List`1<System.Object> list, DotLiquid.Context context, System.IO.TextWriter result)	DotLiquid.Strainer.Filters != null	0.597938144329897	58	39	protected void RenderAll ( List < object > list , Context context , TextWriter result ) { if ( DotLiquid . Strainer . Filters != null ) ; list . ForEach ( token => { try { if ( token is IRenderable ) ( ( IRenderable ) token ) . Render ( context , result ) ; else result . Write ( token . ToString ( ) ) ; } catch ( Exception ex ) { if ( ex . InnerException is LiquidException ) ex = ex . InnerException ; result . Write ( context . HandleError ( ex ) ) ; } } ) ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	0.642857142857143	45	25	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.System.Collections.IEnumerable.GetEnumerator()	ret != null	1	14	0	IEnumerator IEnumerable . GetEnumerator ( ) { if ( ret != null ) ; return _nestedDictionary . GetEnumerator ( ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	ret >= 0	0.27906976744186	24	62	public object Invoke ( string method , List < object > args ) { if ( ret >= 0 ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	ret._errors == null	1	97	0	public static Template Parse ( string source ) { if ( ret . _errors == null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	ret . _errors == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == true	0.185714285714286	13	57	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == true ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	context . _rethrowErrors == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.TruncateWords(System.String input, System.Int32 words, System.String truncateString)	input != null	1	5	0	public static string TruncateWords ( string input , int words , string truncateString ) { if ( input != null ) ; else public static string TruncateWords ( string input , int words = 15 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; var wordList = input . Split ( '' ) . ToList ( ) ; int l = words < 0 ? 0 : words ; return wordList . Count > l ? string . Join ( "" , wordList . Take ( l ) . ToArray ( ) ) + truncateString : input ; } }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	ret._instanceAssigns == null	1	97	0	public static Template Parse ( string source ) { if ( ret . _instanceAssigns == null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	ret . _instanceAssigns == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Strainer.cs	DotLiquid.Strainer.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	ret >= 1	0.0813953488372093	7	79	public object Invoke ( string method , List < object > args ) { if ( ret >= 1 ) ; var methodInfo = _methods [ method ] . FirstOrDefault ( m => m . GetParameters ( ) . Length == args . Count ) ; if ( methodInfo == null ) methodInfo = _methods [ method ] . OrderByDescending ( m => m . GetParameters ( ) . Length ) . First ( ) ; ParameterInfo [ ] parameterInfos = methodInfo . GetParameters ( ) ; if ( parameterInfos . Length > 0 && parameterInfos [ 0 ] . ParameterType == typeof ( Context ) ) args . Insert ( 0 , _context ) ; if ( parameterInfos . Length > args . Count ) for ( int i = args . Count ; i < parameterInfos . Length ; ++ i ) { if ( ( parameterInfos [ i ] . Attributes & ParameterAttributes . HasDefault ) != ParameterAttributes . HasDefault ) throw new SyntaxException ( Liquid . ResourceManager . GetString ( "StrainerFilterHasNoValueException" ) , method , parameterInfos [ i ] . Name ) ; args . Add ( parameterInfos [ i ] . DefaultValue ) ; } try { return methodInfo . Invoke ( null , args . ToArray ( ) ) ; } catch ( TargetInvocationException ex ) { throw ex . InnerException ; } }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("value ")	0.0125	1	79	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "value" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "value" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	70	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Parse(System.String source)	ret._registers == null	1	97	0	public static Template Parse ( string source ) { if ( ret . _registers == null ) ; Template template = new Template ( ) ; template . ParseInternal ( source ) ; return template ; }	ret . _registers == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.Collections.Generic.KeyValuePair`2<System.String, System.Object> item)	_defaultValue == null	1	8	0	public void Add ( KeyValuePair < string , object > item ) { if ( _defaultValue == null ) ; ( ( IDictionary < string , object > ) _nestedDictionary ) . Add ( item ) ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_attributes != null	1	83	0	public override void Render ( Context context , TextWriter result ) { if ( _attributes != null ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_attributes != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	70	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.And(DotLiquid.Condition condition)	condition._childRelation == null	1	6	0	public void And ( Condition condition ) { if ( condition . _childRelation == null ) ; _childRelation = "and" ; _childCondition = condition ; }	condition . _childRelation == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("values ")	0.025	2	78	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "values" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "values" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	DotLiquid.Template.NamingConvention != null	1	97	0	internal Template ParseInternal ( string source ) { if ( DotLiquid . Template . NamingConvention != null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\Include.cs	DotLiquid.Tags.Include.Render(DotLiquid.Context context, System.IO.TextWriter result)	exception != null	0.928571428571429	65	5	public override void Render ( Context context , TextWriter result ) { if ( exception != null ) ; IFileSystem fileSystem = context . Registers [ "file_system" ] as IFileSystem ?? Template . FileSystem ; string source = fileSystem . ReadTemplateFile ( context , _templateName ) ; Template partial = Template . Parse ( source ) ; string shortenedTemplateName = _templateName . Substring ( 1 , _templateName . Length - 2 ) ; object variable = context [ _variableName ?? shortenedTemplateName ] ; context . Stack ( ( ) => { foreach ( var keyValue in _attributes ) context [ keyValue . Key ] = context [ keyValue . Value ] ; if ( variable is IEnumerable ) { ( ( IEnumerable ) variable ) . Cast < object > ( ) . ToList ( ) . ForEach ( v => { context [ shortenedTemplateName ] = v ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; return ; } context [ shortenedTemplateName ] = variable ; partial . Render ( result , RenderParameters . FromContext ( context ) ) ; } ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Attach(System.Collections.Generic.List`1<System.Object> attachment)	DotLiquid.Condition.Operators != null	1	56	0	public List < object > Attach ( List < object > attachment ) { if ( DotLiquid . Condition . Operators != null ) ; Attachment = attachment ; return attachment ; }	DotLiquid . Condition . Operators != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.Collections.Generic.KeyValuePair`2<System.String, System.Object> item)	_lambda == null	1	8	0	public void Add ( KeyValuePair < string , object > item ) { if ( _lambda == null ) ; ( ( IDictionary < string , object > ) _nestedDictionary ) . Add ( item ) ; }	_lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	DotLiquid.Template.SafeTypeTransformers != null	1	97	0	internal Template ParseInternal ( string source ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method != null	1	92	0	public object Invoke ( string method , List < object > args ) { if ( method != null ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("decimal ")	0.0125	1	79	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "decimal" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "decimal" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	DotLiquid.Template.ValueTypeTransformers != null	1	97	0	internal Template ParseInternal ( string source ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_attributes >= 0	0.0240963855421687	2	81	public override void Render ( Context context , TextWriter result ) { if ( _attributes >= 0 ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_attributes >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.Collections.Generic.KeyValuePair`2<System.String, System.Object> item)	_nestedDictionary != null	1	8	0	public void Add ( KeyValuePair < string , object > item ) { if ( _nestedDictionary != null ) ; ( ( IDictionary < string , object > ) _nestedDictionary ) . Add ( item ) ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.TruncateWords(System.String input, System.Int32 words, System.String truncateString)	words >= 0	1	5	0	public static string TruncateWords ( string input , int words , string truncateString ) { if ( words >= 0 ) ; else public static string TruncateWords ( string input , int words = 15 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; var wordList = input . Split ( '' ) . ToList ( ) ; int l = words < 0 ? 0 : words ; return wordList . Count > l ? string . Join ( "" , wordList . Take ( l ) . ToArray ( ) ) + truncateString : input ; } }	words >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_assigns == null	0.824742268041237	80	17	internal Template ParseInternal ( string source ) { if ( _assigns == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_assigns == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	_markup.ToString().Equals("2,5 ")	0.0125	1	79	internal object Render ( Context context ) { if ( _markup . ToString ( ) . Equals ( "2,5" ) ) ; return RenderInternal ( context ) ; }	_markup . ToString ( ) . Equals ( "2,5" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Attach(System.Collections.Generic.List`1<System.Object> attachment)	_childCondition == null	1	56	0	public List < object > Attach ( List < object > attachment ) { if ( _childCondition == null ) ; Attachment = attachment ; return attachment ; }	_childCondition == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.Collections.Generic.KeyValuePair`2<System.String, System.Object> item)	item != null	1	8	0	public void Add ( KeyValuePair < string , object > item ) { if ( item != null ) ; ( ( IDictionary < string , object > ) _nestedDictionary ) . Add ( item ) ; }	item != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_errors == null	0.824742268041237	80	17	internal Template ParseInternal ( string source ) { if ( _errors == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_errors == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName != null	1	83	0	public override void Render ( Context context , TextWriter result ) { if ( _collectionName != null ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_collectionName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	context != null	1	80	0	internal object Render ( Context context ) { if ( context != null ) ; return RenderInternal ( context ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_instanceAssigns == null	0.824742268041237	80	17	internal Template ParseInternal ( string source ) { if ( _instanceAssigns == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_instanceAssigns == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Contains(System.Object key)	_defaultValue == null	1	61	0	public bool Contains ( object key ) { if ( _defaultValue == null ) ; return ( ( IDictionary ) _nestedDictionary ) . Contains ( key ) ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Attach(System.Collections.Generic.List`1<System.Object> attachment)	_childRelation == null	1	56	0	public List < object > Attach ( List < object > attachment ) { if ( _childRelation == null ) ; Attachment = attachment ; return attachment ; }	_childRelation == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	context >= 0	0.0125	1	79	internal object Render ( Context context ) { if ( context >= 0 ) ; return RenderInternal ( context ) ; }	context >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("cite_funny")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "cite_funny" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "cite_funny" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_registers == null	0.824742268041237	80	17	internal Template ParseInternal ( string source ) { if ( _registers == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_registers == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.TruncateWords(System.String input, System.Int32 words, System.String truncateString)	truncateString != null	1	5	0	public static string TruncateWords ( string input , int words , string truncateString ) { if ( truncateString != null ) ; else public static string TruncateWords ( string input , int words = 15 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; var wordList = input . Split ( '' ) . ToList ( ) ; int l = words < 0 ? 0 : words ; return wordList . Count > l ? string . Join ( "" , wordList . Take ( l ) . ToArray ( ) ) + truncateString : input ; } }	truncateString != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName.ToString().Equals("array")	0.0963855421686747	8	75	public override void Render ( Context context , TextWriter result ) { if ( _collectionName . ToString ( ) . Equals ( "array" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_collectionName . ToString ( ) . Equals ( "array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Contains(System.Object key)	_lambda == null	1	61	0	public bool Contains ( object key ) { if ( _lambda == null ) ; return ( ( IDictionary ) _nestedDictionary ) . Contains ( key ) ; }	_lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	source != null	1	97	0	internal Template ParseInternal ( string source ) { if ( source != null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	source != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	context._rethrowErrors == false	1	80	0	internal object Render ( Context context ) { if ( context . _rethrowErrors == false ) ; return RenderInternal ( context ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	exception != null	0.865979381443299	84	13	internal Template ParseInternal ( string source ) { if ( exception != null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Attach(System.Collections.Generic.List`1<System.Object> attachment)	attachment != null	1	56	0	public List < object > Attach ( List < object > attachment ) { if ( attachment != null ) ; Attachment = attachment ; return attachment ; }	attachment != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Contains(System.Object key)	_nestedDictionary != null	1	61	0	public bool Contains ( object key ) { if ( _nestedDictionary != null ) ; return ( ( IDictionary ) _nestedDictionary ) . Contains ( key ) ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	context._strainer == null	0.8625	69	11	internal object Render ( Context context ) { if ( context . _strainer == null ) ; return RenderInternal ( context ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName.ToString().Equals("(1..2)")	0.036144578313253	3	80	public override void Render ( Context context , TextWriter result ) { if ( _collectionName . ToString ( ) . Equals ( "(1..2)" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_collectionName . ToString ( ) . Equals ( "(1..2)" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	ret != null	1	97	0	internal Template ParseInternal ( string source ) { if ( ret != null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Attach(System.Collections.Generic.List`1<System.Object> attachment)	ret != null	1	56	0	public List < object > Attach ( List < object > attachment ) { if ( ret != null ) ; Attachment = attachment ; return attachment ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	ret._assigns == null	0.824742268041237	80	17	internal Template ParseInternal ( string source ) { if ( ret . _assigns == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	ret . _assigns == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	context._strainer != null	0.025	2	78	internal object Render ( Context context ) { if ( context . _strainer != null ) ; return RenderInternal ( context ) ; }	context . _strainer != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Contains(System.Object key)	key != null	1	61	0	public bool Contains ( object key ) { if ( key != null ) ; return ( ( IDictionary ) _nestedDictionary ) . Contains ( key ) ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("divided_by")	0.0217391304347826	2	90	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "divided_by" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "divided_by" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	ret != null	1	80	0	internal object Render ( Context context ) { if ( ret != null ) ; return RenderInternal ( context ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Contains(System.Object key)	ret == true	0.786885245901639	48	13	public bool Contains ( object key ) { if ( ret == true ) ; return ( ( IDictionary ) _nestedDictionary ) . Contains ( key ) ; }	ret == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	ret == 1	0.0625	5	75	internal object Render ( Context context ) { if ( ret == 1 ) ; return RenderInternal ( context ) ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName.ToString().Equals("collection")	0.0120481927710843	1	82	public override void Render ( Context context , TextWriter result ) { if ( _collectionName . ToString ( ) . Equals ( "collection" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_collectionName . ToString ( ) . Equals ( "collection" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.TruncateWords(System.String input, System.Int32 words, System.String truncateString)	truncateString.ToString().Equals("...")	1	5	0	public static string TruncateWords ( string input , int words , string truncateString ) { if ( truncateString . ToString ( ) . Equals ( "..." ) ) ; else public static string TruncateWords ( string input , int words = 15 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; var wordList = input . Split ( '' ) . ToList ( ) ; int l = words < 0 ? 0 : words ; return wordList . Count > l ? string . Join ( "" , wordList . Take ( l ) . ToArray ( ) ) + truncateString : input ; } }	truncateString . ToString ( ) . Equals ( "..." )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	ret._assigns.Equals(_assigns)	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( ret . _assigns . Equals ( _assigns ) ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	ret . _assigns . Equals ( _assigns )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Contains(System.Object key)	ret == false	0.0819672131147541	5	56	public bool Contains ( object key ) { if ( ret == false ) ; return ( ( IDictionary ) _nestedDictionary ) . Contains ( key ) ; }	ret == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	ret >= 1	0.0625	5	75	internal object Render ( Context context ) { if ( ret >= 1 ) ; return RenderInternal ( context ) ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	ret >= 0	0.1375	11	69	internal object Render ( Context context ) { if ( ret >= 0 ) ; return RenderInternal ( context ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.Attach(System.Collections.Generic.List`1<System.Object> attachment)	ret.Equals(attachment)	1	56	0	public List < object > Attach ( List < object > attachment ) { if ( ret . Equals ( attachment ) ) ; Attachment = attachment ; return attachment ; }	ret . Equals ( attachment )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	ret._errors == null	0.824742268041237	80	17	internal Template ParseInternal ( string source ) { if ( ret . _errors == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	ret . _errors == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	ret <= 1	0.0625	5	75	internal object Render ( Context context ) { if ( ret <= 1 ) ; return RenderInternal ( context ) ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	DotLiquid.Condition.Operators != null	1	73	0	private static bool EqualVariables ( object left , object right ) { if ( DotLiquid . Condition . Operators != null ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	DotLiquid . Condition . Operators != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	ret._errors.Equals(_errors)	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( ret . _errors . Equals ( _errors ) ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	ret . _errors . Equals ( _errors )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName.ToString().Equals("authors")	0.036144578313253	3	80	public override void Render ( Context context , TextWriter result ) { if ( _collectionName . ToString ( ) . Equals ( "authors" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_collectionName . ToString ( ) . Equals ( "authors" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.ContainsKey(System.String key)	_defaultValue == null	1	97	0	public bool ContainsKey ( string key ) { if ( _defaultValue == null ) ; return _nestedDictionary . ContainsKey ( key ) ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	context._strainer._context != null	0.1375	11	69	internal object Render ( Context context ) { if ( context . _strainer . _context != null ) ; return RenderInternal ( context ) ; }	context . _strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	ret._instanceAssigns == null	0.824742268041237	80	17	internal Template ParseInternal ( string source ) { if ( ret . _instanceAssigns == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	ret . _instanceAssigns == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Variable.cs	DotLiquid.Variable.Render(DotLiquid.Context context)	context._strainer._context.Equals(context)	0.1375	11	69	internal object Render ( Context context ) { if ( context . _strainer . _context . Equals ( context ) ) ; return RenderInternal ( context ) ; }	context . _strainer . _context . Equals ( context )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	ret._instanceAssigns.Equals(_instanceAssigns)	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( ret . _instanceAssigns . Equals ( _instanceAssigns ) ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	ret . _instanceAssigns . Equals ( _instanceAssigns )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("strip_newlines")	0.0217391304347826	2	90	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "strip_newlines" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "strip_newlines" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.ContainsKey(System.String key)	_lambda == null	1	97	0	public bool ContainsKey ( string key ) { if ( _lambda == null ) ; return _nestedDictionary . ContainsKey ( key ) ; }	_lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.TruncateWords(System.String input, System.Int32 words, System.String truncateString)	ret != null	1	5	0	public static string TruncateWords ( string input , int words , string truncateString ) { if ( ret != null ) ; else public static string TruncateWords ( string input , int words = 15 , string truncateString = "..." ) { if ( string . IsNullOrEmpty ( input ) ) return input ; var wordList = input . Split ( '' ) . ToList ( ) ; int l = words < 0 ? 0 : words ; return wordList . Count > l ? string . Join ( "" , wordList . Take ( l ) . ToArray ( ) ) + truncateString : input ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName.ToString().Equals("array.items")	0.072289156626506	6	77	public override void Render ( Context context , TextWriter result ) { if ( _collectionName . ToString ( ) . Equals ( "array.items" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_collectionName . ToString ( ) . Equals ( "array.items" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	left == 1	0.191780821917808	14	59	private static bool EqualVariables ( object left , object right ) { if ( left == 1 ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	left == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	ret._registers == null	0.824742268041237	80	17	internal Template ParseInternal ( string source ) { if ( ret . _registers == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	ret . _registers == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	ret._registers.Equals(_registers)	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( ret . _registers . Equals ( _registers ) ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	ret . _registers . Equals ( _registers )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.ContainsKey(System.String key)	_nestedDictionary != null	1	97	0	public bool ContainsKey ( string key ) { if ( _nestedDictionary != null ) ; return _nestedDictionary . ContainsKey ( key ) ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName.ToString().Equals("product.texts.array")	0.0120481927710843	1	82	public override void Render ( Context context , TextWriter result ) { if ( _collectionName . ToString ( ) . Equals ( "product.texts.array" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_collectionName . ToString ( ) . Equals ( "product.texts.array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_assigns._defaultValue == null	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( _assigns . _defaultValue == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_assigns . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	input != null	0.409090909090909	9	13	public static string [ ] Split ( string input , string pattern ) { if ( input != null ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	left >= 0	0.342465753424658	25	48	private static bool EqualVariables ( object left , object right ) { if ( left >= 0 ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	left >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.ContainsKey(System.String key)	key != null	1	97	0	public bool ContainsKey ( string key ) { if ( key != null ) ; return _nestedDictionary . ContainsKey ( key ) ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_assigns._lambda == null	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( _assigns . _lambda == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_assigns . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("newline_to_br")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "newline_to_br" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "newline_to_br" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName.ToString().Equals("(1..3)")	0.0120481927710843	1	82	public override void Render ( Context context , TextWriter result ) { if ( _collectionName . ToString ( ) . Equals ( "(1..3)" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_collectionName . ToString ( ) . Equals ( "(1..3)" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_assigns._nestedDictionary != null	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( _assigns . _nestedDictionary != null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_assigns . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.ContainsKey(System.String key)	key >= 0	0.0103092783505155	1	96	public bool ContainsKey ( string key ) { if ( key >= 0 ) ; return _nestedDictionary . ContainsKey ( key ) ; }	key >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	left >= 1	0.671232876712329	49	24	private static bool EqualVariables ( object left , object right ) { if ( left >= 1 ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	left >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	input.ToString().Equals("foo,bar,baz")	0.409090909090909	9	13	public static string [ ] Split ( string input , string pattern ) { if ( input . ToString ( ) . Equals ( "foo,bar,baz" ) ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	input . ToString ( ) . Equals ( "foo,bar,baz" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_instanceAssigns._defaultValue == null	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( _instanceAssigns . _defaultValue == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_instanceAssigns . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_collectionName.ToString().Equals("dummy")	0.0481927710843374	4	79	public override void Render ( Context context , TextWriter result ) { if ( _collectionName . ToString ( ) . Equals ( "dummy" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_collectionName . ToString ( ) . Equals ( "dummy" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.ContainsKey(System.String key)	key.ToString().Equals("test")	0.0103092783505155	1	96	public bool ContainsKey ( string key ) { if ( key . ToString ( ) . Equals ( "test" ) ) ; return _nestedDictionary . ContainsKey ( key ) ; }	key . ToString ( ) . Equals ( "test" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_instanceAssigns._lambda == null	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( _instanceAssigns . _lambda == null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_instanceAssigns . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	left <= 1	0.191780821917808	14	59	private static bool EqualVariables ( object left , object right ) { if ( left <= 1 ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	left <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.ContainsKey(System.String key)	ret == false	0.0309278350515464	3	94	public bool ContainsKey ( string key ) { if ( ret == false ) ; return _nestedDictionary . ContainsKey ( key ) ; }	ret == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.ParseInternal(System.String source)	_instanceAssigns._nestedDictionary != null	0.175257731958763	17	80	internal Template ParseInternal ( string source ) { if ( _instanceAssigns . _nestedDictionary != null ) ; source = DotLiquid . Tags . Literal . FromShortHand ( source ) ; source = DotLiquid . Tags . Comment . FromShortHand ( source ) ; Root = new Document ( ) ; Root . Initialize ( null , null , Tokenize ( source ) ) ; return this ; }	_instanceAssigns . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("hi")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "hi" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "hi" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	DotLiquid.Template.NamingConvention != null	1	90	0	public string Render ( ) { if ( DotLiquid . Template . NamingConvention != null ) ; return Render ( new RenderParameters ( ) ) ; }	DotLiquid . Template . NamingConvention != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	input.ToString().Equals("This is a sentence")	0.545454545454545	12	10	public static string [ ] Split ( string input , string pattern ) { if ( input . ToString ( ) . Equals ( "Thisisasentence" ) ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	input . ToString ( ) . Equals ( "Thisisasentence" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name != null	1	83	0	public override void Render ( Context context , TextWriter result ) { if ( _name != null ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	DotLiquid.Template.SafeTypeTransformers != null	1	90	0	public string Render ( ) { if ( DotLiquid . Template . SafeTypeTransformers != null ) ; return Render ( new RenderParameters ( ) ) ; }	DotLiquid . Template . SafeTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	DotLiquid.Template.ValueTypeTransformers != null	1	90	0	public string Render ( ) { if ( DotLiquid . Template . ValueTypeTransformers != null ) ; return Render ( new RenderParameters ( ) ) ; }	DotLiquid . Template . ValueTypeTransformers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.String key, System.Object value)	_defaultValue == null	1	13	0	public void Add ( string key , object value ) { if ( _defaultValue == null ) ; _nestedDictionary . Add ( key , value ) ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	left == null	0.26027397260274	19	54	private static bool EqualVariables ( object left , object right ) { if ( left == null ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	left == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_assigns != null	1	90	0	public string Render ( ) { if ( _assigns != null ) ; return Render ( new RenderParameters ( ) ) ; }	_assigns != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_assigns._defaultValue == null	1	90	0	public string Render ( ) { if ( _assigns . _defaultValue == null ) ; return Render ( new RenderParameters ( ) ) ; }	_assigns . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("item-array")	0.0602409638554217	5	78	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "item-array" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "item-array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.String key, System.Object value)	_lambda == null	1	13	0	public void Add ( string key , object value ) { if ( _lambda == null ) ; _nestedDictionary . Add ( key , value ) ; }	_lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	pattern != null	0.409090909090909	9	13	public static string [ ] Split ( string input , string pattern ) { if ( pattern != null ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	pattern != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_assigns._lambda == null	1	90	0	public string Render ( ) { if ( _assigns . _lambda == null ) ; return Render ( new RenderParameters ( ) ) ; }	_assigns . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("add_tag")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "add_tag" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "add_tag" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_assigns._nestedDictionary != null	1	90	0	public string Render ( ) { if ( _assigns . _nestedDictionary != null ) ; return Render ( new RenderParameters ( ) ) ; }	_assigns . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	left != null	0.219178082191781	16	57	private static bool EqualVariables ( object left , object right ) { if ( left != null ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	left != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.String key, System.Object value)	_nestedDictionary != null	1	13	0	public void Add ( string key , object value ) { if ( _nestedDictionary != null ) ; _nestedDictionary . Add ( key , value ) ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_errors != null	1	90	0	public string Render ( ) { if ( _errors != null ) ; return Render ( new RenderParameters ( ) ) ; }	_errors != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("i-(1..2)")	0.036144578313253	3	80	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "i-(1..2)" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "i-(1..2)" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_instanceAssigns != null	1	90	0	public string Render ( ) { if ( _instanceAssigns != null ) ; return Render ( new RenderParameters ( ) ) ; }	_instanceAssigns != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	pattern.ToString().Equals(",")	0.409090909090909	9	13	public static string [ ] Split ( string input , string pattern ) { if ( pattern . ToString ( ) . Equals ( "," ) ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	pattern . ToString ( ) . Equals ( "," )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.String key, System.Object value)	key != null	1	13	0	public void Add ( string key , object value ) { if ( key != null ) ; _nestedDictionary . Add ( key , value ) ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_instanceAssigns._defaultValue == null	1	90	0	public string Render ( ) { if ( _instanceAssigns . _defaultValue == null ) ; return Render ( new RenderParameters ( ) ) ; }	_instanceAssigns . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	right == 1	0.0273972602739726	2	71	private static bool EqualVariables ( object left , object right ) { if ( right == 1 ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	right == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("i-array")	0.0240963855421687	2	81	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "i-array" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "i-array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_instanceAssigns._lambda == null	1	90	0	public string Render ( ) { if ( _instanceAssigns . _lambda == null ) ; return Render ( new RenderParameters ( ) ) ; }	_instanceAssigns . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_instanceAssigns._nestedDictionary != null	1	90	0	public string Render ( ) { if ( _instanceAssigns . _nestedDictionary != null ) ; return Render ( new RenderParameters ( ) ) ; }	_instanceAssigns . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("replace_first")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "replace_first" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "replace_first" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.String key, System.Object value)	key.ToString().Equals("test")	1	13	0	public void Add ( string key , object value ) { if ( key . ToString ( ) . Equals ( "test" ) ) ; _nestedDictionary . Add ( key , value ) ; }	key . ToString ( ) . Equals ( "test" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_instanceAssigns._nestedDictionary >= 0	0.0111111111111111	1	89	public string Render ( ) { if ( _instanceAssigns . _nestedDictionary >= 0 ) ; return Render ( new RenderParameters ( ) ) ; }	_instanceAssigns . _nestedDictionary >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	pattern.ToString().Equals(" ")	0.545454545454545	12	10	public static string [ ] Split ( string input , string pattern ) { if ( pattern . ToString ( ) . Equals ( "" ) ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	pattern . ToString ( ) . Equals ( "" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("c-collection")	0.0120481927710843	1	82	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "c-collection" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "c-collection" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	right >= 1	0.73972602739726	54	19	private static bool EqualVariables ( object left , object right ) { if ( right >= 1 ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	right >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_registers != null	1	90	0	public string Render ( ) { if ( _registers != null ) ; return Render ( new RenderParameters ( ) ) ; }	_registers != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.String key, System.Object value)	value != null	1	13	0	public void Add ( string key , object value ) { if ( value != null ) ; _nestedDictionary . Add ( key , value ) ; }	value != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_registers._defaultValue == null	1	90	0	public string Render ( ) { if ( _registers . _defaultValue == null ) ; return Render ( new RenderParameters ( ) ) ; }	_registers . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_registers._lambda == null	1	90	0	public string Render ( ) { if ( _registers . _lambda == null ) ; return Render ( new RenderParameters ( ) ) ; }	_registers . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("item-authors")	0.036144578313253	3	80	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "item-authors" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "item-authors" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	ret.Count == 3	0.409090909090909	9	13	public static string [ ] Split ( string input , string pattern ) { if ( ret . Count == 3 ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	ret . Count == 3
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	right >= 0	0.287671232876712	21	52	private static bool EqualVariables ( object left , object right ) { if ( right >= 0 ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	right >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_registers._nestedDictionary != null	1	90	0	public string Render ( ) { if ( _registers . _nestedDictionary != null ) ; return Render ( new RenderParameters ( ) ) ; }	_registers . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Add(System.String key, System.Object value)	value.Equals(key)	1	13	0	public void Add ( string key , object value ) { if ( value . Equals ( key ) ) ; _nestedDictionary . Add ( key , value ) ; }	value . Equals ( key )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Template.cs	DotLiquid.Template.Render()	_registers._nestedDictionary >= 0	0.0111111111111111	1	89	public string Render ( ) { if ( _registers . _nestedDictionary >= 0 ) ; return Render ( new RenderParameters ( ) ) ; }	_registers . _nestedDictionary >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("make_funny")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "make_funny" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "make_funny" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("i-array.items")	0.072289156626506	6	77	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "i-array.items" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "i-array.items" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Remove(System.String key)	_defaultValue == null	1	12	0	public bool Remove ( string key ) { if ( _defaultValue == null ) ; return _nestedDictionary . Remove ( key ) ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	ret != null	0.636363636363636	14	8	public static string [ ] Split ( string input , string pattern ) { if ( ret != null ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	right <= 1	0.0684931506849315	5	68	private static bool EqualVariables ( object left , object right ) { if ( right <= 1 ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	right <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Remove(System.String key)	_lambda != null	1	12	0	public bool Remove ( string key ) { if ( _lambda != null ) ; return _nestedDictionary . Remove ( key ) ; }	_lambda != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("text-product.texts.array")	0.0120481927710843	1	82	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "text-product.texts.array" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "text-product.texts.array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	ret.All(x => x != null)	0.409090909090909	9	13	public static string [ ] Split ( string input , string pattern ) { if ( ret . All ( x => x != null ) ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	ret . All ( x => x != null )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	right == left	0.0136986301369863	1	72	private static bool EqualVariables ( object left , object right ) { if ( right == left ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	right == left
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("money")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "money" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "money" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Remove(System.String key)	_nestedDictionary != null	1	12	0	public bool Remove ( string key ) { if ( _nestedDictionary != null ) ; return _nestedDictionary . Remove ( key ) ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("item-(1..3)")	0.0120481927710843	1	82	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "item-(1..3)" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "item-(1..3)" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Split(System.String input, System.String pattern)	ret.ToString().Count == 3	0.409090909090909	9	13	public static string [ ] Split ( string input , string pattern ) { if ( ret . ToString ( ) . Count == 3 ) ; return input . IsNullOrWhiteSpace ( ) ? new [ ] { input } : input . Split ( new [ ] { pattern } , StringSplitOptions . RemoveEmptyEntries ) ; }	ret . ToString ( ) . Count == 3
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	right >= left	0.150684931506849	11	62	private static bool EqualVariables ( object left , object right ) { if ( right >= left ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	right >= left
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Remove(System.String key)	key != null	1	12	0	public bool Remove ( string key ) { if ( key != null ) ; return _nestedDictionary . Remove ( key ) ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("a-dummy")	0.0240963855421687	2	81	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "a-dummy" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "a-dummy" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Remove(System.String key)	key.ToString().Equals("test")	1	12	0	public bool Remove ( string key ) { if ( key . ToString ( ) . Equals ( "test" ) ) ; return _nestedDictionary . Remove ( key ) ; }	key . ToString ( ) . Equals ( "test" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.StripHtml(System.String input)	ret.ToString().Equals("test")	1	7	0	public static string StripHtml ( string input ) { if ( ret . ToString ( ) . Equals ( "test" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : Regex . Replace ( input , @"<.*?>" , string . Empty ) ; }	ret . ToString ( ) . Equals ( "test" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("times")	0.0217391304347826	2	90	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "times" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "times" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	right <= left	0.150684931506849	11	62	private static bool EqualVariables ( object left , object right ) { if ( right <= left ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	right <= left
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.Remove(System.String key)	ret == true	1	12	0	public bool Remove ( string key ) { if ( ret == true ) ; return _nestedDictionary . Remove ( key ) ; }	ret == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_name.ToString().Equals("i-dummy")	0.0240963855421687	2	81	public override void Render ( Context context , TextWriter result ) { if ( _name . ToString ( ) . Equals ( "i-dummy" ) ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_name . ToString ( ) . Equals ( "i-dummy" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.TryGetValue(System.String key, System.Object value)	_defaultValue == null	1	4	0	public bool TryGetValue ( string key , out object value ) { if ( _defaultValue == null ) ; return _nestedDictionary . TryGetValue ( key , out value ) ; }	_defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.StripNewlines(System.String input)	input != null	1	16	0	public static string StripNewlines ( string input ) { if ( input != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : Regex . Replace ( input , @"(\r?\n)" , String . Empty ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	right == null	0.191780821917808	14	59	private static bool EqualVariables ( object left , object right ) { if ( right == null ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	right == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	_variableName != null	1	83	0	public override void Render ( Context context , TextWriter result ) { if ( _variableName != null ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	_variableName != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.TryGetValue(System.String key, System.Object value)	_lambda == null	1	4	0	public bool TryGetValue ( string key , out object value ) { if ( _lambda == null ) ; return _nestedDictionary . TryGetValue ( key , out value ) ; }	_lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("date")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "date" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "date" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.StripNewlines(System.String input)	ret != null	1	16	0	public static string StripNewlines ( string input ) { if ( ret != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : Regex . Replace ( input , @"(\r?\n)" , String . Empty ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	context != null	1	83	0	public override void Render ( Context context , TextWriter result ) { if ( context != null ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.EqualVariables(System.Object left, System.Object right)	right != null	0.232876712328767	17	56	private static bool EqualVariables ( object left , object right ) { if ( right != null ) ; if ( left is Symbol ) return ( ( Symbol ) left ) . EvaluationFunction ( right ) ; if ( right is Symbol ) return ( ( Symbol ) right ) . EvaluationFunction ( left ) ; if ( left != null && right != null && left . GetType ( ) != right . GetType ( ) ) { try { right = Convert . ChangeType ( right , left . GetType ( ) ) ; } catch ( Exception ) { } } return Equals ( left , right ) ; }	right != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.TryGetValue(System.String key, System.Object value)	_nestedDictionary != null	1	4	0	public bool TryGetValue ( string key , out object value ) { if ( _nestedDictionary != null ) ; return _nestedDictionary . TryGetValue ( key , out value ) ; }	_nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Join(System.Collections.IEnumerable input, System.String glue)	input != null	1	8	0	public static string Join ( IEnumerable input , string glue ) { if ( input != null ) ; else public static string Join ( IEnumerable input , string glue = "" ) { if ( input == null ) return null ; IEnumerable < object > castInput = input . Cast < object > ( ) ; return string . Join ( glue , castInput ) ; } }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._rethrowErrors == false	1	83	0	public override void Render ( Context context , TextWriter result ) { if ( context . _rethrowErrors == false ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	DotLiquid.Condition.Operators != null	1	87	0	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( DotLiquid . Condition . Operators != null ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	DotLiquid . Condition . Operators != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.TryGetValue(System.String key, System.Object value)	key != null	1	4	0	public bool TryGetValue ( string key , out object value ) { if ( key != null ) ; return _nestedDictionary . TryGetValue ( key , out value ) ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("modulo")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "modulo" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "modulo" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Join(System.Collections.IEnumerable input, System.String glue)	glue != null	1	8	0	public static string Join ( IEnumerable input , string glue ) { if ( glue != null ) ; else public static string Join ( IEnumerable input , string glue = "" ) { if ( input == null ) return null ; IEnumerable < object > castInput = input . Cast < object > ( ) ; return string . Join ( glue , castInput ) ; } }	glue != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	context._strainer == null	1	83	0	public override void Render ( Context context , TextWriter result ) { if ( context . _strainer == null ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Hash.cs	DotLiquid.Hash.TryGetValue(System.String key, System.Object value)	key.ToString().Equals("blockstate")	1	4	0	public bool TryGetValue ( string key , out object value ) { if ( key . ToString ( ) . Equals ( "blockstate" ) ) ; return _nestedDictionary . TryGetValue ( key , out value ) ; }	key . ToString ( ) . Equals ( "blockstate" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	left != null	1	87	0	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( left != null ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	left != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Join(System.Collections.IEnumerable input, System.String glue)	ret != null	1	8	0	public static string Join ( IEnumerable input , string glue ) { if ( ret != null ) ; else public static string Join ( IEnumerable input , string glue = "" ) { if ( input == null ) return null ; IEnumerable < object > castInput = input . Cast < object > ( ) ; return string . Join ( glue , castInput ) ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.Render(DotLiquid.Context context, System.IO.TextWriter result)	result != null	1	83	0	public override void Render ( Context context , TextWriter result ) { if ( result != null ) ; context . Registers [ "for" ] = context . Registers [ "for" ] ?? new Hash ( 0 ) ; object collection = context [ _collectionName ] ; if ( ! ( collection is IEnumerable ) ) return ; int from = ( _attributes . ContainsKey ( "offset" ) ) ? ( _attributes [ "offset" ] == "continue" ) ? Convert . ToInt32 ( context . Registers . Get < Hash > ( "for" ) [ _name ] ) : Convert . ToInt32 ( context [ _attributes [ "offset" ] ] ) : 0 ; int ? limit = _attributes . ContainsKey ( "limit" ) ? context [ _attributes [ "limit" ] ] as int ? : null ; int ? to = ( limit != null ) ? ( int ? ) ( limit . Value + from ) : null ; List < object > segment = SliceCollectionUsingEach ( ( IEnumerable ) collection , from , to ) ; if ( ! segment . Any ( ) ) return ; if ( _reversed ) segment . Reverse ( ) ; int length = segment . Count ; context . Registers . Get < Hash > ( "for" ) [ _name ] = from + length ; context . Stack ( ( ) => { for ( var index = 0 ; index < segment . Count ; index ++ ) { var item = segment [ index ] ; context [ _variableName ] = item ; context [ "forloop" ] = Hash . FromAnonymousObject ( new { name = _name , length = length , index = index + 1 , index0 = index , rindex = length - index , rindex0 = length - index - 1 , first = ( index == 0 ) , last = ( index == length - 1 ) } ) ; try { RenderAll ( NodeList , context , result ) ; } catch ( BreakInterrupt ) { break ; } catch ( ContinueInterrupt ) { } } } ) ; }	result != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("split")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "split" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "split" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	collection != null	1	83	0	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( collection != null ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	collection != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Sort(System.Object input, System.String property)	input != null	1	13	0	public static IEnumerable Sort ( object input , string property ) { if ( input != null ) ; else public static IEnumerable Sort ( object input , string property = null ) { List < object > ary ; if ( input is IEnumerable ) ary = ( ( IEnumerable ) input ) . Flatten ( ) . Cast < object > ( ) . ToList ( ) ; else ary = new List < object > ( new [ ] { input } ) ; if ( ! ary . Any ( ) ) return ary ; if ( string . IsNullOrEmpty ( property ) ) ary . Sort ( ) ; else if ( ( ary . All ( o => o is IDictionary ) ) && ( ( IDictionary ) ary . First ( ) ) . Contains ( property ) ) ary . Sort ( ( a , b ) => Comparer . Default . Compare ( ( ( IDictionary ) a ) [ property ] , ( ( IDictionary ) b ) [ property ] ) ) ; else if ( ary . All ( o => o . RespondTo ( property ) ) ) ary . Sort ( ( a , b ) => Comparer . Default . Compare ( a . Send ( property ) , b . Send ( property ) ) ) ; return ary ; } }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	left >= 0	0.0114942528735632	1	86	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( left >= 0 ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	left >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	from == 0	0.469879518072289	39	44	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( from == 0 ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	from == 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Sort(System.Object input, System.String property)	ret != null	1	13	0	public static IEnumerable Sort ( object input , string property ) { if ( ret != null ) ; else public static IEnumerable Sort ( object input , string property = null ) { List < object > ary ; if ( input is IEnumerable ) ary = ( ( IEnumerable ) input ) . Flatten ( ) . Cast < object > ( ) . ToList ( ) ; else ary = new List < object > ( new [ ] { input } ) ; if ( ! ary . Any ( ) ) return ary ; if ( string . IsNullOrEmpty ( property ) ) ary . Sort ( ) ; else if ( ( ary . All ( o => o is IDictionary ) ) && ( ( IDictionary ) ary . First ( ) ) . Contains ( property ) ) ary . Sort ( ( a , b ) => Comparer . Default . Compare ( ( ( IDictionary ) a ) [ property ] , ( ( IDictionary ) b ) [ property ] ) ) ; else if ( ary . All ( o => o . RespondTo ( property ) ) ) ary . Sort ( ( a , b ) => Comparer . Default . Compare ( a . Send ( property ) , b . Send ( property ) ) ) ; return ary ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("remove")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "remove" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "remove" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	left.ToString().Equals("array")	0.0574712643678161	5	82	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( left . ToString ( ) . Equals ( "array" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	left . ToString ( ) . Equals ( "array" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	from >= 0	1	83	0	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( from >= 0 ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	from >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Sort(System.Object input, System.String property)	property.ToString().Equals("a")	1	13	0	public static IEnumerable Sort ( object input , string property ) { if ( property . ToString ( ) . Equals ( "a" ) ) ; else public static IEnumerable Sort ( object input , string property = null ) { List < object > ary ; if ( input is IEnumerable ) ary = ( ( IEnumerable ) input ) . Flatten ( ) . Cast < object > ( ) . ToList ( ) ; else ary = new List < object > ( new [ ] { input } ) ; if ( ! ary . Any ( ) ) return ary ; if ( string . IsNullOrEmpty ( property ) ) ary . Sort ( ) ; else if ( ( ary . All ( o => o is IDictionary ) ) && ( ( IDictionary ) ary . First ( ) ) . Contains ( property ) ) ary . Sort ( ( a , b ) => Comparer . Default . Compare ( ( ( IDictionary ) a ) [ property ] , ( ( IDictionary ) b ) [ property ] ) ) ; else if ( ary . All ( o => o . RespondTo ( property ) ) ) ary . Sort ( ( a , b ) => Comparer . Default . Compare ( a . Send ( property ) , b . Send ( property ) ) ) ; return ary ; } }	property . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	from <= 0	0.469879518072289	39	44	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( from <= 0 ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	from <= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	left.ToString().Equals("a.size")	0.0689655172413793	6	81	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( left . ToString ( ) . Equals ( "a.size" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	left . ToString ( ) . Equals ( "a.size" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	method.ToString().Equals("add_smiley")	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( method . ToString ( ) . Equals ( "add_smiley" ) ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	method . ToString ( ) . Equals ( "add_smiley" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Map(System.Collections.IEnumerable input, System.String property)	input != null	1	10	0	public static IEnumerable Map ( IEnumerable input , string property ) { if ( input != null ) ; List < object > ary = input . Cast < object > ( ) . ToList ( ) ; if ( ! ary . Any ( ) ) return ary ; if ( ( ary . All ( o => o is IDictionary ) ) && ( ( IDictionary ) ary . First ( ) ) . Contains ( property ) ) return ary . Select ( e => ( ( IDictionary ) e ) [ property ] ) ; if ( ary . All ( o => o . RespondTo ( property ) ) ) return ary . Select ( e => e . Send ( property ) ) ; return ary ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	from <= 1000	0.120481927710843	10	73	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( from <= 1000 ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	from <= 1000
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Map(System.Collections.IEnumerable input, System.String property)	property != null	1	10	0	public static IEnumerable Map ( IEnumerable input , string property ) { if ( property != null ) ; List < object > ary = input . Cast < object > ( ) . ToList ( ) ; if ( ! ary . Any ( ) ) return ary ; if ( ( ary . All ( o => o is IDictionary ) ) && ( ( IDictionary ) ary . First ( ) ) . Contains ( property ) ) return ary . Select ( e => ( ( IDictionary ) e ) [ property ] ) ; if ( ary . All ( o => o . RespondTo ( property ) ) ) return ary . Select ( e => e . Send ( property ) ) ; return ary ; }	property != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	to == null	0.879518072289157	73	10	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( to == null ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	to == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	left.ToString().Equals("condition")	0.0574712643678161	5	82	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( left . ToString ( ) . Equals ( "condition" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	left . ToString ( ) . Equals ( "condition" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	args != null	1	92	0	public object Invoke ( string method , List < object > args ) { if ( args != null ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	args != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Map(System.Collections.IEnumerable input, System.String property)	ret != null	1	10	0	public static IEnumerable Map ( IEnumerable input , string property ) { if ( ret != null ) ; List < object > ary = input . Cast < object > ( ) . ToList ( ) ; if ( ! ary . Any ( ) ) return ary ; if ( ( ary . All ( o => o is IDictionary ) ) && ( ( IDictionary ) ary . First ( ) ) . Contains ( property ) ) return ary . Select ( e => ( ( IDictionary ) e ) [ property ] ) ; if ( ary . All ( o => o . RespondTo ( property ) ) ) return ary . Select ( e => e . Send ( property ) ) ; return ary ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	to >= 0	0.518072289156627	43	40	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( to >= 0 ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	to >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	left.ToString().Equals("1")	0.0229885057471264	2	85	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( left . ToString ( ) . Equals ( "1" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	left . ToString ( ) . Equals ( "1" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	to >= from	0.433734939759036	36	47	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( to >= from ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	to >= from
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	args >= 0	0.0108695652173913	1	91	public object Invoke ( string method , List < object > args ) { if ( args >= 0 ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	args >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Replace(System.String input, System.String string, System.String replacement)	input != null	1	7	0	public static string Replace ( string input , string @string , string replacement ) { if ( input != null ) ; else public static string Replace ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; return string . IsNullOrEmpty ( input ) ? input : Regex . Replace ( input , @string , replacement ) ; } }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	ret != null	1	83	0	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( ret != null ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	ret >= 0	0.036144578313253	3	80	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( ret >= 0 ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	left.ToString().Equals("'bob'")	0.0344827586206897	3	84	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( left . ToString ( ) . Equals ( "'bob'" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	left . ToString ( ) . Equals ( "'bob'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	ret != null	0.880434782608696	81	11	public object Invoke ( string method , List < object > args ) { if ( ret != null ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Replace(System.String input, System.String string, System.String replacement)	input.ToString().Equals("a a a a")	1	7	0	public static string Replace ( string input , string @string , string replacement ) { if ( input . ToString ( ) . Equals ( "aaaa" ) ) ; else public static string Replace ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; return string . IsNullOrEmpty ( input ) ? input : Regex . Replace ( input , @string , replacement ) ; } }	input . ToString ( ) . Equals ( "aaaa" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	ret >= from	0.036144578313253	3	80	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( ret >= from ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	ret >= from
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	left.ToString().Equals("'dave'")	0.0344827586206897	3	84	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( left . ToString ( ) . Equals ( "'dave'" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	left . ToString ( ) . Equals ( "'dave'" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Invoke(System.String method, System.Collections.Generic.List`1<System.Object> args)	ret == 1	0.0760869565217391	7	85	public object Invoke ( string method , List < object > args ) { if ( ret == 1 ) ; if ( Strainer . RespondTo ( method ) ) return Strainer . Invoke ( method , args ) ; return args . First ( ) ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Tags\For.cs	DotLiquid.Tags.For.SliceCollectionUsingEach(System.Collections.IEnumerable collection, System.Int32 from, System.Int32? to)	ret >= to	0.0120481927710843	1	82	private static List < object > SliceCollectionUsingEach ( IEnumerable collection , int from , int ? to ) { if ( ret >= to ) ; List < object > segments = new List < object > ( ) ; int index = 0 ; foreach ( object item in collection ) { if ( to != null && to . Value <= index ) break ; if ( from <= index ) segments . Add ( item ) ; ++ index ; } return segments ; }	ret >= to
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Replace(System.String input, System.String string, System.String replacement)	string != null	1	7	0	public static string Replace ( string input , string @string , string replacement ) { if ( string != null ) ; else public static string Replace ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; return string . IsNullOrEmpty ( input ) ? input : Regex . Replace ( input , @string , replacement ) ; } }	string != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Push(DotLiquid.Hash newScope)	_rethrowErrors == false	0.927835051546392	90	7	public void Push ( Hash newScope ) { if ( _rethrowErrors == false ) ; if ( Scopes . Count > 80 ) throw new StackLevelException ( Liquid . ResourceManager . GetString ( "ContextStackException" ) ) ; Scopes . Insert ( 0 , newScope ) ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	right != null	1	87	0	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( right != null ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	right != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Replace(System.String input, System.String string, System.String replacement)	string.ToString().Equals("a")	1	7	0	public static string Replace ( string input , string @string , string replacement ) { if ( string . ToString ( ) . Equals ( "a" ) ) ; else public static string Replace ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; return string . IsNullOrEmpty ( input ) ? input : Regex . Replace ( input , @string , replacement ) ; } }	string . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Push(DotLiquid.Hash newScope)	_rethrowErrors == true	0.0206185567010309	2	95	public void Push ( Hash newScope ) { if ( _rethrowErrors == true ) ; if ( Scopes . Count > 80 ) throw new StackLevelException ( Liquid . ResourceManager . GetString ( "ContextStackException" ) ) ; Scopes . Insert ( 0 , newScope ) ; }	_rethrowErrors == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	right >= 0	0.0114942528735632	1	86	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( right >= 0 ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	right >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Replace(System.String input, System.String string, System.String replacement)	replacement != null	1	7	0	public static string Replace ( string input , string @string , string replacement ) { if ( replacement != null ) ; else public static string Replace ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; return string . IsNullOrEmpty ( input ) ? input : Regex . Replace ( input , @string , replacement ) ; } }	replacement != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Push(DotLiquid.Hash newScope)	_strainer == null	1	97	0	public void Push ( Hash newScope ) { if ( _strainer == null ) ; if ( Scopes . Count > 80 ) throw new StackLevelException ( Liquid . ResourceManager . GetString ( "ContextStackException" ) ) ; Scopes . Insert ( 0 , newScope ) ; }	_strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	right.ToString().Equals("5")	0.0229885057471264	2	85	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( right . ToString ( ) . Equals ( "5" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	right . ToString ( ) . Equals ( "5" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Replace(System.String input, System.String string, System.String replacement)	replacement.ToString().Equals("b")	1	7	0	public static string Replace ( string input , string @string , string replacement ) { if ( replacement . ToString ( ) . Equals ( "b" ) ) ; else public static string Replace ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; return string . IsNullOrEmpty ( input ) ? input : Regex . Replace ( input , @string , replacement ) ; } }	replacement . ToString ( ) . Equals ( "b" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Push(DotLiquid.Hash newScope)	newScope != null	1	97	0	public void Push ( Hash newScope ) { if ( newScope != null ) ; if ( Scopes . Count > 80 ) throw new StackLevelException ( Liquid . ResourceManager . GetString ( "ContextStackException" ) ) ; Scopes . Insert ( 0 , newScope ) ; }	newScope != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	op != null	1	87	0	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( op != null ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	op != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Replace(System.String input, System.String string, System.String replacement)	ret != null	1	7	0	public static string Replace ( string input , string @string , string replacement ) { if ( ret != null ) ; else public static string Replace ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; return string . IsNullOrEmpty ( input ) ? input : Regex . Replace ( input , @string , replacement ) ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Push(DotLiquid.Hash newScope)	newScope._defaultValue == null	1	97	0	public void Push ( Hash newScope ) { if ( newScope . _defaultValue == null ) ; if ( Scopes . Count > 80 ) throw new StackLevelException ( Liquid . ResourceManager . GetString ( "ContextStackException" ) ) ; Scopes . Insert ( 0 , newScope ) ; }	newScope . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Push(DotLiquid.Hash newScope)	newScope._lambda == null	1	97	0	public void Push ( Hash newScope ) { if ( newScope . _lambda == null ) ; if ( Scopes . Count > 80 ) throw new StackLevelException ( Liquid . ResourceManager . GetString ( "ContextStackException" ) ) ; Scopes . Insert ( 0 , newScope ) ; }	newScope . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	op.ToString().Equals("contains")	0.0574712643678161	5	82	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( op . ToString ( ) . Equals ( "contains" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	op . ToString ( ) . Equals ( "contains" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Replace(System.String input, System.String string, System.String replacement)	ret.ToString().Equals("b b b b")	1	7	0	public static string Replace ( string input , string @string , string replacement ) { if ( ret . ToString ( ) . Equals ( "bbbb" ) ) ; else public static string Replace ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; return string . IsNullOrEmpty ( input ) ? input : Regex . Replace ( input , @string , replacement ) ; } }	ret . ToString ( ) . Equals ( "bbbb" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Push(DotLiquid.Hash newScope)	newScope._nestedDictionary != null	1	97	0	public void Push ( Hash newScope ) { if ( newScope . _nestedDictionary != null ) ; if ( Scopes . Count > 80 ) throw new StackLevelException ( Liquid . ResourceManager . GetString ( "ContextStackException" ) ) ; Scopes . Insert ( 0 , newScope ) ; }	newScope . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	op.ToString().Equals("==")	0.264367816091954	23	64	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( op . ToString ( ) . Equals ( "==" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	op . ToString ( ) . Equals ( "==" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	input != null	0.941176470588235	16	1	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( input != null ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Push(DotLiquid.Hash newScope)	newScope._nestedDictionary >= 0	0.0103092783505155	1	96	public void Push ( Hash newScope ) { if ( newScope . _nestedDictionary >= 0 ) ; if ( Scopes . Count > 80 ) throw new StackLevelException ( Liquid . ResourceManager . GetString ( "ContextStackException" ) ) ; Scopes . Insert ( 0 , newScope ) ; }	newScope . _nestedDictionary >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	op.ToString().Equals("endswith")	0.0574712643678161	5	82	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( op . ToString ( ) . Equals ( "endswith" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	op . ToString ( ) . Equals ( "endswith" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Push(DotLiquid.Hash newScope)	exception != null	0.0309278350515464	3	94	public void Push ( Hash newScope ) { if ( exception != null ) ; if ( Scopes . Count > 80 ) throw new StackLevelException ( Liquid . ResourceManager . GetString ( "ContextStackException" ) ) ; Scopes . Insert ( 0 , newScope ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	input >= 0	0.0588235294117647	1	16	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( input >= 0 ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	input >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Pop()	_rethrowErrors == false	0.927835051546392	90	7	public Hash Pop ( ) { if ( _rethrowErrors == false ) ; if ( Scopes . Count == 1 ) throw new ContextException ( ) ; Hash result = Scopes [ 0 ] ; Scopes . RemoveAt ( 0 ) ; return result ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	input.ToString().Equals("a a a a")	1	17	0	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( input . ToString ( ) . Equals ( "aaaa" ) ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	input . ToString ( ) . Equals ( "aaaa" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	op.ToString().Equals("startswith")	0.0459770114942529	4	83	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( op . ToString ( ) . Equals ( "startswith" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	op . ToString ( ) . Equals ( "startswith" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Pop()	_rethrowErrors == true	0.0206185567010309	2	95	public Hash Pop ( ) { if ( _rethrowErrors == true ) ; if ( Scopes . Count == 1 ) throw new ContextException ( ) ; Hash result = Scopes [ 0 ] ; Scopes . RemoveAt ( 0 ) ; return result ; }	_rethrowErrors == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	string != null	1	17	0	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( string != null ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	string != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	op.ToString().Equals("starts_with")	0.0114942528735632	1	86	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( op . ToString ( ) . Equals ( "starts_with" ) ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	op . ToString ( ) . Equals ( "starts_with" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Pop()	_strainer == null	1	97	0	public Hash Pop ( ) { if ( _strainer == null ) ; if ( Scopes . Count == 1 ) throw new ContextException ( ) ; Hash result = Scopes [ 0 ] ; Scopes . RemoveAt ( 0 ) ; return result ; }	_strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	string.ToString().Equals("a ")	0.588235294117647	10	7	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( string . ToString ( ) . Equals ( "a" ) ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	string . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	context != null	1	87	0	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( context != null ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Pop()	ret != null	1	97	0	public Hash Pop ( ) { if ( ret != null ) ; if ( Scopes . Count == 1 ) throw new ContextException ( ) ; Hash result = Scopes [ 0 ] ; Scopes . RemoveAt ( 0 ) ; return result ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Pop()	ret._defaultValue == null	1	97	0	public Hash Pop ( ) { if ( ret . _defaultValue == null ) ; if ( Scopes . Count == 1 ) throw new ContextException ( ) ; Hash result = Scopes [ 0 ] ; Scopes . RemoveAt ( 0 ) ; return result ; }	ret . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	context._rethrowErrors == false	1	87	0	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( context . _rethrowErrors == false ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	context . _rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	string.ToString().Equals("a")	0.352941176470588	6	11	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( string . ToString ( ) . Equals ( "a" ) ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	string . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Pop()	ret._lambda == null	1	97	0	public Hash Pop ( ) { if ( ret . _lambda == null ) ; if ( Scopes . Count == 1 ) throw new ContextException ( ) ; Hash result = Scopes [ 0 ] ; Scopes . RemoveAt ( 0 ) ; return result ; }	ret . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Pop()	ret._nestedDictionary != null	1	97	0	public Hash Pop ( ) { if ( ret . _nestedDictionary != null ) ; if ( Scopes . Count == 1 ) throw new ContextException ( ) ; Hash result = Scopes [ 0 ] ; Scopes . RemoveAt ( 0 ) ; return result ; }	ret . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	context._strainer == null	1	87	0	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( context . _strainer == null ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	context . _strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	replacement != null	1	17	0	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( replacement != null ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	replacement != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(DotLiquid.Hash newScope, System.Action callback)	_rethrowErrors == false	0.938144329896907	91	6	public void Stack ( Hash newScope , Action callback ) { if ( _rethrowErrors == false ) ; Push ( newScope ) ; try { callback ( ) ; } finally { Pop ( ) ; } }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Condition.cs	DotLiquid.Condition.InterpretCondition(System.String left, System.String right, System.String op, DotLiquid.Context context)	ret == false	0.0919540229885057	8	79	private static bool InterpretCondition ( string left , string right , string op , Context context ) { if ( ret == false ) ; if ( string . IsNullOrEmpty ( op ) ) { object result = context [ left ] ; return ( result != null && ( ! ( result is bool ) || ( bool ) result ) ) ; } object leftObject = context [ left ] ; object rightObject = context [ right ] ; if ( ! Operators . ContainsKey ( op ) ) throw new Exceptions . ArgumentException ( Liquid . ResourceManager . GetString ( "ConditionUnknownOperatorException" ) , op ) ; return Operators [ op ] ( leftObject , rightObject ) ; }	ret == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	replacement.ToString().Equals("")	0.588235294117647	10	7	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( replacement . ToString ( ) . Equals ( "" ) ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	replacement . ToString ( ) . Equals ( "" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(DotLiquid.Hash newScope, System.Action callback)	_rethrowErrors == true	0.0206185567010309	2	95	public void Stack ( Hash newScope , Action callback ) { if ( _rethrowErrors == true ) ; Push ( newScope ) ; try { callback ( ) ; } finally { Pop ( ) ; } }	_rethrowErrors == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	replacement.ToString().Equals("b")	0.352941176470588	6	11	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( replacement . ToString ( ) . Equals ( "b" ) ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	replacement . ToString ( ) . Equals ( "b" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(DotLiquid.Hash newScope, System.Action callback)	_strainer == null	1	97	0	public void Stack ( Hash newScope , Action callback ) { if ( _strainer == null ) ; Push ( newScope ) ; try { callback ( ) ; } finally { Pop ( ) ; } }	_strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	ret != null	1	17	0	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( ret != null ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(DotLiquid.Hash newScope, System.Action callback)	newScope != null	1	97	0	public void Stack ( Hash newScope , Action callback ) { if ( newScope != null ) ; Push ( newScope ) ; try { callback ( ) ; } finally { Pop ( ) ; } }	newScope != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(DotLiquid.Hash newScope, System.Action callback)	newScope._defaultValue == null	1	97	0	public void Stack ( Hash newScope , Action callback ) { if ( newScope . _defaultValue == null ) ; Push ( newScope ) ; try { callback ( ) ; } finally { Pop ( ) ; } }	newScope . _defaultValue == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	ret.ToString().Equals("a a a")	0.588235294117647	10	7	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( ret . ToString ( ) . Equals ( "aaa" ) ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	ret . ToString ( ) . Equals ( "aaa" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(DotLiquid.Hash newScope, System.Action callback)	newScope._lambda == null	1	97	0	public void Stack ( Hash newScope , Action callback ) { if ( newScope . _lambda == null ) ; Push ( newScope ) ; try { callback ( ) ; } finally { Pop ( ) ; } }	newScope . _lambda == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.ReplaceFirst(System.String input, System.String string, System.String replacement)	ret.ToString().Equals("b a a a")	0.352941176470588	6	11	public static string ReplaceFirst ( string input , string @string , string replacement ) { if ( ret . ToString ( ) . Equals ( "baaa" ) ) ; else public static string ReplaceFirst ( string input , string @string , string replacement = "" ) { if ( string . IsNullOrEmpty ( input ) || string . IsNullOrEmpty ( @string ) ) return input ; bool doneReplacement = false ; return Regex . Replace ( input , @string , m => { if ( doneReplacement ) return m . Value ; doneReplacement = true ; return replacement ; } ) ; } }	ret . ToString ( ) . Equals ( "baaa" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(DotLiquid.Hash newScope, System.Action callback)	newScope._nestedDictionary != null	1	97	0	public void Stack ( Hash newScope , Action callback ) { if ( newScope . _nestedDictionary != null ) ; Push ( newScope ) ; try { callback ( ) ; } finally { Pop ( ) ; } }	newScope . _nestedDictionary != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	input != null	0.9375	15	1	public static string Remove ( string input , string @string ) { if ( input != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(DotLiquid.Hash newScope, System.Action callback)	callback != null	1	97	0	public void Stack ( Hash newScope , Action callback ) { if ( callback != null ) ; Push ( newScope ) ; try { callback ( ) ; } finally { Pop ( ) ; } }	callback != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	input >= 0	0.0625	1	15	public static string Remove ( string input , string @string ) { if ( input >= 0 ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	input >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(DotLiquid.Hash newScope, System.Action callback)	exception != null	0.0618556701030928	6	91	public void Stack ( Hash newScope , Action callback ) { if ( exception != null ) ; Push ( newScope ) ; try { callback ( ) ; } finally { Pop ( ) ; } }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	input.ToString().Equals("a a a a")	0.6875	11	5	public static string Remove ( string input , string @string ) { if ( input . ToString ( ) . Equals ( "aaaa" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	input . ToString ( ) . Equals ( "aaaa" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(System.Action callback)	_rethrowErrors == false	0.938144329896907	91	6	public void Stack ( Action callback ) { if ( _rethrowErrors == false ) ; Stack ( new Hash ( ) , callback ) ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	input.ToString().Equals("foo|bar")	0.3125	5	11	public static string Remove ( string input , string @string ) { if ( input . ToString ( ) . Equals ( "foo|bar" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	input . ToString ( ) . Equals ( "foo|bar" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(System.Action callback)	_rethrowErrors == true	0.0206185567010309	2	95	public void Stack ( Action callback ) { if ( _rethrowErrors == true ) ; Stack ( new Hash ( ) , callback ) ; }	_rethrowErrors == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	string != null	1	16	0	public static string Remove ( string input , string @string ) { if ( string != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	string != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	string.ToString().Equals("a")	0.6875	11	5	public static string Remove ( string input , string @string ) { if ( string . ToString ( ) . Equals ( "a" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	string . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(System.Action callback)	_strainer == null	1	97	0	public void Stack ( Action callback ) { if ( _strainer == null ) ; Stack ( new Hash ( ) , callback ) ; }	_strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	string.ToString().Equals("|")	0.3125	5	11	public static string Remove ( string input , string @string ) { if ( string . ToString ( ) . Equals ( "|" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	string . ToString ( ) . Equals ( "|" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(System.Action callback)	callback != null	1	97	0	public void Stack ( Action callback ) { if ( callback != null ) ; Stack ( new Hash ( ) , callback ) ; }	callback != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	ret != null	1	16	0	public static string Remove ( string input , string @string ) { if ( ret != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Stack(System.Action callback)	exception != null	0.0618556701030928	6	91	public void Stack ( Action callback ) { if ( exception != null ) ; Stack ( new Hash ( ) , callback ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	ret.ToString().Equals("   ")	0.6875	11	5	public static string Remove ( string input , string @string ) { if ( ret . ToString ( ) . Equals ( "" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	ret . ToString ( ) . Equals ( "" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Remove(System.String input, System.String string)	ret.ToString().Equals("foobar")	0.3125	5	11	public static string Remove ( string input , string @string ) { if ( ret . ToString ( ) . Equals ( "foobar" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : input . Replace ( @string , string . Empty ) ; }	ret . ToString ( ) . Equals ( "foobar" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	_rethrowErrors == false	0.855670103092783	83	14	private object Resolve ( string key ) { if ( _rethrowErrors == false ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.RemoveFirst(System.String input, System.String string)	input != null	0.909090909090909	10	1	public static string RemoveFirst ( string input , string @string ) { if ( input != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : ReplaceFirst ( input , @string , string . Empty ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.RemoveFirst(System.String input, System.String string)	input >= 0	0.0909090909090909	1	10	public static string RemoveFirst ( string input , string @string ) { if ( input >= 0 ) ; return input . IsNullOrWhiteSpace ( ) ? input : ReplaceFirst ( input , @string , string . Empty ) ; }	input >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	_strainer == null	0.649484536082474	63	34	private object Resolve ( string key ) { if ( _strainer == null ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	_strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.RemoveFirst(System.String input, System.String string)	input.ToString().Equals("a a a a")	1	11	0	public static string RemoveFirst ( string input , string @string ) { if ( input . ToString ( ) . Equals ( "aaaa" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : ReplaceFirst ( input , @string , string . Empty ) ; }	input . ToString ( ) . Equals ( "aaaa" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	_strainer >= 0	0.0103092783505155	1	96	private object Resolve ( string key ) { if ( _strainer >= 0 ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	_strainer >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.RemoveFirst(System.String input, System.String string)	string != null	1	11	0	public static string RemoveFirst ( string input , string @string ) { if ( string != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : ReplaceFirst ( input , @string , string . Empty ) ; }	string != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.RemoveFirst(System.String input, System.String string)	string.ToString().Equals("a ")	1	11	0	public static string RemoveFirst ( string input , string @string ) { if ( string . ToString ( ) . Equals ( "a" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : ReplaceFirst ( input , @string , string . Empty ) ; }	string . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.RemoveFirst(System.String input, System.String string)	ret != null	1	11	0	public static string RemoveFirst ( string input , string @string ) { if ( ret != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : ReplaceFirst ( input , @string , string . Empty ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	key != null	1	97	0	private object Resolve ( string key ) { if ( key != null ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.RemoveFirst(System.String input, System.String string)	ret.ToString().Equals("a a a")	1	11	0	public static string RemoveFirst ( string input , string @string ) { if ( ret . ToString ( ) . Equals ( "aaa" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : ReplaceFirst ( input , @string , string . Empty ) ; }	ret . ToString ( ) . Equals ( "aaa" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Append(System.String input, System.String string)	input != null	1	4	0	public static string Append ( string input , string @string ) { if ( input != null ) ; return input == null ? input : input + @string ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	ret != null	0.34020618556701	33	64	private object Resolve ( string key ) { if ( ret != null ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Append(System.String input, System.String string)	input.ToString().Equals("bc")	1	4	0	public static string Append ( string input , string @string ) { if ( input . ToString ( ) . Equals ( "bc" ) ) ; return input == null ? input : input + @string ; }	input . ToString ( ) . Equals ( "bc" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	ret == 1	0.0206185567010309	2	95	private object Resolve ( string key ) { if ( ret == 1 ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Append(System.String input, System.String string)	string != null	1	4	0	public static string Append ( string input , string @string ) { if ( string != null ) ; return input == null ? input : input + @string ; }	string != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Append(System.String input, System.String string)	string.ToString().Equals("d")	1	4	0	public static string Append ( string input , string @string ) { if ( string . ToString ( ) . Equals ( "d" ) ) ; return input == null ? input : input + @string ; }	string . ToString ( ) . Equals ( "d" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	ret == 1000	0.0103092783505155	1	96	private object Resolve ( string key ) { if ( ret == 1000 ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	ret == 1000
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Append(System.String input, System.String string)	ret != null	1	4	0	public static string Append ( string input , string @string ) { if ( ret != null ) ; return input == null ? input : input + @string ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	ret >= 1	0.536082474226804	52	45	private object Resolve ( string key ) { if ( ret >= 1 ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Append(System.String input, System.String string)	ret.ToString().Equals("bcd")	1	4	0	public static string Append ( string input , string @string ) { if ( ret . ToString ( ) . Equals ( "bcd" ) ) ; return input == null ? input : input + @string ; }	ret . ToString ( ) . Equals ( "bcd" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Prepend(System.String input, System.String string)	input != null	1	9	0	public static string Prepend ( string input , string @string ) { if ( input != null ) ; return input == null ? input : @string + input ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	ret >= 0	0.474226804123711	46	51	private object Resolve ( string key ) { if ( ret >= 0 ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Prepend(System.String input, System.String string)	input.ToString().Equals("bc")	1	9	0	public static string Prepend ( string input , string @string ) { if ( input . ToString ( ) . Equals ( "bc" ) ) ; return input == null ? input : @string + input ; }	input . ToString ( ) . Equals ( "bc" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	ret >= 1000	0.0103092783505155	1	96	private object Resolve ( string key ) { if ( ret >= 1000 ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	ret >= 1000
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Prepend(System.String input, System.String string)	string != null	1	9	0	public static string Prepend ( string input , string @string ) { if ( string != null ) ; return input == null ? input : @string + input ; }	string != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Prepend(System.String input, System.String string)	string.ToString().Equals("a")	1	9	0	public static string Prepend ( string input , string @string ) { if ( string . ToString ( ) . Equals ( "a" ) ) ; return input == null ? input : @string + input ; }	string . ToString ( ) . Equals ( "a" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	ret <= 1	0.0206185567010309	2	95	private object Resolve ( string key ) { if ( ret <= 1 ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Prepend(System.String input, System.String string)	ret != null	1	9	0	public static string Prepend ( string input , string @string ) { if ( ret != null ) ; return input == null ? input : @string + input ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Prepend(System.String input, System.String string)	ret.ToString().Equals("abc")	1	9	0	public static string Prepend ( string input , string @string ) { if ( ret . ToString ( ) . Equals ( "abc" ) ) ; return input == null ? input : @string + input ; }	ret . ToString ( ) . Equals ( "abc" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	ret <= 1000	0.0927835051546392	9	88	private object Resolve ( string key ) { if ( ret <= 1000 ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	ret <= 1000
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.NewlineToBr(System.String input)	input != null	1	14	0	public static string NewlineToBr ( string input ) { if ( input != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : Regex . Replace ( input , @"(\r?\n)" , "<br/>$1" ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.NewlineToBr(System.String input)	input.ToString().Equals("a\r\nb\r\nc")	0.571428571428571	8	6	public static string NewlineToBr ( string input ) { if ( input . ToString ( ) . Equals ( "a\r\nb\r\nc" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : Regex . Replace ( input , @"(\r?\n)" , "<br/>$1" ) ; }	input . ToString ( ) . Equals ( "a\r\nb\r\nc" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	_strainer._context != null	0.350515463917526	34	63	private object Resolve ( string key ) { if ( _strainer . _context != null ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	_strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.NewlineToBr(System.String input)	input.ToString().Equals("a\nb\nc")	0.428571428571429	6	8	public static string NewlineToBr ( string input ) { if ( input . ToString ( ) . Equals ( "a\nb\nc" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : Regex . Replace ( input , @"(\r?\n)" , "<br/>$1" ) ; }	input . ToString ( ) . Equals ( "a\nb\nc" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.NewlineToBr(System.String input)	ret != null	1	14	0	public static string NewlineToBr ( string input ) { if ( ret != null ) ; return input . IsNullOrWhiteSpace ( ) ? input : Regex . Replace ( input , @"(\r?\n)" , "<br/>$1" ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	_strainer._methods != null	0.350515463917526	34	63	private object Resolve ( string key ) { if ( _strainer . _methods != null ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	_strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.NewlineToBr(System.String input)	ret.ToString().Equals("a<br />\r\nb<br />\r\nc")	0.571428571428571	8	6	public static string NewlineToBr ( string input ) { if ( ret . ToString ( ) . Equals ( "a<br/>\r\nb<br/>\r\nc" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : Regex . Replace ( input , @"(\r?\n)" , "<br/>$1" ) ; }	ret . ToString ( ) . Equals ( "a<br/>\r\nb<br/>\r\nc" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.NewlineToBr(System.String input)	ret.ToString().Equals("a<br />\nb<br />\nc")	0.428571428571429	6	8	public static string NewlineToBr ( string input ) { if ( ret . ToString ( ) . Equals ( "a<br/>\nb<br/>\nc" ) ) ; return input . IsNullOrWhiteSpace ( ) ? input : Regex . Replace ( input , @"(\r?\n)" , "<br/>$1" ) ; }	ret . ToString ( ) . Equals ( "a<br/>\nb<br/>\nc" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	DotLiquid.Strainer.Filters != null	0.350515463917526	34	63	private object Resolve ( string key ) { if ( DotLiquid . Strainer . Filters != null ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.First(System.Collections.IEnumerable array)	array != null	1	10	0	public static object First ( IEnumerable array ) { if ( array != null ) ; if ( array == null ) return null ; return array . Cast < object > ( ) . FirstOrDefault ( ) ; }	array != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.First(System.Collections.IEnumerable array)	ret == 1	1	10	0	public static object First ( IEnumerable array ) { if ( ret == 1 ) ; if ( array == null ) return null ; return array . Cast < object > ( ) . FirstOrDefault ( ) ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.First(System.Collections.IEnumerable array)	ret == null	1	10	0	public static object First ( IEnumerable array ) { if ( ret == null ) ; if ( array == null ) return null ; return array . Cast < object > ( ) . FirstOrDefault ( ) ; }	ret == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Last(System.Collections.IEnumerable array)	array != null	1	10	0	public static object Last ( IEnumerable array ) { if ( array != null ) ; if ( array == null ) return null ; return array . Cast < object > ( ) . LastOrDefault ( ) ; }	array != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Resolve(System.String key)	exception != null	0.175257731958763	17	80	private object Resolve ( string key ) { if ( exception != null ) ; switch ( key ) { case null : case "nil" : case "null" : case "" : return null ; case "true" : return true ; case "false" : return false ; case "blank" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; case "empty" : return new Symbol ( o => o is IEnumerable && ! ( ( IEnumerable ) o ) . Cast < object > ( ) . Any ( ) ) ; } Match match = Regex . Match ( key , R . Q ( @"^'(.*)'$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^""(.*)""$" ) ) ; if ( match . Success ) return match . Groups [ 1 ] . Value ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d+)$" ) ) ; if ( match . Success ) return Convert . ToInt32 ( match . Groups [ 1 ] . Value ) ; match = Regex . Match ( key , R . Q ( @"^\((\S+)\.\.(\S+)\)$" ) ) ; if ( match . Success ) return Range . Inclusive ( Convert . ToInt32 ( Resolve ( match . Groups [ 1 ] . Value ) ) , Convert . ToInt32 ( Resolve ( match . Groups [ 2 ] . Value ) ) ) ; match = Regex . Match ( key , R . Q ( @"^([+-]?\d[\d\.|\,]+)$" ) ) ; if ( match . Success ) { float result ; if ( float . TryParse ( match . Groups [ 1 ] . Value , out result ) ) return result ; return float . Parse ( match . Groups [ 1 ] . Value , CultureInfo . InvariantCulture ) ; } return Variable ( key ) ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Last(System.Collections.IEnumerable array)	ret >= 0	1	10	0	public static object Last ( IEnumerable array ) { if ( ret >= 0 ) ; if ( array == null ) return null ; return array . Cast < object > ( ) . LastOrDefault ( ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Last(System.Collections.IEnumerable array)	ret == null	1	10	0	public static object Last ( IEnumerable array ) { if ( ret == null ) ; if ( array == null ) return null ; return array . Cast < object > ( ) . LastOrDefault ( ) ; }	ret == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Plus(System.Object input, System.Object operand)	input == 1	1	4	0	public static object Plus ( object input , object operand ) { if ( input == 1 ) ; return input is string ? string . Concat ( input , operand ) : DoMathsOperation ( input , operand , Expression . Add ) ; }	input == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Plus(System.Object input, System.Object operand)	input != null	1	4	0	public static object Plus ( object input , object operand ) { if ( input != null ) ; return input is string ? string . Concat ( input , operand ) : DoMathsOperation ( input , operand , Expression . Add ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	_rethrowErrors == false	0.845360824742268	82	15	private object FindVariable ( string key ) { if ( _rethrowErrors == false ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Plus(System.Object input, System.Object operand)	operand == 1	1	4	0	public static object Plus ( object input , object operand ) { if ( operand == 1 ) ; return input is string ? string . Concat ( input , operand ) : DoMathsOperation ( input , operand , Expression . Add ) ; }	operand == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Plus(System.Object input, System.Object operand)	operand == input	1	4	0	public static object Plus ( object input , object operand ) { if ( operand == input ) ; return input is string ? string . Concat ( input , operand ) : DoMathsOperation ( input , operand , Expression . Add ) ; }	operand == input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	_strainer == null	0.680412371134021	66	31	private object FindVariable ( string key ) { if ( _strainer == null ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	_strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Plus(System.Object input, System.Object operand)	operand != null	1	4	0	public static object Plus ( object input , object operand ) { if ( operand != null ) ; return input is string ? string . Concat ( input , operand ) : DoMathsOperation ( input , operand , Expression . Add ) ; }	operand != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Plus(System.Object input, System.Object operand)	ret >= 0	1	4	0	public static object Plus ( object input , object operand ) { if ( ret >= 0 ) ; return input is string ? string . Concat ( input , operand ) : DoMathsOperation ( input , operand , Expression . Add ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Plus(System.Object input, System.Object operand)	ret != null	1	4	0	public static object Plus ( object input , object operand ) { if ( ret != null ) ; return input is string ? string . Concat ( input , operand ) : DoMathsOperation ( input , operand , Expression . Add ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	input != null	0.571428571428571	4	3	public static object Minus ( object input , object operand ) { if ( input != null ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	key != null	1	97	0	private object FindVariable ( string key ) { if ( key != null ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	input >= 0	0.428571428571429	3	4	public static object Minus ( object input , object operand ) { if ( input >= 0 ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	input >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	operand == 1	0.428571428571429	3	4	public static object Minus ( object input , object operand ) { if ( operand == 1 ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	operand == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	operand >= 0	0.714285714285714	5	2	public static object Minus ( object input , object operand ) { if ( operand >= 0 ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	operand >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	key >= 0	0.0103092783505155	1	96	private object FindVariable ( string key ) { if ( key >= 0 ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	key >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	operand >= 1	0.428571428571429	3	4	public static object Minus ( object input , object operand ) { if ( operand >= 1 ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	operand >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	operand <= 1	0.428571428571429	3	4	public static object Minus ( object input , object operand ) { if ( operand <= 1 ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	operand <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	ret != null	0.34020618556701	33	64	private object FindVariable ( string key ) { if ( ret != null ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	operand <= input	0.428571428571429	3	4	public static object Minus ( object input , object operand ) { if ( operand <= input ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	operand <= input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	ret != null	0.571428571428571	4	3	public static object Minus ( object input , object operand ) { if ( ret != null ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	ret >= 0	0.428571428571429	3	4	public static object Minus ( object input , object operand ) { if ( ret >= 0 ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	ret == 1	0.0309278350515464	3	94	private object FindVariable ( string key ) { if ( ret == 1 ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Minus(System.Object input, System.Object operand)	ret >= operand	0.428571428571429	3	4	public static object Minus ( object input , object operand ) { if ( ret >= operand ) ; return DoMathsOperation ( input , operand , Expression . Subtract ) ; }	ret >= operand
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Times(System.Object input, System.Object operand)	input >= 0	1	8	0	public static object Times ( object input , object operand ) { if ( input >= 0 ) ; return input is string && operand is int ? Enumerable . Repeat ( ( string ) input , ( int ) operand ) : DoMathsOperation ( input , operand , Expression . Multiply ) ; }	input >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	ret >= 1	0.618556701030928	60	37	private object FindVariable ( string key ) { if ( ret >= 1 ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Times(System.Object input, System.Object operand)	input != null	1	8	0	public static object Times ( object input , object operand ) { if ( input != null ) ; return input is string && operand is int ? Enumerable . Repeat ( ( string ) input , ( int ) operand ) : DoMathsOperation ( input , operand , Expression . Multiply ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Times(System.Object input, System.Object operand)	operand >= 0	1	8	0	public static object Times ( object input , object operand ) { if ( operand >= 0 ) ; return input is string && operand is int ? Enumerable . Repeat ( ( string ) input , ( int ) operand ) : DoMathsOperation ( input , operand , Expression . Multiply ) ; }	operand >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Times(System.Object input, System.Object operand)	ret >= 0	1	8	0	public static object Times ( object input , object operand ) { if ( ret >= 0 ) ; return input is string && operand is int ? Enumerable . Repeat ( ( string ) input , ( int ) operand ) : DoMathsOperation ( input , operand , Expression . Multiply ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	ret >= 0	0.257731958762887	25	72	private object FindVariable ( string key ) { if ( ret >= 0 ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Times(System.Object input, System.Object operand)	ret >= input	1	8	0	public static object Times ( object input , object operand ) { if ( ret >= input ) ; return input is string && operand is int ? Enumerable . Repeat ( ( string ) input , ( int ) operand ) : DoMathsOperation ( input , operand , Expression . Multiply ) ; }	ret >= input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Times(System.Object input, System.Object operand)	ret >= operand	1	8	0	public static object Times ( object input , object operand ) { if ( ret >= operand ) ; return input is string && operand is int ? Enumerable . Repeat ( ( string ) input , ( int ) operand ) : DoMathsOperation ( input , operand , Expression . Multiply ) ; }	ret >= operand
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	ret <= 1	0.0412371134020619	4	93	private object FindVariable ( string key ) { if ( ret <= 1 ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Times(System.Object input, System.Object operand)	ret != null	1	8	0	public static object Times ( object input , object operand ) { if ( ret != null ) ; return input is string && operand is int ? Enumerable . Repeat ( ( string ) input , ( int ) operand ) : DoMathsOperation ( input , operand , Expression . Multiply ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DividedBy(System.Object input, System.Object operand)	input >= 0	1	9	0	public static object DividedBy ( object input , object operand ) { if ( input >= 0 ) ; return DoMathsOperation ( input , operand , Expression . Divide ) ; }	input >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DividedBy(System.Object input, System.Object operand)	operand >= 0	1	9	0	public static object DividedBy ( object input , object operand ) { if ( operand >= 0 ) ; return DoMathsOperation ( input , operand , Expression . Divide ) ; }	operand >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	_strainer._context != null	0.319587628865979	31	66	private object FindVariable ( string key ) { if ( _strainer . _context != null ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	_strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DividedBy(System.Object input, System.Object operand)	operand <= input	1	9	0	public static object DividedBy ( object input , object operand ) { if ( operand <= input ) ; return DoMathsOperation ( input , operand , Expression . Divide ) ; }	operand <= input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DividedBy(System.Object input, System.Object operand)	ret >= 0	1	9	0	public static object DividedBy ( object input , object operand ) { if ( ret >= 0 ) ; return DoMathsOperation ( input , operand , Expression . Divide ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DividedBy(System.Object input, System.Object operand)	ret <= input	1	9	0	public static object DividedBy ( object input , object operand ) { if ( ret <= input ) ; return DoMathsOperation ( input , operand , Expression . Divide ) ; }	ret <= input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	_strainer._methods != null	0.319587628865979	31	66	private object FindVariable ( string key ) { if ( _strainer . _methods != null ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	_strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Modulo(System.Object input, System.Object operand)	input >= 0	1	7	0	public static object Modulo ( object input , object operand ) { if ( input >= 0 ) ; return DoMathsOperation ( input , operand , Expression . Modulo ) ; }	input >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	DotLiquid.Strainer.Filters != null	0.319587628865979	31	66	private object FindVariable ( string key ) { if ( DotLiquid . Strainer . Filters != null ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Modulo(System.Object input, System.Object operand)	operand >= 0	1	7	0	public static object Modulo ( object input , object operand ) { if ( operand >= 0 ) ; return DoMathsOperation ( input , operand , Expression . Modulo ) ; }	operand >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Modulo(System.Object input, System.Object operand)	ret == 1	1	7	0	public static object Modulo ( object input , object operand ) { if ( ret == 1 ) ; return DoMathsOperation ( input , operand , Expression . Modulo ) ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.Modulo(System.Object input, System.Object operand)	ret <= input	1	7	0	public static object Modulo ( object input , object operand ) { if ( ret <= input ) ; return DoMathsOperation ( input , operand , Expression . Modulo ) ; }	ret <= input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.FindVariable(System.String key)	exception != null	0.0618556701030928	6	91	private object FindVariable ( string key ) { if ( exception != null ) ; Hash scope = Scopes . FirstOrDefault ( s => s . ContainsKey ( key ) ) ; object variable = null ; if ( scope == null ) { foreach ( Hash e in Environments ) if ( ( variable = LookupAndEvaluate ( e , key ) ) != null ) { scope = e ; break ; } } scope = scope ?? Environments . LastOrDefault ( ) ?? Scopes . Last ( ) ; variable = variable ?? LookupAndEvaluate ( scope , key ) ; variable = Liquidize ( variable ) ; if ( variable is IContextAware ) ( ( IContextAware ) variable ) . Context = this ; return variable ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	input == 1	0.125	4	28	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( input == 1 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	input == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	input >= 0	0.84375	27	5	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( input >= 0 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	input >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	input >= 1	0.125	4	28	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( input >= 1 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	input >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	_rethrowErrors == false	0.845360824742268	82	15	private object Variable ( string markup ) { if ( _rethrowErrors == false ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	input <= 1	0.125	4	28	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( input <= 1 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	input <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	input != null	0.125	4	28	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( input != null ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	input != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	operand == 1	0.21875	7	25	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( operand == 1 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	operand == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	_strainer == null	0.680412371134021	66	31	private object Variable ( string markup ) { if ( _strainer == null ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	_strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	operand >= 0	0.8125	26	6	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( operand >= 0 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	operand >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	operand >= 1	0.21875	7	25	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( operand >= 1 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	operand >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	operand <= 1	0.21875	7	25	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( operand <= 1 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	operand <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	markup != null	1	97	0	private object Variable ( string markup ) { if ( markup != null ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	markup != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	operand == input	0.125	4	28	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( operand == input ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	operand == input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	operand >= input	0.15625	5	27	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( operand >= input ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	operand >= input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	operand <= input	0.5	16	16	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( operand <= input ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	operand <= input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	markup >= 0	0.0103092783505155	1	96	private object Variable ( string markup ) { if ( markup >= 0 ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	markup >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	operation != null	1	32	0	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( operation != null ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	operation != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	ret == 1	0.1875	6	26	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( ret == 1 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	ret >= 0	0.75	24	8	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( ret >= 0 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	ret != null	0.319587628865979	31	66	private object Variable ( string markup ) { if ( ret != null ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	ret >= 1	0.21875	7	25	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( ret >= 1 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	ret <= 1	0.1875	6	26	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( ret <= 1 ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	ret == 1	0.0206185567010309	2	95	private object Variable ( string markup ) { if ( ret == 1 ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	ret >= input	0.28125	9	23	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( ret >= input ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	ret >= input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	ret <= input	0.5	16	16	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( ret <= input ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	ret <= input
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	ret >= 0	0.350515463917526	34	63	private object Variable ( string markup ) { if ( ret >= 0 ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StandardFilters.DoMathsOperation(System.Object input, System.Object operand, System.Func`3<System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.BinaryExpression> operation)	ret >= operand	0.40625	13	19	private static object DoMathsOperation ( object input , object operand , Func < Expression , Expression , BinaryExpression > operation ) { if ( ret >= operand ) ; return input == null || operand == null ? null : ExpressionUtility . CreateExpression ( operation , input . GetType ( ) , operand . GetType ( ) , input . GetType ( ) , true ) . DynamicInvoke ( input , operand ) ; }	ret >= operand
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StringExtensions.IsNullOrWhiteSpace(System.String s)	s != null	0.67948717948718	53	25	public static bool IsNullOrWhiteSpace ( this string s ) { if ( s != null ) ; return string . IsNullOrEmpty ( s ) || s . Trim ( ) . Length == 0 ; }	s != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	ret >= 1	0.587628865979381	57	40	private object Variable ( string markup ) { if ( ret >= 1 ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StringExtensions.IsNullOrWhiteSpace(System.String s)	s >= 0	0.0128205128205128	1	77	public static bool IsNullOrWhiteSpace ( this string s ) { if ( s >= 0 ) ; return string . IsNullOrEmpty ( s ) || s . Trim ( ) . Length == 0 ; }	s >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	ret <= 1	0.0206185567010309	2	95	private object Variable ( string markup ) { if ( ret <= 1 ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StringExtensions.IsNullOrWhiteSpace(System.String s)	s.ToString().Equals("\n                    ")	0.102564102564103	8	70	public static bool IsNullOrWhiteSpace ( this string s ) { if ( s . ToString ( ) . Equals ( "\n" ) ) ; return string . IsNullOrEmpty ( s ) || s . Trim ( ) . Length == 0 ; }	s . ToString ( ) . Equals ( "\n" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StringExtensions.IsNullOrWhiteSpace(System.String s)	s.ToString().Equals("a a a a")	0.0769230769230769	6	72	public static bool IsNullOrWhiteSpace ( this string s ) { if ( s . ToString ( ) . Equals ( "aaaa" ) ) ; return string . IsNullOrEmpty ( s ) || s . Trim ( ) . Length == 0 ; }	s . ToString ( ) . Equals ( "aaaa" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	_strainer._context != null	0.319587628865979	31	66	private object Variable ( string markup ) { if ( _strainer . _context != null ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	_strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StringExtensions.IsNullOrWhiteSpace(System.String s)	s.ToString().Equals("\n                  ")	0.0769230769230769	6	72	public static bool IsNullOrWhiteSpace ( this string s ) { if ( s . ToString ( ) . Equals ( "\n" ) ) ; return string . IsNullOrEmpty ( s ) || s . Trim ( ) . Length == 0 ; }	s . ToString ( ) . Equals ( "\n" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StringExtensions.IsNullOrWhiteSpace(System.String s)	s.ToString().Equals("This is a sentence")	0.0384615384615385	3	75	public static bool IsNullOrWhiteSpace ( this string s ) { if ( s . ToString ( ) . Equals ( "Thisisasentence" ) ) ; return string . IsNullOrEmpty ( s ) || s . Trim ( ) . Length == 0 ; }	s . ToString ( ) . Equals ( "Thisisasentence" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	_strainer._methods != null	0.319587628865979	31	66	private object Variable ( string markup ) { if ( _strainer . _methods != null ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	_strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StringExtensions.IsNullOrWhiteSpace(System.String s)	s.ToString().Equals("foo,bar,baz")	0.0128205128205128	1	77	public static bool IsNullOrWhiteSpace ( this string s ) { if ( s . ToString ( ) . Equals ( "foo,bar,baz" ) ) ; return string . IsNullOrEmpty ( s ) || s . Trim ( ) . Length == 0 ; }	s . ToString ( ) . Equals ( "foo,bar,baz" )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StringExtensions.IsNullOrWhiteSpace(System.String s)	ret == true	0.230769230769231	18	60	public static bool IsNullOrWhiteSpace ( this string s ) { if ( ret == true ) ; return string . IsNullOrEmpty ( s ) || s . Trim ( ) . Length == 0 ; }	ret == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	DotLiquid.Strainer.Filters != null	0.319587628865979	31	66	private object Variable ( string markup ) { if ( DotLiquid . Strainer . Filters != null ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\StandardFilters.cs	DotLiquid.StringExtensions.IsNullOrWhiteSpace(System.String s)	ret == false	0.166666666666667	13	65	public static bool IsNullOrWhiteSpace ( this string s ) { if ( ret == false ) ; return string . IsNullOrEmpty ( s ) || s . Trim ( ) . Length == 0 ; }	ret == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Variable(System.String markup)	exception != null	0.175257731958763	17	80	private object Variable ( string markup ) { if ( exception != null ) ; List < string > parts = R . Scan ( markup , Liquid . VariableParser ) ; Regex squareBracketed = new Regex ( R . Q ( @"^\[(.*)\]$" ) ) ; string firstPart = parts . Shift ( ) ; Match firstPartSquareBracketedMatch = squareBracketed . Match ( firstPart ) ; if ( firstPartSquareBracketedMatch . Success ) firstPart = Resolve ( firstPartSquareBracketedMatch . Groups [ 1 ] . Value ) . ToString ( ) ; object @object ; if ( ( @object = FindVariable ( firstPart ) ) != null ) { foreach ( string forEachPart in parts ) { Match partSquareBracketedMatch = squareBracketed . Match ( forEachPart ) ; bool partResolved = partSquareBracketedMatch . Success ; object part = forEachPart ; if ( partResolved ) part = Resolve ( partSquareBracketedMatch . Groups [ 1 ] . Value ) ; if ( @object is KeyValuePair < string , object > && ( ( KeyValuePair < string , object > ) @object ) . Key == ( string ) part ) { object res = ( ( KeyValuePair < string , object > ) @object ) . Value ; @object = Liquidize ( res ) ; } else if ( IsHashOrArrayLikeObject ( @object , part ) ) { object res = LookupAndEvaluate ( @object , part ) ; @object = Liquidize ( res ) ; } else if ( ! partResolved && ( @object is IEnumerable ) && ( ( part as string ) == "size" || ( part as string ) == "first" || ( part as string ) == "last" ) ) { var castCollection = ( ( IEnumerable ) @object ) . Cast < object > ( ) ; if ( ( part as string ) == "size" ) @object = castCollection . Count ( ) ; else if ( ( part as string ) == "first" ) @object = castCollection . FirstOrDefault ( ) ; else if ( ( part as string ) == "last" ) @object = castCollection . LastOrDefault ( ) ; } else { return null ; } if ( @object is IContextAware ) ( ( IContextAware ) @object ) . Context = this ; } } return @object ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	obj != null	0.958333333333333	92	4	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( obj != null ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	obj != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	part != null	1	96	0	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( part != null ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	part != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	part == 1	0.09375	9	87	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( part == 1 ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	part == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	part == 0	0.0104166666666667	1	95	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( part == 0 ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	part == 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	part >= 1	0.09375	9	87	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( part >= 1 ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	part >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	part >= 0	0.208333333333333	20	76	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( part >= 0 ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	part >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	part <= 1	0.229166666666667	22	74	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( part <= 1 ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	part <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	part <= 0	0.0104166666666667	1	95	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( part <= 0 ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	part <= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	ret == true	0.5	48	48	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( ret == true ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	ret == true
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.IsHashOrArrayLikeObject(System.Object obj, System.Object part)	ret == false	0.09375	9	87	private static bool IsHashOrArrayLikeObject ( object obj , object part ) { if ( ret == false ) ; if ( obj == null ) return false ; if ( ( obj is IDictionary && ( ( IDictionary ) obj ) . Contains ( part ) ) ) return true ; if ( ( obj is IList ) && ( part is int ) ) return true ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) && obj . GetType ( ) . GetProperty ( ( string ) part ) != null ) return true ; if ( ( obj is IIndexable ) && ( ( IIndexable ) obj ) . ContainsKey ( ( string ) part ) ) return true ; return false ; }	ret == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	_rethrowErrors == false	0.835051546391753	81	16	private object LookupAndEvaluate ( object obj , object key ) { if ( _rethrowErrors == false ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	_strainer == null	0.690721649484536	67	30	private object LookupAndEvaluate ( object obj , object key ) { if ( _strainer == null ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	_strainer == null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	obj != null	1	97	0	private object LookupAndEvaluate ( object obj , object key ) { if ( obj != null ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	obj != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	key != null	1	97	0	private object LookupAndEvaluate ( object obj , object key ) { if ( key != null ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	key != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	key == 1	0.0412371134020619	4	93	private object LookupAndEvaluate ( object obj , object key ) { if ( key == 1 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	key == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	key == 0	0.0309278350515464	3	94	private object LookupAndEvaluate ( object obj , object key ) { if ( key == 0 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	key == 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	key >= 1	0.0412371134020619	4	93	private object LookupAndEvaluate ( object obj , object key ) { if ( key >= 1 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	key >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	key >= 0	0.11340206185567	11	86	private object LookupAndEvaluate ( object obj , object key ) { if ( key >= 0 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	key >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	key <= 1	0.11340206185567	11	86	private object LookupAndEvaluate ( object obj , object key ) { if ( key <= 1 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	key <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	key <= 0	0.0309278350515464	3	94	private object LookupAndEvaluate ( object obj , object key ) { if ( key <= 0 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	key <= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	ret != null	0.164948453608247	16	81	private object LookupAndEvaluate ( object obj , object key ) { if ( ret != null ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	ret == 1	0.0618556701030928	6	91	private object LookupAndEvaluate ( object obj , object key ) { if ( ret == 1 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	ret >= 1	0.577319587628866	56	41	private object LookupAndEvaluate ( object obj , object key ) { if ( ret >= 1 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	ret >= 0	0.288659793814433	28	69	private object LookupAndEvaluate ( object obj , object key ) { if ( ret >= 0 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	ret <= 1	0.0721649484536082	7	90	private object LookupAndEvaluate ( object obj , object key ) { if ( ret <= 1 ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	ret <= key	0.0103092783505155	1	96	private object LookupAndEvaluate ( object obj , object key ) { if ( ret <= key ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	ret <= key
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	_strainer._context != null	0.309278350515464	30	67	private object LookupAndEvaluate ( object obj , object key ) { if ( _strainer . _context != null ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	_strainer . _context != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	_strainer._methods != null	0.309278350515464	30	67	private object LookupAndEvaluate ( object obj , object key ) { if ( _strainer . _methods != null ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	_strainer . _methods != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	DotLiquid.Strainer.Filters != null	0.309278350515464	30	67	private object LookupAndEvaluate ( object obj , object key ) { if ( DotLiquid . Strainer . Filters != null ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	DotLiquid . Strainer . Filters != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.LookupAndEvaluate(System.Object obj, System.Object key)	exception != null	0.185567010309278	18	79	private object LookupAndEvaluate ( object obj , object key ) { if ( exception != null ) ; object value ; if ( obj is IDictionary ) value = ( ( IDictionary ) obj ) [ key ] ; else if ( obj is IList ) value = ( ( IList ) obj ) [ ( int ) key ] ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) value = obj . GetType ( ) . GetProperty ( ( string ) key ) . GetValue ( obj , null ) ; else if ( obj is IIndexable ) value = ( ( IIndexable ) obj ) [ key ] ; else throw new NotSupportedException ( ) ; if ( value is Proc ) { object newValue = ( ( Proc ) value ) . Invoke ( this ) ; if ( obj is IDictionary ) ( ( IDictionary ) obj ) [ key ] = newValue ; else if ( obj is IList ) ( ( IList ) obj ) [ ( int ) key ] = newValue ; else if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) obj . GetType ( ) . GetProperty ( ( string ) key ) . SetValue ( obj , newValue , null ) ; else throw new NotSupportedException ( ) ; return newValue ; } return value ; }	exception != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	obj != null	0.288659793814433	28	69	private static object Liquidize ( object obj ) { if ( obj != null ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	obj != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	obj == 1	0.0515463917525773	5	92	private static object Liquidize ( object obj ) { if ( obj == 1 ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	obj == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	obj >= 0	0.34020618556701	33	64	private static object Liquidize ( object obj ) { if ( obj >= 0 ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	obj >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	obj >= 1	0.567010309278351	55	42	private static object Liquidize ( object obj ) { if ( obj >= 1 ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	obj >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	obj <= 1	0.0515463917525773	5	92	private static object Liquidize ( object obj ) { if ( obj <= 1 ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	obj <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	ret != null	0.288659793814433	28	69	private static object Liquidize ( object obj ) { if ( ret != null ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	ret != null
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	ret.Equals(obj)	0.65979381443299	64	33	private static object Liquidize ( object obj ) { if ( ret . Equals ( obj ) ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	ret . Equals ( obj )
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	ret == 1	0.0515463917525773	5	92	private static object Liquidize ( object obj ) { if ( ret == 1 ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	ret == 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	ret >= 0	0.34020618556701	33	64	private static object Liquidize ( object obj ) { if ( ret >= 0 ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	ret >= 0
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	ret >= 1	0.567010309278351	55	42	private static object Liquidize ( object obj ) { if ( ret >= 1 ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	ret >= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	ret <= 1	0.0515463917525773	5	92	private static object Liquidize ( object obj ) { if ( ret <= 1 ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	ret <= 1
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	ret == obj	0.896907216494845	87	10	private static object Liquidize ( object obj ) { if ( ret == obj ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	ret == obj
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	ret >= obj	0.896907216494845	87	10	private static object Liquidize ( object obj ) { if ( ret >= obj ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	ret >= obj
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.Liquidize(System.Object obj)	ret <= obj	0.896907216494845	87	10	private static object Liquidize ( object obj ) { if ( ret <= obj ) ; if ( obj == null ) return obj ; if ( obj is ILiquidizable ) return ( ( ILiquidizable ) obj ) . ToLiquid ( ) ; if ( obj is string ) return obj ; if ( obj is IEnumerable ) return obj ; if ( obj . GetType ( ) . IsPrimitive ) return obj ; if ( obj is decimal ) return obj ; if ( obj is DateTime ) return obj ; if ( obj is DateTimeOffset ) return obj ; if ( obj is TimeSpan ) return obj ; if ( obj is Guid ) return obj ; if ( TypeUtility . IsAnonymousType ( obj . GetType ( ) ) ) return obj ; if ( obj is KeyValuePair < string , object > ) return obj ; var safeTypeTransformer = Template . GetSafeTypeTransformer ( obj . GetType ( ) ) ; if ( safeTypeTransformer != null ) return safeTypeTransformer ( obj ) ; if ( obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . Any ( ) ) { var attr = ( LiquidTypeAttribute ) obj . GetType ( ) . GetCustomAttributes ( typeof ( LiquidTypeAttribute ) , false ) . First ( ) ; return new DropProxy ( obj , attr . AllowedMembers ) ; } throw new SyntaxException ( Liquid . ResourceManager . GetString ( "ContextObjectInvalidException" ) , obj . ToString ( ) ) ; }	ret <= obj
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.SquashInstanceAssignsWithEnvironments()	_rethrowErrors == false	0.824742268041237	80	17	private void SquashInstanceAssignsWithEnvironments ( ) { if ( _rethrowErrors == false ) ; Dictionary < string , object > tempAssigns = new Dictionary < string , object > ( Template . NamingConvention . StringComparer ) ; Hash lastScope = Scopes . Last ( ) ; foreach ( string k in lastScope . Keys ) foreach ( Hash env in Environments ) if ( env . ContainsKey ( k ) ) { tempAssigns [ k ] = LookupAndEvaluate ( env , k ) ; break ; } foreach ( string k in tempAssigns . Keys ) lastScope [ k ] = tempAssigns [ k ] ; }	_rethrowErrors == false
D:\Data\Code\Invariants\Repos\dotliquid\src\DotLiquid\Context.cs	DotLiquid.Context.SquashInstanceAssignsWithEnvironments()	_strainer == null	1	97	0	private void SquashInstanceAssignsWithEnvironments ( ) { if ( _strainer == null ) ; Dictionary < string , object > tempAssigns = new Dictionary < string , object > ( Template . NamingConvention . StringComparer ) ; Hash lastScope = Scopes . Last ( ) ; foreach ( string k in lastScope . Keys ) foreach ( Hash env in Environments ) if ( env . ContainsKey ( k ) ) { tempAssigns [ k ] = LookupAndEvaluate ( env , k ) ; break ; } foreach ( string k in tempAssigns . Keys ) lastScope [ k ] = tempAssigns [ k ] ; }	_strainer == null
